{"config":{"lang":["en"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"jy-hf\u7684\u4ee3\u7801\u7a7a\u95f4","text":"<p>Welcome to Material for MkDocs.</p>"},{"location":"mkdocs-guide/","title":"\u6b22\u8fce\u6765\u5230JY-HF\u7684\u4ee3\u7801\u7a7a\u95f4","text":"<p>\u4ee5\u4e0b\u7b80\u8981\u4ecb\u7ecd\u672c\u7ad9\u7684\u4e3b\u8981\u5185\u5bb9\u4ee5\u53ca\u642d\u5efa\u3001\u7ef4\u62a4\u7f51\u7ad9\u7684\u65b9\u6cd5\u3001\u66f4\u65b0\u65e5\u5fd7</p>"},{"location":"mkdocs-guide/#_1","title":"\u4e3b\u8981\u5185\u5bb9","text":"<p>\u4e00\u76f4\u5f88\u60f3\u642d\u5efa\u4e2a\u4eba\u7684\u5b66\u4e60\u7f51\u7ad9\uff0c\u5f53\u5185\u5bb9\u5b58\u50a8\u5728\u672c\u5730\u65f6\u867d\u7136\u7ef4\u62a4\u975e\u5e38\u65b9\u4fbf\uff0c\u4f46\u662f\u6709\u4e00\u4e2a\u7edf\u4e00\u6574\u5408\u7684\u9875\u9762\u4f1a\u4fc3\u4f7f\u6211\u53bb\u8bb0\u7b14\u8bb0\u3002\u7ef4\u62a4\u7684\u8fc7\u7a0b\u5e0c\u671b\u4e0d\u8981\u5f62\u5f0f\u5927\u4e8e\u5185\u5bb9\uff0c\u800c\u662f\u80fd\u591f\u4ece\u5b9e\u8d28\u4e0a\u4fc3\u8fdb\u5b66\u4e60\u3002\u5982\u679c\u89c9\u5f97\u91cd\u65b0\u56de\u5f52\u7eb8\u8d28\u5316\u5b66\u4e60\u6548\u7387\u66f4\u9ad8\uff0c\u4e5f\u5b8c\u5168ok~</p>"},{"location":"mkdocs-guide/#1","title":"1\u3001\u8bfe\u5185\u8bfe\u7a0b\u5b66\u4e60\u8d44\u6599","text":"<p>FDS DIP \u7535\u8def\u7535\u5b50\uff0c\u6211\u4e5f\u60f3\u5b66\u590d\u53d8\uff08bushi\uff0c\u4ee5\u540e\u7684\u7ade\u8d5b\u5185\u5bb9\uff0csrtp....</p> <p>\u4ee5\u5f80\u7684\u5fae\u79ef\u5206\uff0c\u7ebf\u4ee3\uff0c\u79bb\u6563\uff0c\u5e38\u5fae\u5206\uff0c\u53ea\u8981\u662f\u786c\u8bfe\uff0c\u5927\u53ef\u5168\u90e8\u4e0a\u4f20</p> <p>\u5f00\u4e2a\u4e13\u697c\u7eaa\u5ff5\uff08\u5f00\u55b7\uff09\u67d0\u51e0\u95e8\u901a\u8bc6\u8bfe</p> <p>\u4e3b\u8981\u652f\u6301markdown\u8bed\u6cd5\uff0c\u4f46\u662f\u53ef\u4ee5\u76f4\u63a5\u4ece\u7f51\u7ad9\u4e0b\u8f7dpdf\u6587\u6863\u54e6~~</p>"},{"location":"mkdocs-guide/#2-blog","title":"2\u3001\u751f\u6d3b \u4e2a\u4ebablog","text":"<p>\u53c2\u8003\u6768xjgg\u7684blog\uff0c\u4ec0\u4e48\u90fd\u53ef\u4ee5\u55b7\uff0c\u4e0a\u4f20\u4e00\u5806\u5806picture</p>"},{"location":"mkdocs-guide/#3","title":"3\u3001\u8bfe\u5916\u81ea\u5b66\u5185\u5bb9\uff0c\u5b9e\u7528\u5de5\u5177\u5b66\u4e60","text":"<p>git bash  shell    linux     \u6444\u5f71\u6280\u672f\uff1f  \u5316\u5986\u6280\u672f       \u8fd0\u52a8\u6280\u5de7...</p>"},{"location":"mkdocs-guide/#4","title":"4\u3001\u60f3\u5bf9\u5f7c\u6b64\u8bf4\u7684\u8bdd\uff0c\u53ef\u4ee5\u52a0\u5bc6\u54e6","text":"<p>[still developing......]</p>"},{"location":"mkdocs-guide/#_2","title":"\u672c\u5730\u90e8\u7f72\u65b9\u5f0f","text":"<p>\u672c\u6587\u6863\u4f7f\u7528 mkdocs \u6784\u5efa\uff0c\u5e76\u4f7f\u7528\u4e86 material \u7b2c\u4e09\u65b9\u4e3b\u9898\uff0c\u4f60\u9700\u8981\u5728\u672c\u5730\u4f9d\u6b21\u5e8f\u5b89\u88c5 Python\u3001mkdocs\u3001material \u4e3b\u9898\u3002</p>"},{"location":"mkdocs-guide/#python","title":"Python \u5b89\u88c5","text":"<p>\u5b98\u7f51\u5b89\u88c5\u6307\u5bfc\u5df2\u7ecf\u7ed9\u51fa\u5404\u7cfb\u7edf\u5b89\u88c5\u65b9\u5f0f\uff0c\u6839\u636e\u5b98\u7f51\u5185\u5bb9\u5b89\u88c5\u5373\u53ef\u3002</p>"},{"location":"mkdocs-guide/#mkdocsmaterial","title":"mkdocs\u3001material \u4e3b\u9898","text":"<p>\u5747\u53ef\u4ee5\u901a\u8fc7 pip\uff08Python \u7684\u5305\u7ba1\u7406\u5668\uff09 \u8fdb\u884c\u5b89\u88c5\u3002</p> <pre><code>$ pip install mkdocs\n$ pip install mkdocs-material\n</code></pre> <p>\u5177\u4f53\u5730\uff0c\u4f60\u53ef\u4ee5\u5206\u522b\u67e5\u770b mkdocs \u7684\u5b89\u88c5\u6307\u5bfc \u4e0e material \u7684\u5b89\u88c5\u6307\u5bfc\u3002</p>"},{"location":"mkdocs-guide/#_3","title":"\u672c\u5730\u6784\u5efa","text":"<p>\u4f60\u53ea\u9700\u8981\u5c06\u672c\u4ed3\u5e93\u62c9\u81f3\u672c\u5730\uff0c\u540e\u4f7f\u7528 <code>mkdocs serve</code> \u90e8\u7f72\u5373\u53ef\u3002</p> <pre><code># \u62c9\u53d6\u4ed3\u5e93\uff0c\u4e24\u8005\u7686\u53ef\n$ git clone git@github.com:little612pea/jy-hf.git\n$ git clone https://github.com/little612pea/jy-hf.git\n# \u6784\u5efa\n$ cd jy-hf\n$ mkdocs serve\n</code></pre> <p>\u5982\u679c\u4f60\u4f7f\u7528\u672c\u5730\u90e8\u7f72\u67e5\u770b\u6587\u6863\uff0c\u8bf7\u5728\u6bcf\u6b21\u4f7f\u7528\u524d\u67e5\u770b\u5e76\u62c9\u53d6\u8fdc\u7a0b\u4ed3\u5e93\u7684 <code>main</code> \u5206\u652f\u66f4\u65b0 <code>git pull</code></p>"},{"location":"mkdocs-guide/#_4","title":"\u5982\u4f55\u642d\u5efa\u7f51\u7ad9","text":"<p>\u539f\u6765\u66fe\u7ecf\u60f3\u81ea\u884c\u7ef4\u62a4\u4e00\u4e2a\u767d\u5ad6\u6765\u76842\u68384G \u963f\u91cc\u4e91\u670d\u52a1\u5668,\u4f7f\u7528wordpress\u7f51\u7ad9\u5efa\u7ad9\uff0c</p> <p>GitHub Pages\u662fGitHub\u63d0\u4f9b\u7684\u4e00\u9879\u514d\u8d39\u9759\u6001\u7f51\u7ad9\u6258\u7ba1\u670d\u52a1\uff0c\u5141\u8bb8\u7528\u6237\u5c06\u4ed6\u4eec\u7684\u9879\u76ee\u6258\u7ba1\u5728GitHub\u4e0a\uff0c\u5e76\u901a\u8fc7GitHub Pages\u670d\u52a1\u53d1\u5e03\u9879\u76ee\u7684\u9759\u6001\u7f51\u7ad9\u3002\u8fd9\u4e2a\u670d\u52a1\u975e\u5e38\u9002\u5408\u7528\u4e8e\u5c55\u793a\u4e2a\u4eba\u3001\u56e2\u961f\u6216\u9879\u76ee\u7684\u6587\u6863\u3001\u535a\u5ba2\u3001\u4f5c\u54c1\u96c6\u7b49\u9759\u6001\u5185\u5bb9\u3002</p> <p>\u4ee5\u4e0b\u662fGitHub Pages\u7684\u4e00\u4e9b\u5173\u952e\u7279\u70b9\u548c\u4fe1\u606f\uff1a</p> <ol> <li>\u514d\u8d39\u6258\u7ba1\uff1a GitHub Pages\u662f\u514d\u8d39\u7684\uff0c\u7528\u6237\u53ef\u4ee5\u5c06\u81ea\u5df1\u7684\u9759\u6001\u7f51\u7ad9\u76f4\u63a5\u6258\u7ba1\u5728GitHub\u4e0a\uff0c\u65e0\u9700\u652f\u4ed8\u989d\u5916\u8d39\u7528\u3002</li> <li>\u57df\u540d\u652f\u6301\uff1a \u7528\u6237\u53ef\u4ee5\u9009\u62e9\u4f7f\u7528GitHub\u63d0\u4f9b\u7684\u9ed8\u8ba4\u57df\u540d\uff08\u5982<code>username.github.io</code>\uff09\uff0c\u4e5f\u53ef\u4ee5\u5c06\u81ea\u5b9a\u4e49\u57df\u540d\u5173\u8054\u5230\u4ed6\u4eec\u7684GitHub Pages\u7f51\u7ad9\u4e0a\u3002</li> <li>\u652f\u6301Jekyll\uff1a GitHub Pages\u539f\u751f\u652f\u6301Jekyll\uff0c\u4e00\u4e2a\u7b80\u5355\u7684\u9759\u6001\u7f51\u7ad9\u751f\u6210\u5668\u3002\u7528\u6237\u53ef\u4ee5\u4f7f\u7528Jekyll\u6765\u81ea\u5b9a\u4e49\u548c\u4f18\u5316\u4ed6\u4eec\u7684\u7f51\u7ad9\uff0c\u6dfb\u52a0\u535a\u5ba2\u3001\u9875\u9762\u5e03\u5c40\u7b49\u3002</li> <li>\u81ea\u52a8\u6784\u5efa\uff1a \u5f53\u7528\u6237\u5c06\u65b0\u7684\u5185\u5bb9\u63a8\u9001\u5230\u4ed6\u4eec\u7684GitHub\u4ed3\u5e93\u65f6\uff0cGitHub Pages\u4f1a\u81ea\u52a8\u91cd\u65b0\u6784\u5efa\u548c\u90e8\u7f72\u7f51\u7ad9\uff0c\u786e\u4fdd\u6700\u65b0\u7684\u5185\u5bb9\u80fd\u591f\u5feb\u901f\u5730\u5728\u7f51\u7ad9\u4e0a\u66f4\u65b0\u3002</li> <li>\u7248\u672c\u63a7\u5236\uff1a \u7531\u4e8eGitHub Pages\u4e0eGitHub\u4ed3\u5e93\u7d27\u5bc6\u96c6\u6210\uff0c\u7528\u6237\u53ef\u4ee5\u5145\u5206\u5229\u7528Git\u7684\u7248\u672c\u63a7\u5236\u529f\u80fd\u6765\u7ba1\u7406\u548c\u8ddf\u8e2a\u7f51\u7ad9\u7684\u53d8\u5316\u3002</li> </ol> <p>\u4f7f\u7528GitHub Pages\u7684\u4e00\u822c\u6b65\u9aa4\u5305\u62ec\uff1a</p> <ul> <li>\u5728GitHub\u4e0a\u521b\u5efa\u4e00\u4e2a\u4ed3\u5e93\uff0c\u4ed3\u5e93\u540d\u5b57\u5e94\u8be5\u662f<code>username.github.io</code>\uff08\u5176\u4e2d<code>username</code>\u662f\u4f60\u7684GitHub\u7528\u6237\u540d\uff09\u6ce8\u610f\uff0c\u8fd9\u91cc\u65b0\u5efa\u7684\u662f\u4e2a\u4eba/\u4f01\u4e1a\u7f51\u7ad9\u7684\u9996\u9875\uff0c\u76f8\u5f53\u4e8e\u670d\u52a1\u5668\u672c\u8eab\uff0c\u5982\u679c\u8981\u65b0\u5efa\u7684\u4ed3\u5e93\u4e0d\u662f\u8fd9\u4e2a\u540d\u79f0\uff0c\u5c31\u53ef\u4ee5\u5728username.github.io/repo_name\u5904\u8bbf\u95ee\uff0c\u76f8\u5f53\u4e8e\u4e00\u4e2a\u7aef\u53e3\u3002\u53ea\u4e0d\u8fc7github pages\u662f\u5e2e\u4f60\u8fd0\u7ef4\u597d\u7684\u670d\u52a1\u5668\uff0c\u6bd4\u8f83\u9760\u8c31</li> <li>\u5728\u4ed3\u5e93\u4e2d\u6dfb\u52a0\u4f60\u7684\u9759\u6001\u7f51\u7ad9\u6587\u4ef6\uff0c\u53ef\u4ee5\u662fHTML\u3001CSS\u3001JavaScript\u7b49\u3002</li> <li>\u5c06\u6587\u4ef6\u63a8\u9001\u5230GitHub\u4ed3\u5e93\u3002</li> <li>\u5728\u4ed3\u5e93\u7684Settings\u9875\u9762\u4e2d\u627e\u5230GitHub Pages\u8bbe\u7f6e\uff0c\u9009\u62e9\u4e3b\u5206\u652f\uff08\u901a\u5e38\u662f<code>main</code>\u6216<code>master</code>\uff09\u4f5c\u4e3a\u6e90\uff0c\u7136\u540e\u4fdd\u5b58\u8bbe\u7f6e\u3002</li> <li>\u5728\u51e0\u5206\u949f\u5185\uff0c\u4f60\u7684\u7f51\u7ad9\u5c31\u4f1a\u5728<code>username.github.io</code>\u4e0a\u53ef\u8bbf\u95ee\u3002</li> </ul> <p>\u603b\u4f53\u800c\u8a00\uff0cGitHub Pages\u662f\u4e00\u4e2a\u65b9\u4fbf\u3001\u7b80\u5355\u4e14\u529f\u80fd\u5f3a\u5927\u7684\u5de5\u5177\uff0c\u9002\u7528\u4e8e\u8bb8\u591a\u4e0d\u540c\u7c7b\u578b\u7684\u9759\u6001\u7f51\u7ad9\u6258\u7ba1\u9700\u6c42\u3002</p>"},{"location":"mkdocs-guide/#github-action-gitlabci","title":"github action \u548c gitlab.ci\u7b49\u5185\u5bb9\u5b9e\u64cd\u539f\u7406\u7b49\u5f85\u540e\u7eed\u5b8c\u5584","text":""},{"location":"mkdocs-guide/#_5","title":"\u5efa\u7ad9\u5177\u4f53\u64cd\u4f5c","text":""},{"location":"mkdocs-guide/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"mkdocs-guide/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre> <p>\u53c2\u8003Material for MkDocs (squidfunk.github.io)\u7ed9\u51fa\u7684\u8be6\u7ec6\u5efa\u7ad9\u8fc7\u7a0b\uff0c\u5927\u4f6c\u7684UI\u671b\u5c18\u83ab\u53ca\u5450</p> <p>\u5b98\u65b9\u6587\u6863\u53c2\u8003\uff1aFor full documentation visit mkdocs.org.</p>"},{"location":"mkdocs-guide/#_6","title":"\u66f4\u65b0\u65e5\u5fd7","text":"<p>11-18 20\uff1a55 \u5f00\u59cb\u5efa\u7ad9</p> <p>11-19 12\uff1a30 \u89e3\u51b3\u5185\u8054\u516c\u5f0f\u65e0\u6cd5\u663e\u793a\u95ee\u9898\uff0c\u4f7f\u7528mathJax\u683c\u5f0f</p> <p>11-19 16\uff1a12 \u57fa\u672c\u5b8c\u6210\u5efa\u7ad9</p> <p>\u63a5\u4e0b\u6765\u8bf7\u51af\u51af\u540c\u5b66\u5e2e\u5fd9\u770b\u770b\u56fe\u7247\u76f8\u5bf9\u8def\u5f84\u8bbe\u7f6e\u600e\u4e48\u65b9\u4fbf\u6e32\u67d3\uff0c\u4f3c\u4e4e\u6e32\u67d3\u4e0d\u4e86html\u683c\u5f0f\uff0c\u5b83\u53ea\u4f1a\u5f62\u5982</p> <p>\"[2-2] (/assets/imgs)\"\u7684\u5f62\u5f0f</p>"},{"location":"1%20%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%20notes/","title":"\u6570\u5b57\u903b\u8f91\u8bbe\u8ba1 notes","text":"<p>SOP\uff1asum of minterms</p> <p>\u5bf9\u51fd\u6570\u6c42complement</p>"},{"location":"1%20%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%20notes/#implicant-squares-in-the-map","title":"Implicant: squares in the map","text":""},{"location":"1%20%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%20notes/#product-term-obtained-by-combining-adjacent-squares-in-the-map-into-a-rectangle-with-the-number-of-squares-a-power-of-2","title":"\uf0a7 product term obtained by combining adjacent squares in the map into a rectangle with the number of squares a power of 2.","text":""},{"location":"1%20%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%20notes/#a-prime-implicant-is-a-product-term-obtained-by-combining-the-maximum-possible-number-of-adjacent-squares-in-the-map-into-a-rectangle-with-the-number-of-squares-a-power-of-2","title":"\uf076A Prime Implicant is a product term obtained by combining the maximum possible number of adjacent squares in the map into a rectangle with the number of squares a power of 2.","text":""},{"location":"1%20%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%20notes/#a-prime-implicant-is-called-an-essential-prime-implicant-if-it-is-the-only-prime-implicant-that-covers-includes-one-or-more-minterms","title":"\uf076A prime implicant is called an Essential Prime Implicant if it is the only prime implicant that covers (includes) one or more minterms.","text":""},{"location":"1%20%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%20notes/#essential-prime-implicant","title":"\u7b80\u5355\u6765\u8bf4\u5c31\u662f\u5982\u679c\u6ca1\u6709\u8fd9\u4e2a\u5708\u6709\u7684\u683c\u5b50\u5c31\u5305\u88f9\u4e0d\u8fdb\u53bb\uff0c\u5c31\u662f essential prime implicant","text":"<p>1.3 implicant \u8574\u542b\u9879\u5176\u5b9e\u5c31\u662f\u6211\u4eec\u6587\u7ae0\u6700\u5f00\u59cb\u63d0\u5230\u7684\u201c\u5708\u201d\uff0c\u6bcf\u4e00\u79cd\u53ef\u80fd\u7684\u5708\u5c31\u662f\u4e00\u4e2a\u8574\u542b\u9879</p> <p></p> <p>\u4e0a\u56fe\u4e2d\u5c31\u67097\u4e2a\u4e00\u6b21\u8574\u542b\u9879\uff0c6\u4e2a\u4e8c\u6b21\u8574\u542b\u9879\u548c1\u4e2a\u56db\u6b21\u8574\u542b\u9879\uff0c\u5171\u8ba114\u4e2a\u8574\u542b\u9879</p> <p>1.4 prime implicant \u8d28\u8574\u542b\u9879\u5c31\u662f\u4e0d\u80fd\u4e0e\u5176\u5b83\u8574\u542b\u9879\u5408\u5e76\u7684\u8574\u542b\u9879\uff0c\u57281.3\u4e2d\uff0c\u6211\u4eec\u53d1\u73b0\u56db\u6b21\u8574\u542b\u9879\u4e2d\u67094\u4e2a\u4e8c\u6b21\u8574\u542b\u9879\uff0c\u90a3\u4e48\u5b83\u4eec\u5c31\u4e0d\u662f\u8d28\u8574\u542b\u9879</p> <p></p> <p>\u53ef\u4ee5\u770b\u5230\u4e0a\u56fe\u4e2d\u7684\u6bcf\u4e00\u4e2a\u5708\u90fd\u4e0d\u80fd\u548c\u5176\u5b83\u5708\u5408\u5e76\uff0c\u6240\u4ee5\u4e0a\u56fe\u6709\u5171\u8ba14\u4e2a\u8d28\u8574\u542b\u9879</p> <p>1.5 essential prime implicant \u5b9e\u8d28\u672c\u6e90\u8574\u542b\u9879\u4e2d\u5fc5\u987b\u542b\u6709\u81f3\u5c11\u4e00\u4e2a\u6ca1\u88ab\u5305\u542b\u5728\u5176\u5b83\u8574\u542b\u9879\u4e2d\u7684\u9879\uff0c\u800c\u4e14\u4e0d\u80fd\u88ab\u66f4\u5927\u7684\u5708\u5305\u88f9</p> <p></p> <p>\u4e0a\u56fe\u4e2d\u6709\u4e09\u4e2a\u5b9e\u8d28\u672c\u6e90\u8574\u542b\u9879\uff0c\u800c\u6211\u4eec\u627e\u5230\u6700\u7b80SOP\u7684\u65b9\u5f0f\u5c31\u662f\u627e\u5230\u6240\u6709\u7684\u5b9e\u8d28\u672c\u6e90\u8574\u542b\u9879</p>"},{"location":"1%20%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%20notes/#cost-criteria","title":"cost criteria","text":""},{"location":"1%20%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%20notes/#literal-cost-l","title":"Literal cost L","text":""},{"location":"1%20%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%20notes/#gate-input-cost-g","title":"gate input cost G","text":""},{"location":"1%20%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%20notes/#gate-input-cost-with-nots-gn","title":"gate input cost with NOTs GN","text":""},{"location":"1%20%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%20notes/#propagation-delay-t_pd-maxt_plht_phl","title":"propagation delay \\(t_{pd} = max{(t_{PLH},t_{PHL})}\\)","text":""},{"location":"1%20%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%20notes/#t_phl","title":"\\(t_{PHL}\\)\u662f","text":"<p>propagation : \u4f20\u8f93</p>"},{"location":"1%20%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%20notes/#transport-delay-inertia-delayrejection-time","title":"\u5206\u4e3atransport delay \u548c inertia delay\uff08\u6709rejection time\u5c5e\u6027\uff09","text":"<p>\u4e09\u4e2a\u4e32\u8054\uff1f\u56db\u4e2a\u53ef\u4ee5\u5417</p> <p>74LS00\u4e0e\u975e\u95e8\u4f20\u8f93\u5ef6\u8fdf\u6d4b\u91cf\uff1a3\u4e2a74LS00\u95e8\u4e32\u8054\uff0c4\u4e2a\u53ef\u4ee5\u5417\uff1f</p> <p>\\((\\overline{A B})\\)</p> <p></p> <p>2-12\u600e\u4e48\u5316\u7b80</p> <p>4\u4f4d\u5168\u52a0\u5668\u7684\u5ef6\u65f6\u8f83\u957f</p> <p>\u56e0\u6b64\u91c7\u7528carry look ahead adder</p> <p>16\u4f4d\u52a0\u6cd5\u5668\u4f7f\u75284\u4e2aCLA\u4e32\u8054</p> <p>64\u4f4d \u7ec4\u8d85\u524d\u8fdb\u4f4d</p> <p>\u5c06G0~3, P0~3\u4f20\u7ed9\u4e0b\u4e00\u5c42\uff1f</p> <p>C4 = G3 +P3G2 + P3P2G1+P3P2P1G0+P3P2P1P0C0</p> <p>\u200b     = G0~3 + P0~3*C0</p> <p>C8 = G4~7 + P4~7*C4</p> <p>\u540c\u7406\uff0cC12 = G8~11+ P8~11*C8</p> <p>C16 = G12~15+ P12~15*C12</p> <p>\u4f9d\u8d56\u5173\u7cfb\u548c4\u4f4d\u7684CLA\u76f8\u4f3c</p> <p></p>"},{"location":"1%20%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%20notes/#1","title":"\u5c0f\u6d4b1 \u590d\u4e60","text":""},{"location":"1%20%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%20notes/#1_1","title":"1\u3001\u903b\u8f91\u8868\u8fbe\u5f0f\u5316\u7b80\uff1a","text":""},{"location":"1%20%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%20notes/#aoverlineababaoverlineaab","title":"\\(A+\\overline{A}B=(A+B)(A+\\overline{A})=A+B\\)","text":""},{"location":"1%20%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%20notes/#_1","title":"\\(\u903b\u8f91\u8868\u8fbe\u5f0f\u53ef\u91cd\u590d\u4f7f\u7528\\)","text":""},{"location":"1%20%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%20notes/#2","title":"2\u3001\u95e8\u4ee3\u4ef7\u8ba1\u7b97\uff1a","text":""},{"location":"1%20%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%20notes/#3","title":"3\u3001\u5361\u8bfa\u56fe\u5316\u7b80","text":"<p>4\u53d8\u91cf\u7684\u5361\u8bfa\u56fe\uff0c16\u4e2a\u683c\u5b50\uff0c\u5708\u7684\u5927\u5c0f\u4e3a8-&gt;1\u4e2a\u53d8\u91cf</p> <p></p>"},{"location":"1%20%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/%E6%95%B0%E9%80%BB%E5%AE%9E%E9%AA%8C/","title":"\u6570\u903b\u5b9e\u9a8c\u8fc7\u7a0b\u7b14\u8bb0","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/labs%26hw/FDS%20Lab%26hw%20review/","title":"Labs & hw","text":"<p>FDS Lab&amp;hw review</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/mynotes/FDS-notes/","title":"FDS-notes-2023","text":"<p>\u6ce8\u610f\u590d\u4e60\uff1a\u586b\u7a7a\u9898\uff0c\u4ee5\u4e0b\u5185\u5bb9\u5747\u53ef\u80fd\u4f5c\u4e3a\u586b\u7a7a</p> <p></p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/mynotes/FDS-notes/#_1","title":"\u6811","text":"<p>\u56db\u79cd\u904d\u5386\u987a\u5e8f</p> <p>\u5c42\u5e8f 1 11 5 12 17 8 20 15</p> <p>\u4e2d\u5e8f 12 11 20 17 1 15 8 5</p> <p>\u524d\u5e8f 1 11 12 17 20 5 8 15</p> <p>\u540e\u5e8f 12 20 17 11 15 8 5 1</p> <pre><code>level-order(Tree T){\n    //\u6ce8\u610flevel-order\u4f7f\u7528\u4e86while\uff0c\u662fenqueue\n    enqueue(T)\n    while(queue is not empty){\n        print(T = dequeue())\n        enqueue(T-&gt;left)\n        enaueue(T-&gt;right)\n    }\n}\n\n//\u4ee5\u4e0b\u4e3a\u9519\u8bef\u7684\u5c42\u5e8f\u904d\u5386\u505a\u6cd5\uff01\nvoid zigzag_levelorder(tree_ptr tree, int rev, queue_ptr queue)\n{\n    enqueue(tree, queue);\n    while (is_empty(queue) == 0)\n    {\n        tree_ptr T = dequeue(queue);\n        visit(T); // \u6253\u5370\u51fa\u8fd9\u5c42\u7684\u8282\u70b9\n        // \u5728\u6b64\u5904\u8c03\u6574\u987a\u5e8f\n        if (rev == 0)\n        {\n            rev = 1;\n            zigzag_levelorder(T-&gt;left, rev, queue);//\u5e94\u8be5\u6539\u4e3aenqueue~~\n            zigzag_levelorder(T-&gt;right, rev, queue);\n        }\n        else\n        {\n            rev = 0;\n            zigzag_levelorder(T-&gt;right, rev, queue);\n            zigzag_levelorder(T-&gt;left, rev, queue);\n        }\n    }\n}\n//zigzag-levelorder hw4\u771f\u662f\u591a\u91d1\nint zigzag_levelorder(tree_ptr tree, queue_ptr queue)\n{\n    // zigzag\u7684\u5c42\u5e8f\u904d\u5386\n    int level = 0;\n    enqueue(tree, queue);\n    while (is_empty(queue) == 0)\n    {\n        int len = queue-&gt;rear - queue-&gt;front;\n        if (level % 2)\n        {\n            for (int i = queue-&gt;front; i &lt; queue-&gt;front + len; i++)\n            {\n                printf(\" %d\", queue-&gt;list[i]-&gt;data);\n            }\n        }\n        else\n        {\n            for (int i = queue-&gt;front + len - 1; i &gt;= queue-&gt;front; i--)\n            {\n                if (level == 0)\n                    printf(\"%d\", queue-&gt;list[i]-&gt;data);\n                else\n                    printf(\" %d\", queue-&gt;list[i]-&gt;data);\n            }\n        }\n        //\u5230\u6b64\u4e3a\u6b62\uff0c\u5f80\u4e0a\uff1a\u6253\u5370\uff0c\u4e5f\u5c31\u662fvisit\n        //\u5f80\u4e0b\uff0cenqueue\n        for (int i = queue-&gt;front; i &lt; queue-&gt;front + len; i++)\n        {\n            if (queue-&gt;list[i]-&gt;left != NULL)\n                enqueue(queue-&gt;list[i]-&gt;left, queue);\n            if (queue-&gt;list[i]-&gt;right != NULL)\n                enqueue(queue-&gt;list[i]-&gt;right, queue);\n        }\n        queue-&gt;front = queue-&gt;front + len;\n        level++;\n    }\n}\n\n\n\nin-order(Tree T){\n    if(T){\n        pre-order(T-&gt;left)\n        print(T);\n        pre-order(T-&gt;right)\n    }\n}\n\nin-order-iterative(Tree_ptr Tree){\n    //\u5199\u6210iterative\u7684\u5f62\u5f0f,\u4f7f\u7528\u6808\u6a21\u62df\n    //\u5148\u5c06\u6700\u5de6\u8fb9\u4e00\u6761\u5168\u90e8\u8fdb\u6808\uff0c\u5f39\u51fa\u6808\u9876\u8282\u70b9\uff08\u79bb\u53f6\u5b50\u5c42\u8f83\u8fd1\u7684\u8282\u70b9\uff09\u540e\u53f3\u8282\u70b9\u8fdb\u6808\n    stack S = init_stack();\n    while(1){\n        while(Tree-&gt;left!=NULL)S.push(Tree = Tree-&gt;left);\n        Tree = S.pop();\n        if(Tree == NULL)break; //\u76f4\u5230stack\u5f39\u7a7a\uff0c\u9000\u51fawhile\u5faa\u73af\n        print(Tree-&gt;data);\n        Tree = Tree-&gt;right;\n    }\n\n}\n\npre-order(Tree T){\n    if(T){\n        print(T);\n        pre-order(T-&gt;left)\n        pre-order(T-&gt;right)\n    }\n}\n\npost-order(Tree T){\n    if(T){\n        post-order(T-&gt;left)\n        post-order(T-&gt;right)\n        print(T);\n    }\n}\n\n\n\n</code></pre> <p>\u524d\u5e8f\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u548c\u540e\u5e8f\u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u4e3a\u6839\u8282\u70b9</p> <p>\u4e2d\u5e8f\u4ece\u5de6\u5230\u53f3\uff0c\u5b9e\u9645\u4e0a\u7684\u6839\u8282\u70b9\u5c06\u6570\u7ec4\u5206\u6210\u4e86\u5b8c\u6574\u7684\u4e24\u4e2a\u90e8\u5206\uff0c\u56e0\u6b64\u53ea\u8981\u786e\u5b9a\u5f53\u524d\u7684\u6839\u8282\u70b9\uff0c\u5c31\u80fd\u627e\u51fa\u5de6\u3001\u53f3\u5b50\u6811\u7684\u533a\u95f4</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/mynotes/FDS-notes/#week-4-hw","title":"\u4e2d\u5e8f\u904d\u5386+\u540e\u5e8f\u904d\u5386\u5efa\u6811\uff1aweek-4-hw","text":"<pre><code>//\u7531\u4e2d\u5e8f\u904d\u5386\u548c\u540e\u5e8f\u904d\u5386\u5efa\u7acb\u4e0a\u9762\u7684\u6811\uff1a\n//\u4e2d\u5e8f\u904d\u5386\uff1a12 11 20 17 1 15 8 5 \n//\u540e\u5e8f\u904d\u5386\uff1a12 20 17 11 15 8 5 1\n//index =             4   \n//11\u4e3a\u65b0\u6811\u7684\u6839\u8282\u70b9\n\ntree_ptr build_tree(int *in_order, int *post_order, int n)\n{\n    if (n &lt;= 0 || in_order == NULL || post_order == NULL || n &gt; MAX_NODE_NUM)\n        return NULL;\n    tree_ptr root = (tree_ptr)malloc(sizeof(tree_node));\n    root-&gt;data = post_order[n - 1];\n    int index = 0;\n    for (int i = 0; i &lt; n; i++)\n    {\n        if (in_order[i] == post_order[n - 1]) //\u4e2d+\u540e\uff1a\u53d6\u540e\u5e8f\u533a\u95f4\u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\uff0c\u5728\u4e2d\u5e8f\u4e2d\u627e\u5230\n            index = i;                        //\u8be5\u5143\u7d20\u7684index\uff0c\u4f20\u5165\u4e0b\u9762\u7684\u9012\u5f52\n    }\n    // \u628a\u4e2d\u5e8f\u5e8f\u5217\u5206\u6210\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u7684\u662f\u5de6\u5b50\u6811\uff0c\u53f3\u8fb9\u7684\u662f\u53f3\u5b50\u6811\n    // \u6b64\u5904 in_order + index + 1 \u5fd8\u8bb0+1\uff0c\u5bfc\u81f4\u53ea\u6709\u5de6\u679d\u7684\u5de6\u5b50\u6811\u5efa\u6210\u4e86\u53f3\u5b50\u6811\n    root-&gt;left = build_tree(in_order, post_order, index);\n    // in_order/post_order\u7684[0~index-1],\u5171index\u4e2a\u6570\n    root-&gt;right = build_tree(in_order + index + 1, post_order + index, n - index - 1);\n    // in_order/post_order\u7684[index+1~n-1]\uff0c\u5171n-1-(index+1)+1 = n-1-index\u4e2a\u6570\n    //\u5de6\u53f3\u52a0\u8d77\u6765\u4e3an-1\u4e2a\u6570\uff0c\u521a\u597d\u5c11\u4e86\u6839\u8282\u70b9\n    return root;\n}\n</code></pre> <p>\u5f62\u8c61\u4e00\u70b9\uff1a\u4e00\u904d\u8fc7\u540e\uff1a</p> <p>\u4e2d\u5e8f \uff08\u5de6\u5b50\u6811\uff1a12 11 20 17 \uff09\u30101\u3011 \uff08\u53f3\u5b50\u6811\uff1a15 8 5\uff09</p> <p>\u540e\u5e8f \uff0812 20 17 11\uff09\uff08 15 8 5\uff09\u30101\u3011</p> <p>\u4e24\u904d\u540e\uff1a</p> <p>\u4e2d\u5e8f \uff08\uff0812\uff09 11 \uff0820 17\uff09 \uff09\u30101\u3011 \uff08\uff0815 8 \uff09{5}\uff08\uff09\uff09</p> <p>\u540e\u5e8f \uff08\uff0812\uff09 \uff0820 17\uff09 {11}\uff09\uff08 \uff0815 8\uff09 {5}\uff09\u30101\u3011</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/mynotes/FDS-notes/#lab2","title":"\u524d\u5e8f\u904d\u5386+\u4e2d\u5e8f\u904d\u5386\u5efa\u6811\uff1alab2","text":"<pre><code>tree_ptr build_tree(int *pre_order, int pre_left, int pre_right, int *in_order, int in_left, int in_right)\n{\n    // \u5148\u5e8f\u904d\u5386\u5efa\u6811,\u5148\u5904\u7406\u6839\u8282\u70b9\uff0c\u518d\u5904\u7406\u5de6\u5b50\u6811\uff0c\u518d\u5904\u7406\u53f3\u5b50\u6811\n    if (pre_left &gt; pre_right || in_left &gt; in_right)\n    {\n        return NULL;\n    }\n    int k;\n    for (k = in_left; k &lt;= in_right; k++)\n    {\n        // \u627e\u5230\u6839\u8282\u70b9\u5728\u4e2d\u5e8f\u904d\u5386\u4e2d\u7684\u4f4d\u7f6e\n        if (in_order[k] == abs(pre_order[pre_left]))\n        {\n            break;\n        }\n    }\n    int num_left = k - in_left; // \u5de6\u5b50\u6811\u7684\u8282\u70b9\u6570\n    tree_ptr root = (tree_ptr)malloc(sizeof(tree_node));\n    root-&gt;data = abs(pre_order[pre_left]);\n    root-&gt;color = red_or_black(pre_order[pre_left]);\n    root-&gt;left = build_tree(pre_order, pre_left + 1, pre_left + num_left, in_order, in_left, k - 1); //\u9664\u5f00pre_order[0](\u6839\u8282\u70b9),\u5de6\u6811\u7684\u533a\u95f4[pre_left+1,pre_left+num_left-1]\n    root-&gt;right = build_tree(pre_order, pre_left + num_left + 1, pre_right, in_order, k + 1, in_right);\n    return root;\n}\n</code></pre> <p>\u4e2d\u5e8f \uff0812 11 20 17\uff09 \u30101\u3011 \uff0815 8 5\uff09</p> <p>\u524d\u5e8f\u30101\u3011 \uff0811 12 17 20\uff09\uff08 5 8 15\uff09</p> <pre><code>//\u81ea\u5df1\u5199\u5199 BST ADT\uff0c\u770b\u770b\u6709\u4ec0\u4e48\u95ee\u9898\n- SearchTree  MakeEmpty( SearchTree T ){\n    T-&gt;left = NULL;\n    T-&gt;right = NULL;\n    T-&gt;\n  }\n- Position  Find( ElementType X, SearchTree T ){\n    //\u67e5\u627e\u5143\u7d20\uff0c\u4eceT\u5f00\u59cb\u627e\uff0c\u8fd4\u56de\u6307\u5411\u8be5\u8282\u70b9\u7684position\uff0c\u4e00\u4e2anode*\n    if(T==NULL)return NULL;//\u6ca1\u6709\u627e\u5230\n    if(T-&gt;data == X)return T;\n    if(T-&gt;-&gt;data&lt; X){\n        Find(T-&gt;right);\n    }\n    else if(T-&gt;data &gt; X){\n        Find(T-&gt;left);\n    }\n\n}\n\n- Position  FindMin( SearchTree T ){\n    //\u627e\u6700\u5c0f\u5143\u7d20\n    if(T==NULL)return NULL;//\u5f53\u524d\u6811\u4e0d\u5b58\u5728\n    else{\n        if(T-&gt;left!=NULL){\n            FindMin(T-&gt;left)\n        }\n    }\n    return T;\n    /*\u522b\u7528while:while(T-&gt;left!=NULL){\n        T = T-&gt;left;\n        FindMin(T);\n    }\n    return T;*/\n}\n- Position  FindMax( SearchTree T ){\n    //\u540c\u4e0a\n    while(T-&gt;right!=NULL){\n        T = T-&gt;right;\n        FindMax(T);\n    }\n    return T;\n}\n- SearchTree  Insert( ElementType X, SearchTree T ){\n    //\u4e8c\u53c9\u6811\u7684\u6b63\u786e\u63d2\u5165\u987a\u5e8f\n    if(T==NULL){\n        node* new_node = (node*)malloc(sizeof(node));\n        T-&gt;data = X;\n        T-&gt;left = NULL;\n        T-&gt;right = NULL;\n        return T;\n    }\n    if(T-&gt;data&gt;X){\n        Insert(X,T-&gt;left);\n    }\n    else if(T-&gt;data&lt;X){\n        Insert(X,T-&gt;right);\n    }\n    return T;\n}\n- SearchTree  Delete( ElementType X, SearchTree T ){\n    //\u5220\u9664\u67d0\u5143\u7d20\uff0c\u662f\u5728\u67e5\u627e\u7684\u57fa\u7840\u4e0a\n    SearchTree pos = FindMax(X,T);\n    //\u5206\u7c7b\u8ba8\u8bba\uff0c\u82e5pos\u7684\u5ea6\u4e3a0/1/2\n    if(pos==NULL)return;\n    else if(pos-&gt;left = NULL &amp;&amp; pos-&gt;right){\n        pos = pos-&gt;right\n    }\n    else if(pos-&gt;right = NULL &amp;&amp; pos-&gt;left){\n        pos = pos-&gt;left\n    }\n    else{\n        //\u5ea6\u4e3a2,\u7528\u5de6\u5b50\u6811\u7684\u6700\u5927\u8282\u70b9\u66ff\u6362\u5f53\u524dpos\u6307\u5411\u7684\u6839\u8282\u70b9\n        SearchTree pos_right_max = FindMax(pos-&gt;right)\n        pos-&gt;data = pos_right_max-&gt;data;\n        Delete(pos-&gt;data,pos-&gt;right);\n        return pos;\n    }\n}\n- ElementType  Retrieve( Position P ){\n    return P-&gt;data;\n}\n\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/mynotes/FDS-notes/#double-ended-queuedeque","title":"\u53cc\u7aef\u961f\u5217 double-ended queue\uff0c\u7b80\u79f0Deque","text":"<p>\u94fe\u8868\u5b9e\u73b0</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// \u5b9a\u4e49\u53cc\u7aef\u961f\u5217\u8282\u70b9\u7ed3\u6784\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// \u5b9a\u4e49\u53cc\u7aef\u961f\u5217\u7ed3\u6784\nstruct Deque {\n    struct Node* front;  // \u961f\u5934\u6307\u9488\n    struct Node* rear;   // \u961f\u5c3e\u6307\u9488\n};\n\n// \u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u53cc\u7aef\u961f\u5217\nstruct Deque* createDeque() {\n    struct Deque* deque = (struct Deque*)malloc(sizeof(struct Deque));\n    deque-&gt;front = NULL;\n    deque-&gt;rear = NULL;\n    return deque;\n}\n//**************************\n// \u5728\u961f\u5934\u63d2\u5165\u5143\u7d20\uff0c\u8111\u888b\u8981\u6709\u90a3\u4e2a\u4e09\u89d2\u5f62\uff0c\u5148\u5c06\u65b0\u8282\u70b9\u6307\u5411front\u6307\u5411\u7684node\uff0c\u7136\u540e\u518d\u5c06front\u79fb\u5230\u65b0\u8282\u70b9\u4e0a\n//front\u60f3\u8c61\u6210\u4e00\u4e2a\u6570\u636e\u57df\u4e3a\u9ed1\uff0c\u53ea\u6709\u6307\u9488\u7684dummy node\n//\u4e14\u603b\u662f\u5148\u5c06\u65b0\u8282\u70b9\u5404\u53c2\u6570\u8d4b\u503c\u5b8c\u6bd5\u540e\u518d\u8fdb\u884c\u4e32\u8054\n//**************************\nvoid insertFront(struct Deque* deque, int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode-&gt;data = data;\n    newNode-&gt;next = deque-&gt;front;\n    deque-&gt;front = newNode;\n    if (deque-&gt;rear == NULL) {\n        deque-&gt;rear = newNode;\n    }\n}\n\n// \u5728\u961f\u5c3e\u63d2\u5165\u5143\u7d20\uff0c\u82e5rear==NULL \u5219\u8bf4\u660edeque\u4e3a\u7a7a\uff0c\u6b64\u65f6\u4e0efront\u6709\u5173\uff0c\u5426\u5219\u53ea\u9700\u5904\u7406rear\u6307\u9488\nvoid insertRear(struct Deque* deque, int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode-&gt;data = data;\n    newNode-&gt;next = NULL;\n    if (deque-&gt;rear == NULL) {\n        deque-&gt;front = newNode;\n        deque-&gt;rear = newNode;\n    } else {\n        deque-&gt;rear-&gt;next = newNode;\n        deque-&gt;rear = newNode;\n    }\n}\n\n// \u4ece\u961f\u5934\u5220\u9664\u5143\u7d20,\u6ce8\u610f\u65e0\u8bba\u662f\u4ece\u961f\u5934/\u961f\u5c3e\u5220\u9664\u65f6\uff0c\u5148\u8981\u4fdd\u8bc1\u5934/\u5c3e\u6307\u9488\u4e0d\u662fNULL\uff0c\u5728\u5220\u9664\u5b8c\u540e\u8fd8\u8981\u5224\u65ad\u662f\u5426\u5220\u6389\u4e86\n//deque\u4e2d\u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\uff0c\u5982\u679c\u662f\u5219\u8981\u5c06front\u548crear\u90fd\u8d4b\u503c\u4e3aNULL\nvoid deleteFront(struct Deque* deque) {\n    if (deque-&gt;front != NULL) {\n        struct Node* temp = deque-&gt;front;\n        deque-&gt;front = deque-&gt;front-&gt;next;\n        free(temp);\n        if (deque-&gt;front == NULL) {\n            deque-&gt;rear = NULL;\n        }\n    }\n}\n\n// \u4ece\u961f\u5c3e\u5220\u9664\u5143\u7d20\nvoid deleteRear(struct Deque* deque) {\n    if (deque-&gt;rear != NULL) {\n        if (deque-&gt;front == deque-&gt;rear) {\n            free(deque-&gt;front);\n            deque-&gt;front = NULL;\n            deque-&gt;rear = NULL;\n        } else {\n            struct Node* temp = deque-&gt;front;\n            while (temp-&gt;next != deque-&gt;rear) {\n                temp = temp-&gt;next;\n            }\n            free(deque-&gt;rear);\n            deque-&gt;rear = temp;//temp\u5411\u540e\u904d\u5386\u7684\u8fc7\u7a0b\uff0c\u6613\u51fa\u586b\u7a7a\u9898\n            deque-&gt;rear-&gt;next = NULL;\n        }\n    }\n}\n\n// \u68c0\u67e5\u53cc\u7aef\u961f\u5217\u662f\u5426\u4e3a\u7a7a\nint isEmpty(struct Deque* deque) {\n    return (deque-&gt;front == NULL);\n}\n\n// \u6253\u5370\u53cc\u7aef\u961f\u5217\u4e2d\u7684\u5143\u7d20\nvoid printDeque(struct Deque* deque) {\n    struct Node* current = deque-&gt;front;\n    while (current != NULL) {\n        printf(\"%d \", current-&gt;data);\n        current = current-&gt;next;\n    }\n    printf(\"\\n\");\n}\n\n// \u4e3b\u51fd\u6570\nint main() {\n    struct Deque* deque = createDeque();\n\n    insertFront(deque, 1);\n    insertRear(deque, 2);\n    insertFront(deque, 3);\n\n    printDeque(deque);\n\n    deleteFront(deque);\n    printDeque(deque);\n\n    insertRear(deque, 4);\n    printDeque(deque);\n\n    deleteRear(deque);\n    printDeque(deque);\n\n    return 0;\n}\n\n</code></pre> <p>\u6570\u7ec4\u5b9e\u73b0</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define MAX_SIZE 100\n\n// \u5b9a\u4e49\u53cc\u7aef\u961f\u5217\u7ed3\u6784\nstruct Deque {\n    int arr[MAX_SIZE];\n    int front;\n    int rear;\n};\n\n// \u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u53cc\u7aef\u961f\u5217\nstruct Deque* createDeque() {\n    struct Deque* deque = (struct Deque*)malloc(sizeof(struct Deque));\n    deque-&gt;front = -1;\n    deque-&gt;rear = -1;\n    return deque;\n}\n\n// \u5728\u961f\u5934\u63d2\u5165\u5143\u7d20\nvoid insertFront(struct Deque* deque, int data) {\n    if (deque-&gt;front == -1) {\n        deque-&gt;front = 0;\n        deque-&gt;rear = 0;\n        deque-&gt;arr[deque-&gt;front] = data;\n    } else if (deque-&gt;front &gt; 0) {\n        deque-&gt;arr[--deque-&gt;front] = data;\n    } else {\n        printf(\"Deque is full (front).\\n\");\n    }\n}\n\n// \u5728\u961f\u5c3e\u63d2\u5165\u5143\u7d20\nvoid insertRear(struct Deque* deque, int data) {\n    if (deque-&gt;rear == -1) {\n        deque-&gt;front = 0;\n        deque-&gt;rear = 0;\n        deque-&gt;arr[deque-&gt;rear] = data;\n    } else if (deque-&gt;rear &lt; MAX_SIZE - 1) {\n        deque-&gt;arr[++deque-&gt;rear] = data;\n    } else {\n        printf(\"Deque is full (rear).\\n\");\n    }\n}\n\n// \u4ece\u961f\u5934\u5220\u9664\u5143\u7d20\nvoid deleteFront(struct Deque* deque) {\n    if (deque-&gt;front != -1) {\n        if (deque-&gt;front == deque-&gt;rear) {\n            deque-&gt;front = -1;\n            deque-&gt;rear = -1;\n        } else {\n            deque-&gt;front++;\n        }\n    } else {\n        printf(\"Deque is empty (front).\\n\");\n    }\n}\n\n// \u4ece\u961f\u5c3e\u5220\u9664\u5143\u7d20\nvoid deleteRear(struct Deque* deque) {\n    if (deque-&gt;rear != -1) {\n        if (deque-&gt;front == deque-&gt;rear) {\n            deque-&gt;front = -1;\n            deque-&gt;rear = -1;\n        } else {\n            deque-&gt;rear--;\n        }\n    } else {\n        printf(\"Deque is empty (rear).\\n\");\n    }\n}\n\n// \u68c0\u67e5\u53cc\u7aef\u961f\u5217\u662f\u5426\u4e3a\u7a7a\nint isEmpty(struct Deque* deque) {\n    return (deque-&gt;front == -1);\n}\n\n// \u6253\u5370\u53cc\u7aef\u961f\u5217\u4e2d\u7684\u5143\u7d20\nvoid printDeque(struct Deque* deque) {\n    if (isEmpty(deque)) {\n        printf(\"Deque is empty.\\n\");\n        return;\n    }\n\n    printf(\"Front: %d, Rear: %d\\n\", deque-&gt;front, deque-&gt;rear);\n    printf(\"Elements: \");\n    for (int i = deque-&gt;front; i &lt;= deque-&gt;rear; i++) {\n        printf(\"%d \", deque-&gt;arr[i]);\n    }\n    printf(\"\\n\");\n}\n\n// \u4e3b\u51fd\u6570\nint main() {\n    struct Deque* deque = createDeque();\n\n    insertFront(deque, 1);\n    insertRear(deque, 2);\n    insertFront(deque, 3);\n\n    printDeque(deque);\n\n    deleteFront(deque);\n    printDeque(deque);\n\n    insertRear(deque, 4);\n    printDeque(deque);\n\n    deleteRear(deque);\n    printDeque(deque);\n\n\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/mynotes/FDS-notes/#_2","title":"\u5faa\u73af\u961f\u5217","text":"<p>\u94fe\u8868\u5b9e\u73b0</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// \u5b9a\u4e49\u5faa\u73af\u961f\u5217\u8282\u70b9\u7ed3\u6784\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// \u5b9a\u4e49\u5faa\u73af\u961f\u5217\u7ed3\u6784\nstruct CircularQueue {\n    struct Node* front;\n    struct Node* rear;\n};\n\n// \u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5faa\u73af\u961f\u5217\nstruct CircularQueue* createCircularQueue() {\n    struct CircularQueue* queue = (struct CircularQueue*)malloc(sizeof(struct CircularQueue));\n    queue-&gt;front = NULL;\n    queue-&gt;rear = NULL;\n    return queue;\n}\n\n// \u5165\u961f\u64cd\u4f5c\nvoid enqueue(struct CircularQueue* queue, int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode-&gt;data = data;\n    newNode-&gt;next = NULL;\n    if (queue-&gt;rear == NULL) {\n        queue-&gt;front = newNode;\n        queue-&gt;rear = newNode;\n        newNode-&gt;next = newNode; // \u94fe\u63a5\u5230\u81ea\u8eab\u4ee5\u6784\u6210\u5faa\u73af\n    } else {\n        newNode-&gt;next = queue-&gt;front;\n        queue-&gt;rear-&gt;next = newNode;\n        queue-&gt;rear = newNode;\n    }\n}\n\n// \u51fa\u961f\u64cd\u4f5c\nint dequeue(struct CircularQueue* queue) {\n    if (queue-&gt;front == NULL) {\n        printf(\"Queue is empty.\\n\");\n        return -1; // \u961f\u5217\u4e3a\u7a7a\u65f6\u8fd4\u56de-1\n    }\n    int data = queue-&gt;front-&gt;data;\n    struct Node* temp = queue-&gt;front;\n    if (queue-&gt;front == queue-&gt;rear) {\n        queue-&gt;front = NULL;\n        queue-&gt;rear = NULL;\n    } else {\n        queue-&gt;front = queue-&gt;front-&gt;next;\n        queue-&gt;rear-&gt;next = queue-&gt;front;\n    }\n    free(temp);\n    return data;\n}\n\n// \u68c0\u67e5\u5faa\u73af\u961f\u5217\u662f\u5426\u4e3a\u7a7a\nint isEmpty(struct CircularQueue* queue) {\n    return (queue-&gt;front == NULL);\n}\n\n// \u6253\u5370\u5faa\u73af\u961f\u5217\u4e2d\u7684\u5143\u7d20\nvoid printCircularQueue(struct CircularQueue* queue) {\n    struct Node* current = queue-&gt;front;\n    if (current == NULL) {\n        printf(\"Circular Queue is empty.\\n\");\n        return;\n    }\n    do {\n        printf(\"%d \", current-&gt;data);\n        current = current-&gt;next;\n    } while (current != queue-&gt;front);\n    printf(\"\\n\");\n}\n\n// \u4e3b\u51fd\u6570\nint main() {\n    struct CircularQueue* queue = createCircularQueue();\n\n    enqueue(queue, 1);\n    enqueue(queue, 2);\n    enqueue(queue, 3);\n    enqueue(queue, 4);\n\n    printCircularQueue(queue);\n\n    dequeue(queue);\n    dequeue(queue);\n\n    printCircularQueue(queue);\n\n    enqueue(queue, 5);\n    printCircularQueue(queue);\n\n    dequeue(queue);\n    dequeue(queue);\n    dequeue(queue);\n    dequeue(queue);\n\n    printCircularQueue(queue);\n\n    return 0;\n}\n\n</code></pre> <p>\u6570\u7ec4\u5b9e\u73b0</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define MAX_SIZE 100\n\n// \u5b9a\u4e49\u5faa\u73af\u961f\u5217\u7ed3\u6784\nstruct CircularQueue {\n    int arr[MAX_SIZE];\n    int front;\n    int rear;\n};\n\n// \u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5faa\u73af\u961f\u5217\nstruct CircularQueue* createCircularQueue() {\n    struct CircularQueue* queue = (struct CircularQueue*)malloc(sizeof(struct CircularQueue));\n    queue-&gt;front = -1;\n    queue-&gt;rear = -1;\n    return queue;\n}\n\n// \u5165\u961f\u64cd\u4f5c\nvoid enqueue(struct CircularQueue* queue, int data) {\n    if ((queue-&gt;rear + 1) % MAX_SIZE == queue-&gt;front) {\n        printf(\"Queue is full.\\n\");\n        return;\n    }\n    if (queue-&gt;front == -1) {\n        queue-&gt;front = 0;\n        queue-&gt;rear = 0;\n        queue-&gt;arr[queue-&gt;rear] = data;\n    } else {\n        queue-&gt;rear = (queue-&gt;rear + 1) % MAX_SIZE;\n        queue-&gt;arr[queue-&gt;rear] = data;\n    }\n}\n\n// \u51fa\u961f\u64cd\u4f5c\nint dequeue(struct CircularQueue* queue) {\n    if (queue-&gt;front == -1) {\n        printf(\"Queue is empty.\\n\");\n        return -1;\n    }\n    int data = queue-&gt;arr[queue-&gt;front];\n    if (queue-&gt;front == queue-&gt;rear) {\n        queue-&gt;front = -1;\n        queue-&gt;rear = -1;\n    } else {\n        queue-&gt;front = (queue-&gt;front + 1) % MAX_SIZE;\n    }\n    return data;\n}\n\n// \u68c0\u67e5\u5faa\u73af\u961f\u5217\u662f\u5426\u4e3a\u7a7a\nint isEmpty(struct CircularQueue* queue) {\n    return (queue-&gt;front == -1);\n}\n\n// \u6253\u5370\u5faa\u5faa\u73af\u961f\u5217\u4e2d\u7684\u5143\u7d20\nvoid printCircularQueue(struct CircularQueue* queue) {\n    if (isEmpty(queue)) {\n        printf(\"Circular Queue is empty.\\n\");\n        return;\n    }\n\n    int i = queue-&gt;front;\n    do {\n        printf(\"%d \", queue-&gt;arr[i]);\n        i = (i + 1) % MAX_SIZE;\n    } while (i != (queue-&gt;rear + 1) % MAX_SIZE);\n    printf(\"\\n\");\n}\n\n// \u4e3b\u51fd\u6570\nint main() {\n    struct CircularQueue* queue = createCircularQueue();\n\n    enqueue(queue, 1);\n    enqueue(queue, 2);\n    enqueue(queue, 3);\n    enqueue(queue, 4);\n\n    printCircularQueue(queue);\n\n    dequeue(queue);\n    dequeue(queue);\n\n    printCircularQueue(queue);\n\n    enqueue(queue, 5);\n    printCircularQueue(queue);\n\n    dequeue(queue);\n    dequeue(queue);\n    dequeue(queue);\n    dequeue(queue);\n\n    printCircularQueue(queue);\n\n    return 0;\n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/mynotes/FDS-notes/#_3","title":"\u53cc\u5411\u5faa\u73af\u94fe\u8868","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// \u5b9a\u4e49\u53cc\u5411\u5faa\u73af\u94fe\u8868\u8282\u70b9\u7ed3\u6784\nstruct Node {\n    int data;\n    struct Node* next;\n    struct Node* prev;\n};\n\n// \u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u53cc\u5411\u5faa\u73af\u94fe\u8868\nstruct Node* createDoublyCircularLinkedList(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode-&gt;data = data;\n    newNode-&gt;next = newNode;\n    newNode-&gt;prev = newNode;\n    return newNode;\n}\n\n// \u5728\u53cc\u5411\u5faa\u73af\u94fe\u8868\u7684\u672b\u5c3e\u63d2\u5165\u8282\u70b9\nvoid insertAtEnd(struct Node** head, int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode-&gt;data = data;\n    newNode-&gt;next = (*head);\n    newNode-&gt;prev = (*head)-&gt;prev;\n    (*head)-&gt;prev-&gt;next = newNode;\n    (*head)-&gt;prev = newNode;\n}\n\n// \u6253\u5370\u53cc\u5411\u5faa\u73af\u94fe\u8868\u7684\u5143\u7d20\nvoid printDoublyCircularLinkedList(struct Node* head) {\n    if (head == NULL) {\n        printf(\"Empty Doubly Circular Linked List\\n\");\n        return;\n    }\n\n    struct Node* current = head;\n    do {\n        printf(\"%d \", current-&gt;data);\n        current = current-&gt;next;\n    } while (current != head);\n    printf(\"\\n\");\n}\n\n// \u4e3b\u51fd\u6570\nint main() {\n    struct Node* head = createDoublyCircularLinkedList(1);\n\n    insertAtEnd(&amp;head, 2);\n    insertAtEnd(&amp;head, 3);\n\n    printf(\"Doubly Circular Linked List: \");c \n    printDoublyCircularLinkedList(head);\n\n    return 0;\n}\n\n</code></pre> <p>\u4e8c\u5206\u6cd5\u7684\u7ec6\u8282\u52a0\u7ec6\u8282 \u4f60\u771f\u7684\u5e94\u8be5\u641e\u61c2\uff01\uff01\uff01_\u4e8c\u5206\u7b97\u6cd5-CSDN\u535a\u5ba2</p> <p>\u6298\u534a\u67e5\u627e\u5224\u5b9a\u6811\u2014\u2014\uff08\u5feb\u901f\u5224\u65ad\u67d0\u68f5\u6811\u662f\u5426\u4e3a\u6298\u534a\u67e5\u627e\u5224\u5b9a\u6811\uff09_\u6298\u534a\u67e5\u627e\u6811_\u53eb\u6211\u8611\u83c7\u5148\u751f\u7684\u535a\u5ba2-CSDN\u535a\u5ba2</p> <p>\u5bf9\u4efb\u610f\u65e0\u5e8f\u5e8f\u5217\u53ef\u5efa\u7acb\u5b8c\u5168\u4e8c\u53c9\u67e5\u627e\u6811</p> <p>\u5148\u5bf9\u5e8f\u5217\u6392\u5e8f\uff0c\u6392\u5e8f\u540e\u5f97\u5230\u5347\u5e8f\u5e8f\u5217\u4e3a\u4e2d\u5e8f\u904d\u5386\u987a\u5e8f</p> <p>\u5df2\u77e5\u7236\u8282\u70b9i\uff0c\u53ef\u6c42\u51fa\u5b50\u8282\u70b9\u4e0b\u68072i\u548c 2i+1</p> <pre><code>void make_tree(int* tree, int* a,int n,int p,int* i){\n    if(p&gt;n||p&lt;1||(*i)&gt;n){\n        return;\n    }\n    make_tree(tree,a,n,p*2,i);\n    tree[p] = a[(*i)++];\n    make_tree(tree,a,n,p*2+1,i);\n}\n</code></pre> <p>\u76f4\u63a5\u627e\u5230\u8d8a\u754c\u4e3a\u6b62</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/","title":"Notes for Data Structure","text":"<p>This is my personal notes for The Foundation of Data Structure course in Zhejiang University.</p> <p>Since it\u2019s the first time I\u2019ve learned data structure systematically, I wish I could detail the information which will make it easier for me to review in the future. </p> <p>Also hope that my notes can help someone else a little bit.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK01/","title":"WEEK 1","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK01/#1-algorithm-analysis","title":"1 Algorithm Analysis","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK01/#definition-an-algorithm-is-a-finite-set-of-instructions-that-if-followed-accomplishes-a-particular-task-in-addition-all-algorithms-must-satisfy-the-following-criteria","title":"[Definition] An algorithm is a finite set of instructions that, if followed, accomplishes a particular task. In addition, all algorithms must satisfy the following criteria.","text":"<ol> <li> <p>Input : There are zero or more quantities that are externally supplied.</p> </li> <li> <p>Output : At least one quantity is produced.</p> </li> <li> <p>Definiteness : Each instruction is clear and unambiguous.</p> </li> <li> <p>Finiteness : the algorithm terminates after finite number of steps</p> </li> <li> <p>Effectiveness : basic enough to be carried out ; feasible</p> </li> <li> <p>A program does not have to be finite. (eg. an operation system)</p> </li> <li> <p>An algorithm can be described by human languages, flow charts, some programming languages, or pseudocode.</p> </li> </ol>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK01/#example-selection-sort-sort-a-set-of-ngeq1-integers-in-increasing-order","title":"[Example] Selection Sort : Sort a set of \\(n\\geq1\\) integers in increasing order","text":"<pre><code>for (i = 0; i &lt; n; i++){\n    Examine list[i] to list[n-1] and suppose that the smallest integer is at list[min];\n    Interchange list[i] and list[min];\n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK01/#11-what-to-analyze","title":"1.1 What to Analyze","text":"<ul> <li> <p>Machine and compiler-dependent run times.</p> </li> <li> <p>Time and space complexities : machine and compiler independent.</p> </li> <li> <p>Assumptions:</p> </li> </ul> <ol> <li> <p>instructions are executed sequentially \u987a\u5e8f\u6267\u884c</p> </li> <li> <p>each instruction is simple, and takes exactly one time unit</p> </li> <li>integer size is fixed and we have infinite memory</li> </ol> <ul> <li>\\(T_{avg}(N)\\, and\\, T_{worst}(N)\\) : the average and worst case time complexities as functions of input size \\(N\\)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK01/#example-matrix-addition","title":"[Example] Matrix addition","text":"<pre><code>void add(int a[][MAX_SIZE],\n         int b[][MAX_SIZE],\n         int c[][MAX_SIZE],\n         int rows, int cols) \n{\n    int i, j;\n    for (i=0; i&lt;rows; i++)/*rows+1*/\n        for (j=0;j&lt;cols;j++)/*rows(cols+1)*/\n            c[i][j] = a[i][j]+b[i][j];/*rows*cols*/\n}\n</code></pre> \\[ T(rows, cols) = 2rows\\times cols + 2rows+1 \\] <ul> <li>\u975e\u5bf9\u79f0</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK01/#example-iterative-function-for-summing-a-list-of-numbers","title":"[Example] Iterative function for summing a list of numbers","text":"<pre><code>float sum (float list[], int n)\n{  /*add a list of numbers*/\n    float tempsum = 0; /*count = 1*/\n    int i;\n    for (i=0; i&lt;n; i++)\n        /*count++*/\n        tempsum  += list[i]; /*count++*/\n    /*count++ for last excutaion of for*/\n   return tempsum; /*count++*/\n}\n</code></pre> \\[ T_{sum}(n)=2n+3 \\]"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK01/#example-recursive-function-for-summing-a-list-of-numbers","title":"[Example] Recursive function for summing a list of numbers","text":"<pre><code>float rsum (float list[], int n)\n{/*add a list of numbers*/\n    if (n) /*count++*/\n        return rsum(list, n-1) + list[n-1];\n        /*count++*/\n    return 0; /*count++*/\n}\n</code></pre> \\[ T_{rsum}(n)=2n+2 \\] <p>But it takes more time to compute each step.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK01/#12-asymptotic-notationoomegathetao","title":"1.2 Asymptotic Notation(\\(O,\\Omega,\\Theta,o\\))","text":"<ul> <li>predict the growth ; compare the time complexities of two programs ; asymptotic(\u6e10\u8fdb\u7684) behavior</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK01/#definition-tnofn-if-there-are-positive-constants-c-and-n_0-such-that-tnleq-ccdot-fn-for-all-ngeq-n_0upper-bound","title":"[Definition] \\(T(N)=O(f(N))\\) if there are positive constants \\(c\\) and \\(n_0\\) such that \\(T(N)\\leq c\\cdot f(N)\\) for all \\(N\\geq n_0\\).(upper bound)","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK01/#definition-tnomegagn-if-there-are-positive-constants-c-and-n_0-such-that-tngeq-ccdot-fn-for-all-ngeq-n_0lower-bound","title":"[Definition] \\(T(N)=\\Omega(g(N))\\) if there are positive constants \\(c\\) and \\(n_0\\) such that \\(T(N)\\geq c\\cdot f(N)\\) for all \\(N\\geq n_0\\).(lower bound)","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK01/#definition-tnthetahn-if-and-only-if-tnohn-and-tnomegahn","title":"[Definition] \\(T(N)=\\Theta(h(N))\\) if and only if \\(T(N)=O(h(N))\\) and \\(T(N)=\\Omega(h(N))\\).","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK01/#definition-tnopn-if-tnopn-and-tnneqthetapn","title":"[Definition] \\(T(N)=o(p(N))\\) if \\(T(n)=O(p(N))\\) and \\(T(N)\\neq\\Theta(p(N))\\).","text":"<ul> <li> <p>\\(2N+3=O(N)=O(N^{k\\geq1})=O(2^N)=\\ldots\\) take the smallest \\(f(N)\\)</p> </li> <li> <p>\\(2^N+N^2=\\Omega(2^N)=\\Omega(N^2)=\\Omega(N)=\\Omega(1)=\\ldots\\) take the largest \\(g(N)\\)</p> </li> <li> <p>Rules of Asymptotic Notation</p> </li> </ul> <ol> <li>If \\(T_1(N)=O(f(N))\\) and \\(T_2=O(g(N))\\), then</li> </ol> <p>(1) \\(T_1(N)+T_2(N)=max(O(f(N)),O(g(N)))\\)</p> <p>(2) \\(T_1(N)*T_2(N)=O(f(N)*g(N))\\)</p> <ol> <li> <p>\u82e5\\(T(N)\\)\u662f\u4e00\u4e2a\\(k\\)\u6b21\u591a\u9879\u5f0f\uff0c\u5219\\(T(N)=\\Theta(N^k)\\)</p> </li> <li> <p>\\(log_kN=O(N)\\) for any constant \\(k\\) (logarithms grow very slowly)</p> </li> </ol> <p></p> <p></p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK01/#example-matrix-addition_1","title":"[Example] Matrix addition","text":"<pre><code>void add(int a[][MAX_SIZE],\n         int b[][MAX_SIZE],\n         int c[][MAX_SIZE],\n         int rows, int cols) \n{\n    int i, j;\n    for (i=0; i&lt;rows; i++)\n        for (j=0;j&lt;cols;j++)\n            c[i][j] = a[i][j]+b[i][j];\n}\n</code></pre> \\[ T(rows,cols)=\\Theta(rows\\cdot cols) \\]"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK01/#general-rules","title":"General Rules","text":"<ul> <li> <p>For loops : The running time of a for loop is at most the running time of the statements inside the for loop (including tests) times the number of iterations.</p> </li> <li> <p>Nested for loops : The total running time of a statement inside a group of nested loops is the running time of the statements multiplied by the product of the sizes of all the for loops.</p> </li> <li> <p>Consecutive statements : These just add (which means that the maximum is the one that counts).</p> </li> <li> <p>If/else : For the fragment           if ( Condition )  S1;           else  S2;</p> </li> </ul> <p>The running time is never more than the running time of the test plus the larger of the running time of S1 and S2.</p> <p></p> <ul> <li>Recursions : </li> </ul> <p>[Example] Fibonacci number   $$   Fib(0)=Fib(1)=1, Fib(n)=Fib(n-1)+Fib(n-2)   $$</p> <p><code>c   lont int Fib (int N) /*T(N)*/   {       if (N&lt;=1) /*O(1)*/           return 1; /*O(1)*/       else           return Fib(N-1)+Fib(N-2);   }      /*O(1)*//*T(N-1)*//*T(N-2)*/</code></p> <p>$$   T(N)=T(N-1)+T(N-2)+2\\geq Fib(N)\\   \\left(\\frac{3}{2} \\right)^n\\leq Fib(N)\\leq\\left(\\frac{5}{3}\\right)^n   $$</p> <p>\u65f6\u95f4\u590d\u6742\u5ea6\uff1a\\(O(2^N)\\) \\(T(N)\\) grows exponentially</p> <p>\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a\\(O(N)\\)</p> <p>\\(O(N)\\)</p> <p>\\(O(N)\\)</p> \\[T(N)\\]"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK02/","title":"WEEK 2","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK02/#13-compare-the-algorithms","title":"1.3 Compare the Algorithms","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK02/#example","title":"[Example] \u6700\u5927\u5b50\u5e8f\u5217\u548c","text":"<p>Algorithm 1</p> <pre><code>int  MaxSubsequenceSum ( const int A[ ],  int  N ) \n{ \n    int ThisSum, MaxSum, i, j, k; \n    MaxSum = 0;   /* initialize the maximum sum */\n    for( i = 0; i &lt; N; i++ )  /* start from A[ i ] */\n        for( j = i; j &lt; N; j++ ) {   /* end at A[ j ] */\n            ThisSum = 0; \n            for( k = i; k &lt;= j; k++ ) \n                ThisSum += A[ k ];  /* sum from A[ i ] to A[ j ] */\n            if ( ThisSum &gt; MaxSum ) \n                MaxSum = ThisSum;  /* update max sum */\n        }  /* end for-j and for-i */\n    return MaxSum; \n}\n</code></pre> \\[ T(N)=O(N^3) \\] <p>Algotithm 2</p> <pre><code>int  MaxSubsequenceSum ( const int A[ ],  int  N ) \n{ \n    int ThisSum, MaxSum, i, j; \n    MaxSum = 0;   /* initialize the maximum sum */\n    for( i = 0; i &lt; N; i++ ) {   /* start from A[ i ] */\n        ThisSum = 0; \n        for( j = i; j &lt; N; j++ ) {   /* end at A[ j ] */\n            ThisSum += A[ j ];  /* sum from A[ i ] to A[ j ] */\n            if ( ThisSum &gt; MaxSum ) \n                MaxSum = ThisSum;  /* update max sum */\n        }  /* end for-j */\n    }  /* end for-i */\n    return MaxSum; \n} \n</code></pre> \\[ T(N)=O(N^2) \\] <p>Algorithm 3 Divide and Conquer  \u5206\u6cbb\u6cd5</p> <pre><code>static int MaxSubSum(const int A[ ], int Left, int Right)\n{\n    int MaxLeftSum, MaxRightSum;\n    int MaxLeftBorderSum, MaxRightBorderSum;\n    int LeftBorderSum, RightBorderSum;\n    int Center, i;\n\n    if (Left == Right)\n        if (A[Left] &gt; 0)\n            return A[Left];\n        else\n            return 0;\n\n    Center = (Left + Right) / 2;\n    MaxLeftSum = MaxSubSum(A, Left, Center);\n    MaxRightSum = MaxSubSum(A, Center + 1, Right);\n\n    MaxLeftBorderSum = 0;\n    LeftBorderSum = 0;\n    for (i = Center; i &gt;= Left; i--)\n    {\n        LeftBorderSum += A[i];\n        if (LeftBorderSum &gt; MaxLeftBorderSum)\n            MaxLeftBorderSum = LeftBorderSum;\n    }\n\n    MaxRightBorderSum = 0;\n    RightBorderSum = 0;\n    for (i = Center+1; i &lt;= Right; i++)\n    {\n        RightBorderSum += A[i];\n        if (RightBorderSum &gt; MaxRightBorderSum)\n            MaxRightBorderSum = RightBorderSum;\n    }\n\n    return Max3(MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum);\n}\n\nint MaxSubsequenceSum(const int A[ ], int N)\n{\n    return MaxSubSum(A, 0, N - 1);\n}\n</code></pre> <p>$$ \\because T(N)=2T(\\frac N2)+cN\\quad T(1)=O(1)\\ T(\\frac N2)=2T(\\frac N {2^2})+c\\frac N2\\ \\cdots\\ T(1)=2T(\\frac N{2^k})+c\\frac N{2^{k-1}}\\ \\therefore T(N)=2^kT(\\frac N{2^k})+kcN=N\\cdot O(1)+cN\\log N $$ Algorithm 4 On-line Algorithm  \u5728\u7ebf\u7b97\u6cd5</p> <pre><code>int MaxSubsequenceSum( const int  A[ ],  int  N ) \n{ \n    int ThisSum, MaxSum, j; \n    ThisSum = MaxSum = 0; \n    for ( j = 0; j &lt; N; j++ ) { \n        ThisSum += A[ j ]; \n        if ( ThisSum &gt; MaxSum ) \n            MaxSum = ThisSum; \n        else if ( ThisSum &lt; 0 ) \n            ThisSum = 0;\n    }  /* end for-j */\n    return MaxSum; \n} \n</code></pre> \\[ T(N)=O(N) \\] <ul> <li>A[ ] is scanned once only. \u626b\u63cf\u4e00\u6b21\uff0c\u65e0\u9700\u5b58\u50a8\uff08\u5904\u7406streaming data\uff09</li> <li>\u5728\u4efb\u610f\u65f6\u523b\uff0c\u7b97\u6cd5\u90fd\u80fd\u5bf9\u5b83\u5df2\u7ecf\u8bfb\u5165\u7684\u6570\u636e\u7ed9\u51fa\u5b50\u5e8f\u5217\u95ee\u9898\u7684\u6b63\u786e\u7b54\u6848(\u5176\u4ed6\u7b97\u6cd5\u4e0d\u5177\u6709\u8fd9\u4e2a\u7279\u6027)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK02/#14-logrithms-in-the-running-time","title":"1.4 Logrithms in the Running Time","text":"<ul> <li>\u5982\u679c\u4e00\u4e2a\u7b97\u6cd5\u7528\u5e38\u6570\u65f6\u95f4\u5c06\u95ee\u9898\u7684\u5927\u5c0f\u524a\u51cf\u4e3a\u5176\u4e00\u90e8\u5206(\u901a\u5e38\u662f1/2)\uff0c\u90a3\u4e48\u8be5\u7b97\u6cd5\u5c31\u662f\\(O(logN)\\)\u7684</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK02/#example-binary-search","title":"[Example] Binary Search","text":"<pre><code>int BinarySearch ( const ElementType A[ ], ElementType X, int N ) \n{ \n    int  Low, Mid, High; \n    Low = 0;  High = N - 1; \n    while ( Low &lt;= High ) { \n        Mid = ( Low + High ) / 2; \n        if ( A[ Mid ] &lt; X ) \n            Low = Mid + 1; \n        else \n            if ( A[ Mid ] &gt; X ) \n                High = Mid - 1; \n            else \n                return  Mid; /* Found */ \n    }  /* end while */\n    return  NotFound; /* NotFound is defined as -1 */ \n} \n</code></pre> \\[ T_{worst}(N)=O(\\log N) \\]"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK02/#example-euclids-algorithm","title":"[Example] Euclid\u2019s Algorithm","text":"<pre><code>int Gcd(int M, int N)\n{\n    int Rem;\n\n    while (N &gt; 0)\n    {\n        Rem = M % N;\n        M = N;\n        N = Rem;\n    }\n    return M;\n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK02/#example-efficient-exponentiation","title":"[Example] Efficient exponentiation","text":"<pre><code>long int Pow(long int X, int N)\n{\n    if (N == 0) return 1;\n    if (N == 1) return X;\n    if (IsEven(N)) return Pow(X*X, N/2);/*return Pow(X, N/2)*Pow(X, N/2) affects the efficiency*/\n    else return Pow(X*X, N/2)*X; /*return Pow(X, N-1)*X is the same*/\n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK02/#15-checking-your-analysis","title":"1.5 Checking Your Analysis","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK02/#method-1","title":"Method 1","text":"<p>When \\(T(N)=O(N)\\), check if \\(T(2N)/T(N)\\approx2\\)</p> <p>When \\(T(N)=O(N^2)\\), check if \\(T(2N)/T(N)\\approx4\\)</p> <p>When \\(T(N)=O(N^3)\\), check if \\(T(2N)/T(N)\\approx8\\)</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK02/#method-2","title":"Method 2","text":"<p>When \\(T(N)=O(f(N))\\), check if $\\lim\\limits_{N\\rightarrow\\infty}\\frac{T(N)}{f(N)}\\approx C $</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK02/#2-list-stacks-and-queues","title":"2 LIst, Stacks and Queues","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK02/#21-abstract-data-typeadt","title":"2.1 Abstract Data Type(ADT)  \u62bd\u8c61\u6570\u636e\u7c7b\u578b","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK02/#definition-data-type-objects-and","title":"[Definition] Data Type = {Objects} and","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK02/#definition-an-abstract-data-typeadt-is-a-data-type-that-is-organized-in-such-a-way-that-the-specification-on-the-objects-and-specification-of-the-operations-on-the-objects-are-separated-from-the-representation-of-the-objects-and-the-implementation-on-the-operations","title":"[Definition] An Abstract Data Type(ADT) is a data type that is organized in such a way that the specification on the objects and specification of the operations on the objects are separated from the representation of the objects and the implementation on the operations.","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK02/#22-the-list-adt","title":"2.2 The List ADT","text":"<ul> <li>Objects : N items</li> <li>Operations</li> <li>Finding the length</li> <li>Printing</li> <li>Making an empty</li> <li>Finding</li> <li>Inserting</li> <li>Deleting</li> <li>Finding next</li> <li>Finding previous</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK02/#simple-array-implementation-of-lists","title":"Simple Array implementation of Lists","text":"<ul> <li> <p>Sequential mapping \u8fde\u7eed\u5b58\u50a8\uff0c\u8bbf\u95ee\u5feb</p> </li> <li> <p>Find_Kth take \\(O(1)\\) time.</p> </li> <li> <p>MaxSize has to be estimated.</p> </li> <li> <p>Insertion and Deletion not only take \\(O(N)\\) times, but also involve a lot of data movements which takes time.</p> </li> </ul> <p></p> <p>Query \u67e5\u8be2</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK02/#linked-lists","title":"Linked Lists","text":"<ul> <li> <p>Location of nodes may change on differrent runs.</p> </li> <li> <p>Insertion \u5148\u8fde\u540e\u65ad</p> </li> <li> <p>Deletion \u5148\u8fde\u540e\u91ca\u653e</p> </li> <li> <p>\u9891\u7e41malloc\u548cfree\u7cfb\u7edf\u5f00\u9500\u8f83\u5927</p> </li> <li> <p>Finding take \\(O(N)\\) times.</p> </li> </ul> <p><code>c   /*Return true if L is empty*/   int IsEmpty(List L)   {     return L-&gt;Next == NULL;   }</code></p> <p><code>c   /*Return true if P is the last position in list L*/   /*Parameter L is unused in this implementation*/   int IsLast(Position P, List L)   {     return P-&gt;Next == NULL;   }</code></p> <p>```c   /Return Position of X in L; NULL if not found/   Position Find(Element X, List L)   {     Position P;</p> <pre><code>P = L-&gt;Next;\nwhile (P != NULL &amp;&amp; P-&gt;Element != X) P = P-&gt;Next;\n\nreturn P;\n</code></pre> <p>}   ```</p> <p>```c   /Delete first occurence of X from a list/   /Assume use of a header node/   void Delete(ElementType X, List L)   {     Position P, TmpCell;</p> <pre><code>P = FindPrevious(X, L);\n\nif (!IsLast(P, L))\n{\n    TmpCell = P-&gt;Next;\n    P-&gt;Next = TmpCell-&gt;Next;\n    free(TmpCell);\n}\n</code></pre> <p>}   ```</p> <p>```c   /If X is not found, then Next field of returned/   /Assumes a header/   Position FindPrevious(ElementType X, List L)   {     Position P;</p> <pre><code>P = L;\nwhile (P-&gt;Next != NULL &amp;&amp; P-&gt;Next-&gt;Element != X) P = P-&gt;Next;\n\nreturn P;\n</code></pre> <p>}   ```</p> <p>```c   /Insert (after legal position P)/   /Header implementation assumed/   /Parameter L is unused in this implementation/   void Insert(ElementType X, List L, Position P)   {     Position TmpCell;</p> <pre><code>TmpCell = malloc(sizeof(struct Node));\nif (TmpCell == NULL) FatalError(\"Out of space!\")\n\nTmpCell-&gt;Element = X;\nTmpeCell-&gt;Next = P-&gt;Next;\nP-&gt;Next = TmpCell;\n</code></pre> <p>}   ```</p> <p>```c   void DeleteList(List L)   {     Position P, Tmp;</p> <pre><code>P = L-&gt;Next;\nL-&gt;Next = NULL;\nwhile (P != NULL)\n{\n    Tmp = P-&gt;Next;\n    free(P);\n    P = Tmp;\n}\n</code></pre> <p>}   ```</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK02/#doubly-linked-circular-lists","title":"Doubly Linked Circular Lists","text":"<ul> <li>Finding take \\(O(\\frac N 2)\\) times.</li> </ul> <p>The correct answer is D.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK02/#two-applications","title":"Two Applications","text":"<ol> <li> <p>The Polynomial ADT</p> </li> <li> <p>Objects : </p> </li> <li> <p>Operations : </p> </li> <li>Finding degree</li> <li>Addition</li> <li>Subtraction</li> <li> <p>Multiplication</p> </li> <li> <p>Differentiation</p> </li> <li> <p>[Representation 1]</p> </li> </ol> <p><code>c   typedef struct {     int CoeffArray [ MaxDegree + 1 ] ;     int HighPower;   }  *Polynomial ;</code></p> <p><code>c   /*\u5c06\u591a\u9879\u5f0f\u521d\u59cb\u5316\u4e3a\u96f6*/   void ZeroPolynomial(Polynomial Poly)   {     int i;     for(i = O; i &lt;= MaxDegree; i++)         Poly-&gt;CoeffArray[ i ] = O;     Poly-&gt;HighPower = O;   }</code></p> <p>```c   /\u4e24\u4e2a\u591a\u9879\u5f0f\u76f8\u52a0/   void AddPolynomial(const Polynomial Poly1, const Polynomial Poly2, Polynomial PolySum)   {       int i;</p> <pre><code>  ZeroPolynomial(PolySum);\nPolySum-&gt;HighPower = Max(Poly1-&gt;HighPower, Poly2-&gt;HighPower);\n\n  for (i = PolySum-&gt;HighPower; i &gt;= O; i--)\n    PolySum-&gt;CoeffArray[ i ] = Poly1-&gt;CoeffArray[ i ] + Poly2-&gt;CoeffArray[ i ];\n</code></pre> <p>}   ```</p> <p>```c   void MultPolynomial(const Polynomial Poly1, const Polynomial Poly2, Polynomial PolyProd)   {       int i, j;</p> <pre><code>  ZeroPolynomial (PolyProd);\nPolyProd-&gt;HighPower = Poly1-&gt;HighPower + Poly2-&gt;HighPower;\n\n  if(PolyProd-&gt;HighPower &gt; MaxDegree)\n    Error(\"Exceeded array size\");\nelse\n    for(i = O; i &lt;= Poly1-&gt;HighPower; i++)\n        for(j = O; j &lt;= Poly2-&gt;HighPower; j++)\n            PolyProd-&gt;CoeffArray[ i + j ] += Poly1-&gt;CoeffArray[ i ] * Poly2-&gt;CoeffArray[ j ];\n</code></pre> <p>}   ```</p> <ul> <li>[Representation 2]</li> </ul> <p><code>c   typedef struct poly_node *poly_ptr;   struct poly_node{       int Coefficient;  /* assume coefficients are integers */       int Exponent;       poly_ptr Next;   };   typedef poly_ptr a;    /* nodes sorted by exponent */</code></p> <ul> <li> <p>\u53ea\u5b58\u50a8\u975e\u96f6\u9879</p> </li> <li> <p>Multilists</p> </li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK02/#cursor-implementation-of-linked-listsno-pointer","title":"Cursor Implementation of Linked Lists(no pointer)","text":"<p>#blender \u30a8\u30a4\u30b5\u30fc\u30fb\u30d1\u30eb\u30de\u30bf\u30e0 || Acer Palmatum - selescha.arts\u7684\u63d2\u753b - pixiv</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK03/","title":"WEEK 3","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK03/#23-the-stack-adt","title":"2.3 The Stack ADT","text":"<ul> <li>Last-In-First-Out (LIFO)</li> <li>Objects : A finite ordered list with zero or more elements.</li> <li>Operations :</li> <li>IsEmpty</li> <li>CreatStack</li> <li>DisposeStack</li> <li>MakeEmpty</li> <li>Push</li> <li>Top</li> <li>Pop</li> <li>A Pop(or Top) on an empty stack in an error in the stack ADT.</li> <li>Push on a full stack is an implementation error but not an ADT error.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK03/#linked-list-implementation-with-a-header-node","title":"Linked List Implementation (with a header node)","text":"<ul> <li>The calls to malloc and free are expensive. Simply keep another stack as a recycle bin.</li> </ul> <p><code>c   int IsEmpty(Stack S)   {     return S-&gt;Next == NULL;   }</code></p> <p>```c   Stack CreateStack(void)   {     Stack S;     S = malloc(sizeof(struct Node));     if (S == NULL)         Fatal Error(\"Out of space!\");     S-&gt;Next == NULL;     MakeEmpty(S);     return S;   }</p> <p>void MakeEmpty(Stack S)   {     if (S == NULL)         Error(\"Must use CreateStack first\");     else         while(!IsEmpty(S)) Pop(S);   }   ```</p> <p><code>c   void Push(ElementType X, Stack S)   {     PtrToNode TmpCell;     TmpCell = malloc(sizeof(struct Node));     if (TmpCell == NULL)         Fatal Error(\"Out of space!\") ;     else     {         TmpCell-&gt;Element = X;         TmpCe11-&gt;Next = S-&gt;Next;         S-&gt;Next = TmpCell;     }   }</code></p> <p><code>c   ElementType Top(Stack S)   {     if(!IsEmpty(S))         return S-&gt;Next-&gt;Element;     Error(\"Empty stack\") ;     return O; /* Return value used to avoid warning*/   }</code></p> <p><code>c   void Pop(Stack s)   {     PtrToNode FirstCell;     if(IsEmpty(S))         Error(\"Empty stack\") ;     else     {         FirstCe11 = S-&gt;Next;         S-&gt;Next = S-&gt;Next-&gt;Next;         free(FirstCe11);     }   }</code></p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK03/#array-implementation-of-stacks","title":"Array Implementation of Stacks","text":"<pre><code>struct StackRecord {\n    int Capacity;          /* size of stack */\n    int TopOfStack;        /* the top pointer */\n    /* ++ for push, -- for pop, -1 for empty stack */\n    ElementType *Array;    /* array for stack elements */\n}; \n</code></pre> <ul> <li> <p>The stack model must be well encapsulated(\u5c01\u88c5).  That is, no part of your code, except for the stack routines, can attempt to access the Array or TopOfStack variable.</p> </li> <li> <p>Error check must be done before Push or Pop (Top).</p> </li> </ul> <p>```c   Stack CreateStack(int MaxElements)   {     Stack S;     if(MaxElements &lt; MinStackSize)     Error(\"Stack size is too small\") ;     S = malloc(sizeof(struct StackRecord));     if (S == NULL)         Fatal Error(\"Out of space!!!\") ;</p> <pre><code>S-&gt;Array = malloc(sizeof(ElementType) * MaxElements) ;\nif(S-&gt;Array = NULL)\n    Fatal Error(\"Out of space!!!\");\nS-&gt;Capacity = MaxElements;\nMakeEmpty(S) ;\nreturn S;\n</code></pre> <p>}   ```</p> <p><code>c   void DisposeStack(Stack S)   {     if(S != NULL)     {         free(S-&gt;Array);         free(S);     }   }</code></p> <p><code>c   int IsEmpty(Stack S)   {     return S-&gt;TopOfStack == EmptyTOS;   }</code></p> <p><code>c   void MakeEmpty(Stack S)   {     S-&gt;TopOfStack = EmptyTOS;   }</code></p> <p><code>c   void Push(ElementType X, Stack S)   {     if (IsFull(S))         Error(\"Full stack\");     else         S-&gt;Array[ ++S-&gt;TopOfStack ] = X;   }</code></p> <p><code>c   ElementType Top(Stack S)   {     if(! IsEmpty(S))         return S-&gt;Array[ S-&gt;TopOfStack ];     Error(\"Empty stack\") ;     return O; /* Return value used to avoid warning*/   }</code></p> <p><code>c   void Pop(Stack S)   {     if(IsEmpty(S))         Error(\"Empty stack\") ;     else         S-&gt;TopOfStack--;   }</code></p> <p><code>c   ElementType TopAndPop(Stack S)   {     if(!Is Empty(S))         return S-&gt;Array[ S-&gt;TopOfStack-- ];     Error(\"Empty stack\");     return O; /* Return value used to avoid warnin */   }</code></p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK03/#application","title":"Application","text":"<ol> <li>Balancing Symbols</li> </ol> <p>\u68c0\u67e5\u62ec\u53f7\u662f\u5426\u5e73\u8861</p> <p><code>pseudocode    Algorithm  {        Make an empty stack S;        while (read in a character c) {            if (c is an opening symbol)                Push(c, S);            else if (c is a closing symbol) {                if (S is empty)  { ERROR; exit; }                else  {  /* stack is okay */                    if  (Top(S) doesn\u2019t match c)  { ERROR, exit; }                    else  Pop(S);                }  /* end else-stack is okay */            }  /* end else-if-closing symbol */        } /* end while-loop */         if (S is not empty)  ERROR;    }</code></p> <ol> <li> <p>Postfix Evaluation \u540e\u7f00\u8868\u8fbe\u5f0f</p> </li> <li> <p>Infix to Postfix Conversion</p> </li> <li> <p>\u8bfb\u5230\u4e00\u4e2a\u64cd\u4f5c\u6570\u65f6\u7acb\u5373\u628a\u5b83\u653e\u5230\u8f93\u51fa\u4e2d</p> </li> <li>\u8bfb\u5230\u4e00\u4e2a\u64cd\u4f5c\u7b26\u65f6\u4ece\u6808\u4e2d\u5f39\u51fa\u6808\u5143\u7d20\u76f4\u5230\u53d1\u73b0\u4f18\u5148\u7ea7\u66f4\u4f4e\u7684\u5143\u7d20\u4e3a\u6b62\uff0c\u518d\u5c06\u64cd\u4f5c\u7b26\u538b\u5165\u6808\u4e2d</li> <li>The order of operands is the same in infix and postfix.</li> <li>Operators with higher precedence appear before those with lower precedence.</li> <li>Never pop a \u2019(\u2018 from the stack except when processing a \u2018)\u2019.</li> <li>When \u2018(\u2019 is not in the stack, its precedence is the highest; but when it is in the stack, its precedence is the lowest. </li> <li> <p>Exponentiation associates right to left.</p> </li> <li> <p>Function Calls (System Stack)</p> <p></p> <p>Note : Recursion can always be completely removed. Non recursive programs are generally faster than equivalent recursive programs. However, recursive programs are in general much simpler and easier to understand.</p> </li> </ol>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK03/#24-the-queue-adt","title":"2.4 The Queue ADT","text":"<ul> <li>First-In-First-Out (FIFO)</li> <li>Objects : A finite ordered list with zero or more elements.</li> <li>Operations : </li> <li>IsEmpty</li> <li>CreatQueue</li> <li>DisposeQueue</li> <li>MakeEmpty</li> <li>Enqueue</li> <li>Front</li> <li>Dequeue</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK03/#array-implementation-of-queues","title":"Array Implementation of Queues","text":"<pre><code>struct QueueRecord {\n    int Capacity ;       /* max size of queue */\n    int Front;           /* the front pointer */\n    int Rear;            /* the rear pointer */\n    int Size;            /* Optional - the current size of queue */\n    ElementType *Array;  /* array for queue elements */\n }; \n</code></pre> <p>Circular Queue :</p> <p></p> <ul> <li>The maximum capacity of this queue is 5.</li> </ul> <p>Note : Adding a Size field can avoid wasting one empty space to distinguish \u201cfull\u201d from \u201cempty\u201d.  </p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK04/","title":"WEEK 4","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK04/#3-trees","title":"3 Trees \u975e\u5e38\u91cd\u70b9","text":"<p>preorder+inorder \u91cd\u6784\u6811\uff1f</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK04/#31-preliminaries","title":"3.1 Preliminaries","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK04/#definition-a-tree-is-a-collection-of-nodes-the-collection-can-be-empty-otherwise-a-tree-consists-of-1-a-distinguished-node-r-called-the-root-2-and-zero-or-more-nonempty-subtrees-each-of-whose-roots-are-connected-by-a-directed-edge-from-r","title":"[Definition] A tree is a  collection of nodes. The collection can be empty; otherwise, a tree consists of (1)  a distinguished node r, called the root; (2) and zero or more nonempty (sub)trees, each of whose roots are connected by a directed edge from r.","text":"<ul> <li> <p>Subtrees must not connect together.  Therefore every node in the tree is the root of some subtree.</p> </li> <li> <p>There are N-1 edges in a tree with N nodes</p> </li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK04/#terminologies","title":"Terminologies","text":"<ul> <li>degree of a node : \u7ed3\u70b9\u7684\u5b50\u6811\u4e2a\u6570</li> <li>degree of a tree : \u7ed3\u70b9\u7684\u5ea6\u7684\u6700\u5927\u503c</li> <li>parent : \u6709\u5b50\u6811\u7684\u7ed3\u70b9</li> <li>children : the roots of the subtrees of a parent</li> <li>siblings : children of the same parent</li> <li>leaf(terminal node) : a node with degree 0(no children)</li> <li>path from \\(n_1\\) to \\(n_k\\) : a unique sequence of nodes \\(n_1,n_2,\\cdots,n_k\\) such that \\(n_i\\) is the parent of \\(n_{i+1}\\) for \\(1\\leq i&lt;k\\) </li> <li>length of path : \u8def\u5f84\u4e0a\u8fb9\u7684\u6761\u6570</li> <li>depth of \\(n_i\\) : \u4ece\u6839\u7ed3\u70b9\u5230\\(n_i\\)\u7ed3\u70b9\u7684\u8def\u5f84\u7684\u957f\u5ea6(\\(Depth(root)=0\\))</li> <li>height of \\(n_i\\) : \u4ece\\(n_i\\)\u7ed3\u70b9\u5230\u53f6\u7ed3\u70b9\u7684\u6700\u957f\u8def\u5f84\u7684\u957f\u5ea6(\\(Height(leaf)=0\\))</li> <li>height/depth of a tree : \u6839\u7ed3\u70b9\u7684\u9ad8\u5ea6/\u6700\u6df1\u7684\u53f6\u7ed3\u70b9\u7684\u6df1\u5ea6</li> <li>ancestors of a node : \u4ece\u6b64\u7ed3\u70b9\u5230\u6839\u7ed3\u70b9\u7684\u8def\u5f84\u4e0a\u7684\u6240\u6709\u7ed3\u70b9</li> <li>descendants of a node : \u6b64\u7ed3\u70b9\u7684\u5b50\u6811\u4e2d\u7684\u6240\u6709\u7ed3\u70b9</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK04/#list-representation","title":"List Representation","text":"<ul> <li>The size of each node depends on the number of branches.</li> </ul> <p>The correct answer is T.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK04/#firstchild-nextsibling-representation","title":"FirstChild-NextSibling Representation","text":"<ul> <li>The representation is not unique since the children in a tree can be of any order.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK04/#32-binary-trees","title":"3.2 Binary Trees","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK04/#definition-a-binary-tree-is-a-tree-in-which-no-node-can-have-more-than-two-children","title":"[Definition] A binary tree is a tree in which no node can have more than two children.","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK04/#tree-traversals-visit-each-node-exactly-once","title":"Tree Traversals (visit each node exactly once)","text":"<p>\u7ebf\u6027\u590d\u6742\u5ea6\\(O(n)\\)\uff0c\u56e0\u4e3a\u6bcf\u4e2a\u8282\u70b9\u53ea\u8bbf\u95ee\u4e00\u6b21</p> <p>\u904d\u5386\u4e0d\u6539\u53d8\u64cd\u4f5c\u6570\u7684\u987a\u5e8f</p> <p>visit\uff08\u53ef\u4ee5\u662fprint\uff09</p> <ol> <li>Preorder Traversal \u5148\u5904\u7406\u6839\u8282\u70b9\uff0c\u518d\u5904\u7406\u5de6\u53f3\u8282\u70b9\uff0c\u56e0\u6b64preorder\u4e2d\u7b2c\u4e00\u4e2a\u904d\u5386\u5230\u7684\u4e3a\u6839\u8282\u70b9</li> </ol> <p><code>pseudocode    void preorder( tree_ptr tree )    {         if( tree )           {            visit ( tree );            for (each child C of tree )                preorder ( C );        }    }</code></p> <ol> <li>Postorder Traversal\u5148\u5904\u7406\u5de6\u53f3\u5b50\u6811\uff0c\u6839\u8282\u70b9\u6700\u540e\u8fd4\u56de\uff0c\u56e0\u6b64postorder\u4e2d\u6839\u8282\u70b9\u6700\u540e\u8fd4\u56de</li> </ol> <p><code>pseudocode    void postorder( tree_ptr tree )    {       if( tree )        {            for (each child C of tree )             postorder ( C );            visit ( tree );        }    }</code></p> <ol> <li>Levelorder Traversal \u5c42\u5e8f\u904d\u5386\uff0c\u4f7f\u7528\u4e00\u4e2aqueue</li> </ol> <p><code>pseudocode    void levelorder( tree_ptr tree )    {        enqueue ( tree );        while (queue is not empty)         {            visit ( T = dequeue ( ) );            for (each child C of T )                enqueue ( C );        }    }</code></p> <ol> <li>Inorder Traversal \u8fd4\u56de\u987a\u5e8f\u4e3a\u5de6\u3001\u6839\u3001\u53f3\uff0c\u4e2d\u5e8f\u904d\u5386\u6700\u4e3a\u5173\u952e</li> </ol> <p><code>pseudocode    void inorder( tree_ptr  tree )    {           if( tree )        {         inorder ( tree-&gt;Left );             visit ( tree-&gt;Element );             inorder ( tree-&gt;Right );       }    }</code></p> <p>Iterative Program : \u4f7f\u7528\u81ea\u5df1\u5b9a\u4e49\u7684\u6808\u66ff\u6362\u7cfb\u7edf\u7684\u6808\uff0c\u5b9e\u73b0\u4e2d\u5e8f\u904d\u5386</p> <p>leftmost \u7684\u5de6\u8282\u70b9\u548crightmost\u7684\u53f3\u8282\u70b9\u90fd\u662fNULL</p> <p><code>pseudocode    void iter_inorder( tree_ptr tree )    {      Stack  S = CreateStack( MAX_SIZE );     for ( ; ; )       {         for ( ; tree; tree = tree-&gt;Left )             Push ( tree, S );             tree = Top ( S );               Pop( S );             if ( !tree ) break;             visit ( tree-&gt;Element );             tree = tree-&gt;Right;         }    }</code></p> <p></p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK04/#threaded-binary-trees","title":"Threaded Binary Trees","text":"<ul> <li> <p>A full binary tree with \\(n\\) nodes has \\(2n\\) links, and \\(n+1\\) of them are NULL.</p> </li> <li> <p>Replace the NULL links by \u201cthreads\u201d which will make traversals easier.</p> </li> </ul> <p>Rules :</p> <ul> <li>If Tree-&gt;Left is null, replace it with a pointer to the inorder predecessor(\u4e2d\u5e8f\u524d\u9a71) of Tree.</li> <li>leftmost\u7684left\u6307\u9488\u7531\u4e8e\u6ca1\u6709\u4e2d\u5e8f\u524d\u9a71\uff08\u4e2d\u5e8f\u904d\u5386\u4e2d\u6700\u5148\u8fd4\u56de\u7684\u8282\u70b9\uff09\uff0c\u6240\u4ee5\u6307\u5411head node</li> <li>If Tree-&gt;Right is null, replace it with a pointer to the inorder successor(\u4e2d\u5e8f\u540e\u7ee7) of Tree.</li> <li>\u540c\u7406\uff0crightmost\u7684right\u7531\u4e8e\u6ca1\u6709\u4e2d\u5e8f\u540e\u7ee7\uff08\u4e2d\u5e8f\u904d\u5386\u4e2d\u6700\u540e\u8fd4\u56de\u7684\u8282\u70b9\uff09\uff0c\u6240\u4ee5\u4e5f\u6307\u5411head node</li> <li>There must not be any loose threads.  Therefore a threaded binary tree must have a head node of which the left child points to the first node.\uff08\u53f3\u8282\u70b9\u6307\u9488\u6307\u5411\u81ea\u8eab\uff09</li> </ul> <pre><code>typedef struct ThreadedTreeNode *PtrToThreadedNode;\ntypedef struct PtrToThreadedNode ThreadedTree;\ntypedef struct ThreadedTreeNode \n{\n    int LeftThread;        /* if it is TRUE, then Left */\n    ThreadedTree Left;     /* is a thread, not a child ptr.*/\n    ElementType Element;\n    int RightThread;       /* if it is TRUE, then Right */\n    ThreadedTree Right;    /* is a thread, not a child ptr.*/\n}\n</code></pre> <ul> <li>\u7ebf\u7d22\u5316\u7684\u5b9e\u8d28\u5c31\u662f\u5c06\u4e8c\u53c9\u94fe\u8868\u4e2d\u7684\u7a7a\u6307\u9488\u6539\u4e3a\u6307\u5411\u524d\u9a71\u6216\u540e\u7ee7\u7684\u7ebf\u7d22\u3002\u7531\u4e8e\u524d\u9a71\u548c\u540e\u7ee7\u4fe1\u606f\u53ea\u6709\u5728\u904d\u5386\u8be5\u4e8c\u53c9\u6811\u65f6\u624d\u80fd\u5f97\u5230\uff0c\u6240\u4ee5\uff0c\u7ebf\u7d22\u5316\u7684\u8fc7\u7a0b\u5c31\u662f\u5728\u904d\u5386\u7684\u8fc7\u7a0b\u4e2d\u4fee\u6539\u7a7a\u6307\u9488\u7684\u8fc7\u7a0b\u3002</li> </ul> <p></p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK05/","title":"WEEK 5","text":"<ul> <li>In a tree, the order of children does not matter. But in a binary tree, left child and right child are different.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK05/#properties-of-binary-trees","title":"Properties of Binary Trees","text":"<ul> <li>The maximum number of nodes on level \\(i\\) is \\(2^{i-1},i\\geq1\\).</li> <li>The maximum number of nodes in a binary tree of depth \\(k\\) is \\(2^k-1,k\\geq1\\).</li> <li>For any nonempty binary tree, \\(n_0 = n_2 + 1\\) where \\(n_0\\) is the number of leaf nodes and \\(n_2\\) is the number of nodes of degree 2.</li> </ul> <p>proof:   \u5047\u8bbe\u8be5\u4e8c\u53c9\u6811\u603b\u5171\u6709n\u4e2a\u7ed3\u70b9(\\(n =n_0+n_1+n_2\\))\uff0c\u5219\u8be5\u4e8c\u53c9\u6811\u603b\u5171\u4f1a\u6709n-1\u6761\u8fb9\uff0c\u5ea6\u4e3a2\u7684\u7ed3\u70b9\u4f1a\u5ef6\u4f38\u51fa\u4e24\u6761\u8fb9\uff0c</p> <p>\u540c\u7406\uff0c\u5ea6\u4e3a1\u7684\u7ed3\u70b9\u4f1a\u5ef6\u4f38\u51fa\u4e00\u6761\u8fb9\uff0c\u5219\u53ef\u5217\u516c\u5f0f\uff1a$n-1 = 2n_2 + n_1 $\uff0c</p> <p>\u5408\u5e76\u4e24\u4e2a\u5f0f\u5b50\u53ef\u5f97\uff1a\\(2n_2 + n_1 +1 =n_0 + n_1 + n_2\\) \uff0c\u5219\u8ba1\u7b97\u53ef\u77e5 \\(n_0=n_2+1\\)</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK05/#33-binary-search-trees","title":"3.3 Binary Search Trees","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK05/#definition-a-binary-search-tree-is-a-binary-tree-it-may-be-empty-if-it-is-not-empty-it-satisfies-the-following-properties","title":"[Definition] A binary search tree is a binary tree.  It may be empty.  If it is not empty, it satisfies the following properties:","text":"<ul> <li>\u6bcf\u4e2a\u7ed3\u70b9\u6709\u4e00\u4e2a\u4e92\u4e0d\u4e0d\u540c\u7684\u503c</li> <li>\u82e5\u5de6\u5b50\u6811\u975e\u7a7a\uff0c\u5219\u5de6\u5b50\u6811\u4e0a\u6240\u6709\u7ed3\u70b9\u7684\u503c\u5747\u5c0f\u4e8e\u6839\u7ed3\u70b9\u7684\u503c</li> <li>\u82e5\u53f3\u5b50\u6811\u975e\u7a7a\uff0c\u5219\u53f3\u5b50\u6811\u4e0a\u6240\u6709\u7ed3\u70b9\u7684\u503c\u5747\u5927\u4e8e\u6839\u7ed3\u70b9\u7684\u503c</li> <li>\u5de6\u3001\u53f3\u5b50\u6811\u4e5f\u662f\u662f\u4e00\u68f5\u4e8c\u53c9\u67e5\u627e\u6811</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK05/#adt","title":"ADT","text":"<ul> <li>Objects : A finite ordered list with zero or more elements.</li> <li>Operations :</li> <li>SearchTree  MakeEmpty( SearchTree T )</li> <li>Position  Find( ElementType X, SearchTree T )</li> <li>Position  FindMin( SearchTree T )</li> <li>Position  FindMax( SearchTree T )</li> <li>SearchTree  Insert( ElementType X, SearchTree T )</li> <li>SearchTree  Delete( ElementType X, SearchTree T )</li> <li>ElementType  Retrieve( Position P )</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK05/#implementations","title":"Implementations","text":"<ol> <li>Find</li> </ol> <p><code>pseudocode    Position Find( ElementType X, SearchTree T )     {      if ( T == NULL )          return NULL;  /* not found in an empty tree */        if ( X &lt; T-&gt;Element )  /* if smaller than root */            return Find( X, T-&gt;Left );  /* search left subtree */        else          if ( X &gt; T-&gt;Element )  /* if larger than root */             return  Find( X, T-&gt;Right );  /* search right subtree */            else   /* if X == root */             return  T;  /* found */    }</code></p> <ul> <li>\\(T(N)=S(N)=O(d)\\) where \\(d\\) is the depth of X</li> </ul> <p>Iterative program :</p> <p><code>pseudocode    Position Iter_Find( ElementType X, SearchTree T )     {      while ( T )     {         if ( X == T-&gt;Element )               return T;  /* found */            if ( X &lt; T-&gt;Element )                T = T-&gt;Left; /*move down along left path */            else                 T = T-&gt; Right; /* move down along right path */        }  /* end while-loop */        return NULL;   /* not found */    }</code></p> <ol> <li>FindMin</li> </ol> <p><code>pseudocode    Position FindMin( SearchTree T )     {      if ( T == NULL )            return NULL; /* not found in an empty tree */        else             if ( T-&gt;Left == NULL ) return T;  /* found left most */            else return FindMin( T-&gt;Left );   /* keep moving to left */    }</code></p> <ol> <li>FindMax</li> </ol> <p><code>pseudocode    Position FindMax( SearchTree T )     {      if ( T != NULL )          while ( T-&gt;Right != NULL )                T = T-&gt;Right;   /* keep moving to find right most */        return T;  /* return NULL or the right most */    }</code></p> <ol> <li>Insert</li> </ol> <p><code>pseudocode    SearchTree Insert( ElementType X, SearchTree T )     {         if ( T == NULL ) /* Create and return a one-node tree */         {          T = malloc( sizeof( struct TreeNode ) );          if ( T == NULL )              FatalError( \"Out of space!!!\" );          else          {              T-&gt;Element = X;              T-&gt;Left = T-&gt;Right = NULL;          }         }  /* End creating a one-node tree */        else  /* If there is a tree */             if ( X &lt; T-&gt;Element )              T-&gt;Left = Insert( X, T-&gt;Left );          else              if ( X &gt; T-&gt;Element )                  T-&gt;Right = Insert( X, T-&gt;Right );          /* Else X is in the tree already; we'll do nothing */         return  T;   /* Do not forget this line!! */     }</code></p> <ul> <li>\u5185\u5b58\u8d8a\u754c\u540e\u4e0d\u4f1a\u9a6c\u4e0a\u62a5\u9519\uff0c\u5728\u4e0b\u4e00\u6b21free\u6216malloc\u65f6\u4f1a\u5931\u8d25</li> <li>Handle duplicated keys</li> <li> <p>\\(T(N)=O(d)\\)</p> </li> <li> <p>Delete</p> </li> <li> <p>Delete a leaf node : Reset its parent link to NULL</p> </li> <li>Delete a degree 1 node : Replace the node by its single child</li> <li>Delete a degree 2 node : \u7528\u5de6\u5b50\u6811\u6700\u5927\u503c\u7ed3\u70b9\u6216\u53f3\u5b50\u6811\u6700\u5c0f\u503c\u7ed3\u70b9\u66ff\u6362</li> </ul> <p><code>pseudocode    SearchTree Delete( ElementType X, SearchTree T )     {         Position TmpCell;         if ( T == NULL ) Error( \"Element not found\" );         else if ( X &lt; T-&gt;Element )  /* Go left */          T-&gt;Left = Delete( X, T-&gt;Left );         else if ( X &gt; T-&gt;Element )  /* Go right */          T-&gt;Right = Delete( X, T-&gt;Right );      else  /* Found element to be deleted */          if ( T-&gt;Left &amp;&amp; T-&gt;Right ) {  /* Two children */          /* Replace with smallest in right subtree */              TmpCell = FindMin( T-&gt;Right );              T-&gt;Element = TmpCell-&gt;Element;              T-&gt;Right = Delete( T-&gt;Element, T-&gt;Right );  } /* End if */         else          {  /* One or zero child */              TmpCell = T;              if ( T-&gt;Left == NULL ) /* Also handles 0 child */                  T = T-&gt;Right;              else if ( T-&gt;Right == NULL )                   T = T-&gt;Left;              free( TmpCell );            }  /* End else 1 or 0 child */          return  T;     }</code></p> <ul> <li>\\(T(N)=O(d)\\)</li> </ul> <p>Note : If there are not many deletions, then lazy deletion may be employed: add a flag field to each node, to mark if a node is active or is deleted.  Therefore we can delete a node without actually freeing the space of that node.  If a deleted key is reinserted, we won\u2019t have to call malloc again.</p> <ol> <li> <p>Average-Case Analysis</p> </li> <li> <p>The average depth over all nodes in a tree is \\(O(logN)\\) on the assumption that all trees are equally likely.</p> </li> <li>\u5c06\\(n\\)\u4e2a\u5143\u7d20\u5b58\u5165\u4e8c\u53c9\u641c\u7d22\u6811\uff0c\u6811\u7684\u9ad8\u5ea6\u5c06\u7531\u63d2\u5165\u5e8f\u5217\u51b3\u5b9a</li> </ol> <p></p> <p>The correct answer is A.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK06/","title":"WEEK 6","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK06/#4-priority-queues-heaps","title":"4 Priority Queues (Heaps)","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK06/#41-adt-model","title":"4.1 ADT Model","text":"<ul> <li>Objects :A finite ordered list with zero or more elements.</li> <li>Operations :</li> <li>PriorityQueue  Initialize( int MaxElements ); </li> <li>void  Insert( ElementType X, PriorityQueue H ); </li> <li>ElementType  DeleteMin( PriorityQueue H ); </li> <li>ElementType  FindMin( PriorityQueue H ); </li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK06/#42-implementations","title":"4.2 Implementations","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK06/#array","title":"Array","text":"<ul> <li> <p>Insertion \u2014 add one item at the end ~\\(\\Theta(1)\\)</p> </li> <li> <p>Deletion \u2014 find the largest / smallest key ~\\(\\Theta(n)\\)</p> </li> </ul> <p>\u200b                     remove the item and shift array ~\\(O(n)\\)</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK06/#linked-list","title":"Linked List","text":"<ul> <li> <p>Insertion \u2014 add to the front of the chain ~\\(\\Theta(1)\\)</p> </li> <li> <p>Deletion \u2014 find the largest / smallest key ~\\(\\Theta(n)\\)</p> </li> </ul> <p>\u200b                      remove the item ~\\(\\Theta(1)\\)</p> <ul> <li>Never more deletions than insertions</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK06/#ordered-array","title":"Ordered Array","text":"<ul> <li>Insertion \u2014 find the proper position ~\\(O(\\log n)\\)</li> </ul> <p>\u200b                      shift array and add the item  ~\\(O(n)\\)</p> <ul> <li>Deletion \u2014 remove the first / last item ~\\(\\Theta(1)\\)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK06/#ordered-linked-list","title":"Ordered Linked List","text":"<ul> <li>Insertion \u2014 find the proper position ~\\(O(n)\\)</li> </ul> <p>\u200b                      add the item  ~\\(\\Theta(1)\\)</p> <ul> <li>Deletion \u2014 remove the first / last item ~\\(\\Theta(1)\\)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK06/#binary-search-tree","title":"Binary Search Tree","text":"<ul> <li>Both insertion and deletion will take \\(O(\\log N)\\) only.</li> <li>Only delete the the minimum element, always delete from the left subtrees.</li> <li>Keep a balanced tree </li> <li>But there are many operations related to AVL tree that we don't really need for a priority queue.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK06/#43-binary-heap","title":"4.3 Binary Heap","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK06/#structure-property","title":"Structure Property","text":"<p>[Definition] A binary tree with \\(n\\) nodes and height \\(h\\) is complete  if  its nodes correspond to the nodes numbered from \\(1\\) to \\(n\\) in the perfect binary tree of height \\(h\\).</p> <ul> <li> <p>A complete binary tree of height \\(h\\) has between \\(2^h\\) and \\(2^{h+1}-1\\) nodes.</p> </li> <li> <p>\\(h=\\lfloor\\log N\\rfloor\\)</p> </li> <li> <p>Array Representation : BT[n + 1]  ( BT[0] is not used)</p> </li> </ul> <p></p> <p>[Lemma] </p> <ol> <li>\\(index\\,of\\,parent(i)=\\left\\{    \\begin{array}{rcl}    \\lfloor i/2\\rfloor &amp;&amp; {i\\neq1}\\\\    None &amp;&amp; {i=1}\\\\    \\end{array} \\right.\\)</li> <li>\\(index\\,of\\,left\\_child(i)=\\left\\{    \\begin{array}{rcl}    2i &amp;&amp; {2i\\leq n}\\\\    None &amp;&amp; {2i&gt;n}\\\\    \\end{array} \\right.\\)</li> <li>\\(index\\,of\\,right\\_child(i)=\\left\\{    \\begin{array}{rcl}    2i+1 &amp;&amp; {2i+1\\leq n}\\\\    None &amp;&amp; {2i+1&gt;n}\\\\    \\end{array} \\right.\\)</li> </ol> <pre><code>PriorityQueue Initialize( int MaxElements ) \n{ \n    PriorityQueue H; \n    if ( MaxElements &lt; MinPQSize ) \n        return Error( \"Priority queue size is too small\" ); \n    H = malloc(sizeof( struct HeapStruct )); \n    if ( H == NULL ) \n        return FatalError( \"Out of space!!!\" ); \n    /* Allocate the array plus one extra for sentinel */ \n    H-&gt;Elements = malloc(( MaxElements + 1 ) * sizeof( ElementType )); \n    if ( H-&gt;Elements == NULL ) \n        return FatalError( \"Out of space!!!\" ); \n    H-&gt;Capacity = MaxElements; \n    H-&gt;Size = 0; \n    H-&gt;Elements[0] = MinData;  /* set the sentinel */\n    return H; \n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK06/#heap-order-property","title":"Heap Order Property","text":"<p>[Definition] A min tree is a tree in which the key value in each node is no larger than the key values in its children (if any).  A min heap is a complete binary tree that is also a min tree.</p> <ul> <li>We can declare a max heap by changing the heap order property.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK06/#basic-heap-operations","title":"Basic Heap Operations","text":"<ol> <li>Insertion</li> </ol> <p><code>c    /*H-&gt;Element[ 0 ] is a sentinel that is no larger than the minimum element in the heap.*/     void Insert( ElementType X, PriorityQueue H )     {      int i;         if ( IsFull( H ))         {          Error( \"Priority queue is full\" );          return;         }         for ( i = ++H-&gt;Size; H-&gt;Elements[ i/2 ] &gt; X; i /= 2 )          H-&gt;Elements[ i ] = H-&gt;Elements[ i/2 ]; /*Percolate up, faster than swap*/        H-&gt;Elements[ i ] = X;     }</code></p> <p>$$    T(N)=O(\\log N)    $$</p> <ol> <li>DeleteMin</li> </ol> <p><code>c    ElementType DeleteMin( PriorityQueue H )     {         int i, Child;         ElementType MinElement, LastElement;         if ( IsEmpty( H ) )         {             Error( \"Priority queue is empty\" );             return H-&gt;Elements[ 0 ];           }         MinElement = H-&gt;Elements[ 1 ];  /*Save the min element*/        LastElement = H-&gt;Elements[ H-&gt;Size-- ];  /*Take last and reset size*/        for ( i = 1; i * 2 &lt;= H-&gt;Size; i = Child )  /*Find smaller child*/         {            Child = i * 2;             if (Child != H-&gt;Size &amp;&amp; H-&gt;Elements[Child+1] &lt; H-&gt;Elements[Child])                  Child++;                 if ( LastElement &gt; H-&gt;Elements[ Child ] )   /*Percolate one level*/                  H-&gt;Elements[ i ] = H-&gt;Elements[ Child ];             else                  break;   /*Find the proper position*/        }         H-&gt;Elements[ i ] = LastElement;         return MinElement;     }</code> $$ T(N)=O(\\log N) $$</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK06/#other-heap-operations","title":"Other Heap Operations","text":"<ul> <li> <p>\u67e5\u627e\u9664\u6700\u5c0f\u503c\u4e4b\u5916\u7684\u503c\u9700\u8981\u5bf9\u6574\u4e2a\u5806\u8fdb\u884c\u7ebf\u6027\u626b\u63cf</p> </li> <li> <p>DecreaseKey \u2014 Percolate up</p> </li> <li> <p>IncreaseKey \u2014 Percolate down</p> </li> <li> <p>Delete</p> </li> <li> <p>BuildHeap</p> </li> </ul> <p>\u5c06N \u4e2a\u5173\u952e\u5b57\u4ee5\u4efb\u610f\u987a\u5e8f\u653e\u5165\u6811\u4e2d\uff0c\u4fdd\u6301\u7ed3\u6784\u7279\u6027\uff0c\u518d\u6267\u884c\u4e0b\u6ee4</p> <p><code>c    for (i = N/2; i &gt; 0; i--)     PercolateDown(i);</code></p> <p>$$    T(N)=O(N)    $$</p> <p>[Theorem] For the perfect binary tree of height \\(h\\) containing \\(2^{h+1}-1\\) nodes, the sum of the heights of the nodes is \\(2^{h+1}-1-(h+1)\\).</p> <p></p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK06/#44-applications-of-priority-queues","title":"4.4 Applications of Priority Queues","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK06/#heap-sort","title":"Heap Sort","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK06/#k","title":"\u67e5\u627e\u4e00\u4e2a\u5e8f\u5217\u4e2d\u7b2ck\u5c0f\u7684\u5143\u7d20","text":"<p>The function is to find the <code>K</code>-th smallest element in a list <code>A</code> of <code>N</code> elements.  The function <code>BuildMaxHeap(H, K)</code> is to arrange elements <code>H[1]</code> ... <code>H[K]</code> into a max-heap.  </p> <pre><code>ElementType FindKthSmallest ( int A[], int N, int K )\n{   /* it is assumed that K&lt;=N */\n    ElementType *H;\n    int i, next, child;\n\n    H = (ElementType*)malloc((K+1)*sizeof(ElementType));\n    for ( i = 1; i &lt;= K; i++ ) H[i] = A[i-1];\n    BuildMaxHeap(H, K);\n\n    for ( next = K; next &lt; N; next++ ) {\n        H[0] = A[next];\n        if ( H[0] &lt; H[1] ) {\n            for ( i = 1; i*2 &lt;= K; i = child ) {\n                child = i*2;\n                if ( child != K &amp;&amp; H[child+1] &gt; H[child] ) child++;\n                if ( H[0] &lt; H[child] )\n                    H[i] = H[child];\n                else break;\n            }\n            H[i] = H[0];\n        }\n    }\n    return H[1];\n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK06/#45-d-heaps-all-nodes-have-d-children","title":"4.5 \\(d\\)-Heaps \u2014 All nodes have \\(d\\) children","text":"<p>Note :</p> <ul> <li>DeleteMin will take \\(d-1\\) comparisons to find the smallest child. Hence the total time complexity would be \\(O(d \\log_d N)\\).</li> <li>2 or /2 is merely a bit shift, but d or /d is not.</li> <li>When the priority queue is too large to fit entirely in main memory, a d-heap will become interesting.</li> </ul> <p></p> <p></p> <p>\u6b63\u786e\u7b54\u6848\u662f4\uff0c\u6ce8\u610f\u201cin the process\u201d</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK07/","title":"WEEK 7","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK07/#5-the-disjoint-set","title":"5 The Disjoint Set","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK07/#51-equivalence-relations","title":"5.1 Equivalence Relations","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK07/#definition-a-relation-r-is-defined-on-a-set-s-if-for-every-pair-of-elements-a-b-a-b-in-s-a-r-b-is-either-true-or-false-if-a-r-b-is-true-then-we-say-that-a-is-related-to-b","title":"[Definition] A relation R is defined on a set S if for every pair of elements (a, b), a, b \\(\\in\\) S, a R b is either true or false.  If a R b is true, then we say that a is related to b.","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK07/#definition-a-relation-over-a-set-s-is-said-to-be-an-equivalence-relation-over-s-if-it-is-symmetric-reflexive-and-transitive-over-s","title":"[Definition] A relation, ~, over a set, S, is said to be an equivalence relation over S if it is symmetric, reflexive, and transitive over S.","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK07/#definition-two-members-x-and-y-of-a-set-s-are-said-to-be-in-the-same-equivalence-class-if-x-y","title":"[Definition] Two members x and y of a set S are said to be in the same equivalence class if x ~ y.","text":"<p>\u5173\u7cfb\u7684\u51e0\u79cd\u7c7b\u578b \u81ea\u53cd\u5173\u7cfb\uff08reflexive\uff09 \u8bbe R\u662f A\u4e0a\u7684\u4e00\u4e2a\u4e8c\u5143\u5173\u7cfb\uff0c\u82e5\u5bf9\u4e8e A\u4e2d\u7684\u6bcf\u4e00\u4e2a\u5143\u7d20 a\uff0c (a,a)\u90fd\u5c5e\u4e8e R\uff0c\u5219\u79f0 R\u4e3a\u81ea\u53cd\u5173\u7cfb\u3002</p> <p>\u975e\u81ea\u53cd\u5173\u7cfb\uff08irreflexive\uff09 \u8bbeR\u662fA\u4e0a\u7684\u5173\u7cfb\u3002\u82e5\u5bf9\u6240\u6709a\u2208A\uff0c\u5747\u6709(a\uff0ca)\u2208 R\uff0c\u5219\u79f0R\u662fA\u4e0a\u7684\u4e00\u4e2a\u81ea\u53cd\u5173\u7cfb</p> <p>\u5bf9\u79f0\u5173\u7cfb\uff08symmetric\uff09 \u96c6\u5408A\u4e0a\u7684\u4e8c\u5143\u5173\u7cfbR\uff0c\u5bf9\u4efb\u4f55a\uff0cb\u2208A\uff0c\u5f53aRb\u65f6\u6709bRa</p> <p>\u975e\u5bf9\u79f0\u5173\u7cfb\uff08asymmetric\uff09 \u96c6\u5408A\u4e0a\u7684\u4e8c\u5143\u5173\u7cfbR\uff0c\u5bf9\u4efb\u4f55a\uff0cb\u2208A\uff0c\u5f53aRb\u65f6\u6709bR a</p> <p>\u53cd\u5bf9\u79f0\u5173\u7cfb\uff08antisymmetric\uff09</p> <p></p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK07/#52-the-dynamic-equivalence-problem","title":"5.2 The Dynamic Equivalence Problem","text":"<ul> <li>Given an equivalence relation ~, decide for any a and b if a ~ b</li> </ul> <p><code>pseudocode   Algorithm: (Union/Find)   {     /* step 1: read the relations in */       Initialize N disjoint sets;       while ( read in a ~ b )       {         if ( !(Find(a) == Find(b)) )  /*Dynamic(on-line)*/             Union the two sets;       } /* end-while */       /* step 2: decide if a ~ b */       while ( read in a and b )           if ( Find(a) == Find(b) )             output( true );           else                output( false );   }</code></p> <ul> <li>Elements of the sets : \\(1,2,3,\\cdots,N\\)</li> <li>Sets : \\(S_1,S_2,\\cdots\\,and\\,S_i\\bigcap S_j=\\emptyset\\,(if\\quad i\\neq j)\\)</li> <li> <p>Operations :</p> </li> <li> <p>Union( \\(i, j\\) ) = Replace \\(S_i\\) and \\(S_j\\) by \\(S=S_i\\bigcup S_j\\)</p> </li> <li>Find( \\(i\\) ) = Find the set \\(S_k\\) which contains the element \\(i\\)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK07/#53-basic-data-structure","title":"5.3 Basic Data Structure","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK07/#union-i-j","title":"Union( \\(i, j\\) )","text":"<ul> <li> <p>Make \\(S_i\\) a subtree of \\(S_j\\), or vice versa, that is to set the parent pointer of one of the roots to the other root.</p> </li> <li> <p>Implementation 1 :</p> </li> </ul> <p></p> <ul> <li> <p>Implementation 2 :</p> </li> <li> <p>The elements are numbered from 1 to N, hence they can be used as indices of an array.</p> </li> <li> <p>S[ element ] = the element\u2019s parent</p> </li> <li> <p>Note : S[ root ] = 0 and set name = root index</p> </li> <li>\u6570\u7ec4\u521d\u59cb\u5316\u5168\u90e8\u4e3a0</li> </ul> <p><code>c   void SetUnion(DisjSet S, SetType Rt1, SetType Rt2)   {     S[Rt2] = Rt1;   }</code></p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK07/#find-i","title":"Find( \\(i\\) )","text":"<ul> <li>Implementation 1 :</li> </ul> <ul> <li>Implementation 2 :</li> </ul> <p><code>c   SetType Find(ElementType X, DisjSet S)   {     for ( ; S[X]&gt;0; X=S[X]);     return X;   }</code></p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK07/#analysis","title":"Analysis","text":"<ul> <li>Union and find are always paired. Thus we consider the performance of a sequence of union-find operations.</li> </ul> <pre><code>Algorithm using union-find operations:\n{  \n    Initialize Si = { i }  for  i = 1, ..., 12 ;\n    for ( k = 1; k &lt;= 9; k++ )  /* for each pair i R j */\n    {\n        if ( Find( i ) != Find( j ) )\n            SetUnion( Find( i ), Find( j ) );\n    }\n}\n</code></pre> <ul> <li>Worst case : \\(T(N)=\\Theta(N^2)\\)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK07/#54-smart-union-algorithms","title":"5.4 Smart Union Algorithms","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK07/#union-by-size","title":"Union-by-Size","text":"<ul> <li> <p>Always change the smaller tree</p> </li> <li> <p>S[Root] = -size, initialized to be -1</p> </li> <li> <p>[Lemma] Let T be a tree created by union-by-size with N nodes, then \\(height(T)\\leq\\lfloor\\log_2N\\rfloor+1\\).</p> </li> </ul> <p>Proved by induction. Each element can have its set name changed at most \\(\\log_2N\\) times.</p> <ul> <li>Time complexity of \\(N\\) Union and \\(M\\) Find operations is now \\(O(N+M\\log_2N)\\).</li> </ul> <pre><code>/* Assumes Rootl and Root2 are roots*/\nvoid SetUnion(DisjSet S, SetType Root1, SetType Root2)\n{\n    if (S[Root1] &lt;= S[Root2])\n    {\n        S[Root1] += S[Root2];\n        S[Root2] = Root1;\n    }\n    else\n    {\n        S[Root2] += S[Root1];\n        S[Root1] = Root2;\n    }\n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK07/#union-by-height","title":"Union-by-Height","text":"<ul> <li>Always change the shallow tree</li> <li>\u4fdd\u8bc1\u6240\u6709\u7684\u6811\u7684\u6df1\u5ea6\u6700\u591a\u662f\\(O(logN)\\)</li> </ul> <pre><code>/* Assumes Rootl and Root2 are roots*/\nvoid SetUnion(DisjSet S, SetType Root1, SetType Root2)\n{\n    if ( S[Root2] &lt; S[Root1])  /*Root2 is deeper set*/\n        S[Root1] = Root2;      /*Make Root2 new root*/\n    else\n    {\n        if (S[Root1] == S[Root2])  /*Same height*/\n            S[Root1]--;\n        S[Root2] = Root1;\n    }\n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK07/#55-path-compression","title":"5.5 Path Compression","text":"<ul> <li>\u4eceX\u5230Root\u7684\u8def\u5f84\u4e0a\u7684\u6bcf\u4e00\u4e2a\u7ed3\u70b9\u90fd\u4f7f\u5b83\u7684\u7236\u7ed3\u70b9\u53d8\u6210Root</li> </ul> <pre><code>SetType Find( ElementType X, DisjSet S )\n{\n    if ( S[ X ] &lt;= 0 )    \n        return X;\n    else \n        return S[ X ] = Find( S[ X ], S );\n}\n</code></pre> <pre><code>SetType Find( ElementType X, DisjSet S )\n{   \n    ElementType root, trail, lead;\n    for ( root = X; S[ root ] &gt; 0; root = S[ root ] );  /* find the root */\n    for ( trail = X; trail != root; trail = lead )\n    {\n        lead = S[ trail ];   \n        S[ trail ] = root;   \n    }  /* collapsing */\n    return root;\n}\n</code></pre> <ul> <li>Note : Not compatible with union-by-height since it changes the heights.  Just take \u201cheight\u201d as an estimated rank.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK07/#56-worst-case-for-union-by-rank-and-path-compression","title":"5.6 Worst Case for Union-by-Rank and Path Compression","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK07/#lemma-let-tmn-be-the-maximum-time-required-to-process-an-intermixed-sequence-of-mgeq-n-finds-and-n-1-unions-then-k_1malphamnleq-tmnleq-k_2malphamn-for-some-positive-constants-k_1-and-k_2","title":"[Lemma] Let \\(T(M,N)\\) be the maximum time required to process an intermixed sequence of \\(M\\geq N\\) finds and \\(N-1\\) unions, then \\(k_1M\\alpha(M,N)\\leq T(M,N)\\leq k_2M\\alpha(M,N)\\) for some positive constants \\(k_1\\) and \\(k_2\\).","text":"<ul> <li>Ackermann\u2019s Function   $$   A(i,j)=\\left{   \\begin{array}{rcl}   2^j &amp;&amp; {i=1,j\\geq1}\\   A(i-1,2) &amp;&amp; {i\\geq2,j=1}\\   A(i-1,A(i,j-1)) &amp;&amp; {i\\geq2,j\\geq2}\\   \\end{array} \\right.   $$</li> </ul> <p>$$   A(2,4)=2^{2^{2^{2^2}}}=2^{65536}   $$</p> <ul> <li>\\(\\alpha(M,N)=min\\{i\\geq1|A(i,\\lfloor M/N\\rfloor)&gt;\\log N\\}\\leq O(\\log^*N)\\leq4\\)</li> </ul> <p>\\(\\log^*N\\) (inverse Ackermann function) = number of times the logarithm is applied to \\(N\\) until the result \\(\\leq1\\).</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK07/#_1","title":"\u8981\u6c42\u65f6\u95f4\u590d\u6742\u5ea6\u8bc1\u660e","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK07/#57-conclusion","title":"5.7 Conclusion","text":"<p>\u4e00\u5171\u6709\u4e94\u79cd\u7b97\u6cd5\uff0c\u6ce8\u610f\u770b\u6e05\u9898\u8bbe</p> <ul> <li> <p>No smart union</p> </li> <li> <p>Union-by-size</p> </li> <li> <p>Union-by-height</p> </li> <li> <p>Union-by-size + Path Compression</p> </li> <li> <p>Union-by-height + Path Compression</p> </li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/","title":"WEEK 8","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#6-graph-algorithms","title":"6 Graph Algorithms","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#61-definitions","title":"6.1 Definitions","text":"<ul> <li>\\(G( V, E )\\) where \\(G\\) = graph, \\(V = V( G )\\) = finite nonempty set of vertices, and \\(E = E( G )\\) = finite set of edges.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#undirected-graph","title":"Undirected graph","text":"<ul> <li>\\(( v_i , v_j ) = ( v_j , v_i )\\) = the same edge.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#directed-graphdiagraph","title":"Directed graph(diagraph)","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#restrictions","title":"Restrictions","text":"<ul> <li>Self loop is illegal.</li> <li>Multigraph is not considered.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#complete-graph","title":"Complete graph","text":"<ul> <li>A graph that has the maximum number of edges.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#adjacent","title":"Adjacent","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#subgraph","title":"Subgraph","text":"\\[ G'\\subset G=V(G')\\subseteq V(G) \\&amp;\\&amp; E(G')\\subseteq E(G) \\]"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#path","title":"Path","text":"<ul> <li>Path(\\(\\subset G\\)) from \\(v_p\\) to \\(v_q\\) = \\(\\{v_p,v_{i1},v_{i2},\\cdots,v_{in},v_q\\}\\) such that \\((v_p,v_{i1}),(v_{i1},v_{i2}),\\cdots,(v_{in},v_q)\\) belong to \\(E(G)\\)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#length-of-a-path","title":"Length of a path","text":"<ul> <li>number of edges on the path</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#simple-path","title":"Simple path","text":"<ul> <li>\\(v_{i1},v_{i2},\\cdots,v_{in}\\) are distinct.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#cycle","title":"Cycle","text":"<ul> <li>simple path with \\(v_p=v_q\\)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#connected","title":"Connected","text":"<ul> <li>\\(v_i\\) and \\(v_j\\) in an undirected \\(G\\) are connected if there is a path from \\(v_i\\) to \\(v_j\\) (and hence there is also a path from \\(v_j\\) to \\(v_i\\))</li> <li>An undirected graph \\(G\\) is connected if every pair of distinct \\(v_i\\) and \\(v_j\\) are connected</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#connected-component-of-an-undirected-g","title":"(Connected) Component of an undirected G","text":"<ul> <li>the maximal connected subgraph</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#tree","title":"Tree","text":"<ul> <li>a graph that is connected and acyclic(\u975e\u5faa\u73af\u7684)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#dag","title":"DAG","text":"<ul> <li>a directed acyclic graph</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#strongly-connected-directed-graph-g","title":"Strongly connected directed graph G","text":"<ul> <li>For every pair of \\(v_i\\) and \\(v_j\\) in \\(V( G )\\), there exist directed paths from \\(v_i\\) to \\(v_j\\) and from \\(v_j\\) to \\(v_i\\).  </li> <li>If the graph is connected without direction to the edges, then it is said to be weakly connected</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#strongly-connected-component","title":"Strongly connected component","text":"<ul> <li>the maximal subgraph that is strongly connected</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#degree","title":"Degree","text":"<ul> <li> <p>number of edges incident to v</p> </li> <li> <p>For a directed G, we have in-degree and out-degree.</p> </li> <li> <p>Given G with \\(n\\) vertices and \\(e\\) edges, then   $$   e=(\\sum_{i=0}^{n-1}d_i)/2\\quad where\\quad d_i=degree(v_i)   $$</p> </li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#62-representation-of-graphs","title":"6.2 Representation of Graphs","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#adjacency-matrix","title":"Adjacency Matrix","text":"<p>Note : If G is undirected, then adj_mat[][] is symmetric. Thus we can save space by storing only half of the matrix.</p> <p></p> <ul> <li> <p>This representation wastes space if the graph has a lot of vertices but very few edges.</p> </li> <li> <p>To find out whether or not \\(G\\) is connected, we\u2019ll have to examine all edges. In this case \\(T\\) and \\(S\\) are both \\(O( n^2 )\\).</p> </li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#adjacency-lists","title":"Adjacency Lists","text":"<ul> <li>Replace each row by a linked list</li> </ul> <p>Note : The order of nodes in each list does not matter.</p> <ul> <li>For undirected \\(G\\), \\(S\\) = \\(n\\) heads + \\(2e\\) nodes  = \\((n+2e)\\) ptrs + \\(2e\\) ints</li> <li>Degree(i) = number of nodes in graph[i](if \\(G\\) is undirected)</li> <li>\\(T\\) of examine \\(E(G)\\) = \\(O(n+e)\\)</li> </ul> <p></p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#adjacency-multilists","title":"Adjacency Multilists","text":"<ul> <li>Sometimes we need to mark the edge after examine it, and then find the next edge.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#weighted-edges","title":"Weighted Edges","text":"<ul> <li>adj_mat [ i ] [ j ] = weight</li> <li>adjacency lists / multilists :  add a weight field to the node</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#63-topological-sort","title":"6.3 Topological Sort \u62d3\u6251\u6392\u5e8f \u4e0d\u662f\u4e00\u79cd\u4e25\u683c\u610f\u4e49\u7684\u6392\u5e8f\u7b97\u6cd5","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#aov-activity-on-vertices-network","title":"AOV  activity on vertices  Network \u6709\u5411\u65e0\u73af\u56fe","text":"<ul> <li>digraph \\(G\\) in which \\(V( G )\\) represents activities and \\(E( G )\\) represents precedence relations </li> <li>Feasible AOV network must be a directed acyclic graph\uff08DAG\uff09.</li> <li>\\(i\\)  is a predecessor of \\(j\\) = there is a path from \\(i\\)  to \\(j\\)</li> <li>\\(i\\)  is an immediate predecessor of  \\(j\\) = \\(&lt; i,  j &gt; \\in E( G )\\). Then \\(j\\) is called a successor(immediate successor) of \\(i\\)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#partial-order","title":"Partial order","text":"<ul> <li>a precedence relation which is both transitive and irreflexive </li> </ul> <p>Note : If the precedence relation is reflexive, then there must be an \\(i\\) such that \\(i\\) is a predecessor of \\(i\\).  That is, \\(i\\) must be done before \\(i\\) is started. Therefore if a project is feasible, it must be irreflexive.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK08/#definition-a-topological-order-is-a-linear-ordering-of-the-vertices-of-a-graph-such-that-for-any-two-vertices-i-j-if-i-is-a-predecessor-of-j-in-the-network-then-i-precedes-j-in-the-linear-ordering","title":"[Definition] A topological order is a linear ordering  of the vertices of a graph such that, for any two vertices, \\(i\\), \\(j\\), if \\(i\\) is a predecessor of \\(j\\) in the network then \\(i\\) precedes \\(j\\) in the linear ordering.","text":"<p>Note : The topological orders may not be unique for a network.</p> <pre><code>/*Test an AOV for feasibility, and generate a topological order if possible*/\nvoid Topsort( Graph G )\n{   \n    int Counter;\n    Vertex V, W;\n    for ( Counter = 0; Counter &lt; NumVertex; Counter++ ) \n    {\n        V = FindNewVertexOfDegreeZero( );\n        if ( V == NotAVertex ) //\u786e\u8ba4\u56fe\u4e2d\u65e0\u73af\uff1f\n        {\n            Error ( \u201cGraph has a cycle\u201d );   \n            break;  \n        }\n        TopNum[ V ] = Counter; /* or output V */\n        for ( each W adjacent to V )\n            Indegree[ W ]\u2013\u2013; //\u5bf9\u6240\u6709\u524d\u7f6e\u9009\u8bfe\u8981\u6c42\u6709V\u7684\u8bfe\u7a0b\uff0c\u5728\u4fee\u4e4b\u524d\u5fc5\u987b\u4fee\u5b8c\u7684\u8bfe\u5c11\u4e86\u4e00\u95e8\n    }\n}\n</code></pre> \\[ T=O(|V|^2+|E|) = O(|V|^2) \\] <pre><code>/*Improvment:Keep all the unassigned vertices of degree 0 in a special box (queue or stack)*/\nvoid Topsort( Graph G )\n{   \n    Queue Q;\n    int Counter = 0;\n    Vertex V, W;\n    Q = CreateQueue( NumVertex );  \n    MakeEmpty( Q );\n    for ( each vertex V )\n        if ( Indegree[ V ] == 0 ) Enqueue( V, Q );\n    while ( !IsEmpty( Q ) ) \n    {\n        V = Dequeue( Q );\n        TopNum[ V ] = ++Counter; /* assign next */\n        for ( each W adjacent to V )\n            if (\u2013\u2013Indegree[ W ] == 0 ) Enqueue( W, Q );\n    }  /* end-while */\n    if ( Counter != NumVertex )\n    Error( \u201cGraph has a cycle\u201d );\n    DisposeQueue( Q ); /* free memory */\n}\n</code></pre> \\[ T=O(|V|+|E|) \\] <p>\\(\u6ce8\u610fE\u7684\u8303\u56f4 \u6700\u5c0f V \u6700\u5927 |V|^2\\)</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK09/","title":"WEEK 9","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK09/#64-shortest-path-algorithms","title":"6.4 Shortest Path Algorithms","text":"<p>Given a digraph \\(G = ( V, E )\\), and a cost function \\(c( e )\\) for \\(e \\in E( G )\\). </p> <p>The length of a path \\(P\\) from source to destination is \\(\\sum_{e_i\\subset P} c(e_i)\\)(also called weighted path length).</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK09/#single-source-shortest-path-problem","title":"Single-Source Shortest-Path Problem","text":"<p>Given as input a weighted graph, \\(G = ( V, E )\\), and a distinguished vertex \\(s\\), find the shortest weighted path from \\(s\\) to every other vertex in \\(G\\).</p> <p>Note: If there is no negative-cost cycle, the shortest path from \\(s\\) to \\(s\\) is defined to be zero.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK09/#unweighted-shortest-path","title":"Unweighted Shortest Path","text":"<ul> <li>Breadth-first search \u5e7f\u5ea6\u4f18\u5148\u904d\u5386</li> </ul> <p>Implementation : </p> <ul> <li>Table[ i ].Dist ::= distance from \\(s\\) to \\(v_i\\)  / initialized to be \\(\\infin\\) except for \\(s\\) /</li> <li>Table[ i ].Known ::= 1 if \\(v_i\\) is checked; or 0 if not</li> <li>Table[ i ].Path ::= for tracking the path   / initialized to be 0 /</li> </ul> <pre><code>void Unweighted( Table T )\n{   \n    int CurrDist;\n    Vertex V, W;\n    for ( CurrDist = 0; CurrDist &lt; NumVertex; CurrDist++ ) \n    {\n        for ( each vertex V )\n            if ( !T[ V ].Known &amp;&amp; T[ V ].Dist == CurrDist ) \n            {\n                T[ V ].Known = true;\n                for ( each W adjacent to V )\n                    if ( T[ W ].Dist == Infinity ) \n                    {\n                        T[ W ].Dist = CurrDist + 1;\n                        T[ W ].Path = V;\n                    } /* end-if Dist == Infinity */\n            } /* end-if !Known &amp;&amp; Dist == CurrDist */\n    }  /* end-for CurrDist */\n}\n</code></pre> <p>The worst case : </p> <p> $$ T(N)=O(|V|^2) $$ Improvement :</p> <pre><code>void Unweighted( Table T )\n{   \n    /* T is initialized with the source vertex S given */\n    Queue Q;\n    Vertex V, W;\n    Q = CreateQueue( NumVertex );\n    MakeEmpty( Q );\n    Enqueue( S, Q ); /* Enqueue the source vertex */\n    while ( !IsEmpty( Q ) ) \n    {\n        V = Dequeue( Q );\n        T[ V ].Known = true; /* not really necessary */\n        for ( each W adjacent to V )\n            if ( T[ W ].Dist == Infinity ) \n            {\n                T[ W ].Dist = T[ V ].Dist + 1;\n                T[ W ].Path = V;\n                Enqueue( W, Q );\n            } /* end-if Dist == Infinity */\n    } /* end-while */\n    DisposeQueue( Q ); /* free memory */\n}\n</code></pre> \\[ T=O(|V|+|E|) \\]"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK09/#weighted-shorted-path","title":"Weighted Shorted Path","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK09/#dijkstras-algorithm","title":"Dijkstra\u2019s Algorithm","text":"<ul> <li>Let S = { \\(s\\) and \\(v_i\\)\u2019s whose shortest paths have been found }</li> <li>For any \\(u\\notin S\\),  define distance [ u ] = minimal length of path { \\(s\\rightarrow(v_i\\in S)\\rightarrow u\\) }.  If the paths are generated in non-decreasing order, then :</li> <li>the shortest path must go through only \\(v_i\\in S\\)</li> <li>Greedy Method : \\(u\\) is chosen so that distance[ u ] = min{ \\(w \\notin S\\) | distance[ w ] }  (If \\(u\\) is not unique, then we may select any of them)</li> <li>if distance[\\(u_1\\)] &lt; distance[\\(u_2\\)] and add \\(u_1\\) into \\(S\\), then distance [ \\(u_2\\) ] may change.  If so, a shorter path from \\(s\\) to \\(u_2\\) must go through \\(u_1\\) and distance [ \\(u_2\\) ] = distance [ \\(u_1\\) ] + length(&lt; \\(u_1\\), \\(u_2\\)&gt;).</li> </ul> <pre><code>typedef int Vertex;\nstruct TableEntry\n{\n    List Header; /*Adjacency list*/\n    int Known;\n    DistType Dist;\n    Vertex Path;\n};\n/*Vertices are numbered from 0*/\n#define NotAVertex (-1)\ntypedef struct TableEntry Table[ NumVertex ];\n</code></pre> <pre><code>void InitTable(Vertex Start, Graph G, Table T)\n{ \n    int i;\n    ReadGraph(G, T); /* Read graph somehow */\n    for(i = 0; i &lt; NumVertex; i++)\n    {\n        T[ i ].Known = False;\n        T[ i ].Dist = Infinity;\n        T[ i ].Path = NotAVertex;\n    }\n    T[ Start ].dist = O;\n}\n</code></pre> <pre><code>/*Print shortest path to V after Dijkstra has run*/\n/*Assume that the path exists*/\nvoid PrintPath(Vertex V, Table T)\n{\n    if (T[ V ].Path != NotAVertex)\n    {\n        PrintPath(T[ V ].Path, T);\n        printf(\" to\") ;\n    }\n    printf(\"%v\", V) ; /* %v is pseudocode * /\n</code></pre> <pre><code>void Dijkstra( Table T )\n{ \n    Vertex V, W;\n    for ( ; ; ) \n    {\n        V = smallest unknown distance vertex;\n        if ( V == NotAVertex ) break; \n        T[ V ].Known = true;\n        for ( each W adjacent to V )\n            if ( !T[ W ].Known ) \n                if ( T[ V ].Dist + Cvw &lt; T[ W ].Dist ) \n                {\n                    Decrease( T[ W ].Dist to T[ V ].Dist + Cvw );\n                    T[ W ].Path = V;\n                } /* end-if update W */\n    } /* end-for( ; ; ) */\n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK09/#implementation-1","title":"Implementation 1","text":"<ul> <li>Simply scan the table to find the smallest unknown distance vertex.\u2014\u2014\\(O(|V|)\\)</li> <li>Good if the graph is dense</li> </ul> \\[ T=O(|V|^2+|E|) \\]"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK09/#implementation-2","title":"Implementation 2","text":"<ul> <li> <p>\u5806\u4f18\u5316</p> </li> <li> <p>Keep distances in a priority queue and call <code>DeleteMin</code> to find the smallest unknown distance vertex.\u2014\u2014\\(O(\\log|V|)\\)</p> </li> <li> <p>\u66f4\u65b0\u7684\u5904\u7406\u65b9\u6cd5</p> </li> <li> <p>Method 1 : <code>DecreaseKey</code>\u2014\u2014\\(O(\\log|V|)\\)</p> <p>\\(T=O(|V|\\log|V|+|E|\\log|V|)=O(|E|\\log|V|)\\)</p> </li> <li> <p>Method 2 : insert W with updated Dist into the priority queue</p> <p>Must keep doing <code>DeleteMin</code> until an unknown vertex emerges</p> <p>\\(T=O(|E|\\log|V|)\\) but requires \\(|E|\\) <code>DeleteMin</code> with <code>|E|</code> space</p> </li> <li> <p>Good if the graph is sparse</p> </li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK09/#improvements","title":"Improvements","text":"<ul> <li>Pairing heap</li> <li>Fibonacci heap</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK09/#graphs-with-negative-edge-costs","title":"Graphs with Negative Edge Costs","text":"<pre><code>void WeightedNegative( Table T )\n{\n    Queue Q;\n    Vertex V, W;\n    Q = CreateQueue (NumVertex );  \n    MakeEmpty( Q );\n    Enqueue( S, Q ); /*Enqueue the source vertex*/\n    while ( !IsEmpty( Q ) ) \n    {\n        V = Dequeue( Q );\n        for ( each W adjacent to V )\n        if ( T[ V ].Dist + Cvw &lt; T[ W ].Dist ) \n        {\n            T[ W ].Dist = T[ V ].Dist + Cvw;\n            T[ W ].Path = V;\n            if ( W is not already in Q )\n                Enqueue( W, Q );\n        } /*end-if update*/\n    } /*end-while */\n    DisposeQueue( Q ); /*free memory*/\n}\n</code></pre> <p>Note : Negative-cost cycle will cause indefinite loop</p> \\[ T=O(|V|\\times|E|) \\]"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK09/#acyclic-graphs","title":"Acyclic Graphs","text":"<ul> <li>If the graph is acyclic, vertices may be selected in topological order since when a vertex is selected, its distance can no longer be lowered without any incoming edges from unknown nodes.</li> <li>\\(T=O(|E|+|V|)\\) and no priority queue is needed.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK09/#aoeactivity-on-edge-networks","title":"AOE(Activity on Edge) Networks","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK09/#all-pairs-shortest-path-problem","title":"All-Pairs Shortest Path Problem","text":"<ul> <li>For all pairs of \\(v_i\\) and \\(v_j\\) ( \\(i\\neq j\\) ), find the shortest path between.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK09/#method-1","title":"Method 1","text":"<ul> <li>Use single-source algorithm for \\(|V|\\) times.</li> <li>\\(T=O(|V|^3)\\), works fast on sparse graph.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK09/#method-2","title":"Method 2","text":"<ul> <li>\u52a8\u6001\u89c4\u5212</li> <li>\\(O(|V|^3)\\) algorithm given in Chapter 10, works faster on dense graphs.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK10/","title":"WEEK 10","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK10/#65-network-flow-problems","title":"6.5 Network Flow Problems","text":"<ul> <li>Determine the maximum amount of flow that can pass from \\(s\\) to \\(t\\).</li> </ul> <p>Note : Total coming in (\\(v\\)) = Total going out (\\(v\\)) where \\(v \\notin \\{ s, t \\}\\)</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK10/#a-simple-algorithm","title":"A Simple Algorithm","text":"<ul> <li>\u6d41\u56fe\\(G_f\\)\u8868\u793a\u7b97\u6cd5\u7684\u4efb\u610f\u9636\u6bb5\u5df2\u7ecf\u8fbe\u5230\u7684\u6d41\uff0c\u5f00\u59cb\u65f6\\(G_f\\)\u7684\u6240\u6709\u8fb9\u90fd\u6ca1\u6709\u6d41\uff0c\u7b97\u6cd5\u7ec8\u6b62\u65f6\\(G_f\\)\u5305\u542b\u6700\u5927\u6d41</li> <li>\u6b8b\u4f59\u56fe(residual graph)\\(G_r\\)\u8868\u793a\u5bf9\u4e8e\u6bcf\u6761\u8fb9\u8fd8\u80fd\u6dfb\u52a0\u4e0a\u591a\u5c11\u6d41\uff0c\\(G_r\\)\u7684\u8fb9\u53eb\u505a\u6b8b\u4f59\u8fb9(residual edge)</li> </ul> <p>Step 1 : Find any path from \\(s\\) to \\(t\\) in \\(G_r\\) , which is called augmenting path(\u589e\u957f\u901a\u8def).</p> <p>Step 2 : Take the minimum edge on this path as the amount of flow and add to \\(G_f\\).</p> <p>Step 3 : Update \\(G_r\\) and remove the 0 flow edges.</p> <p>Step 4 : If there is a path from \\(s\\) to \\(t\\) in \\(G_r\\) then go to Step 1, or end the algorithm.</p> <ul> <li>Step 1\u4e2d\u521d\u59cb\u9009\u62e9\u7684\u8def\u5f84\u53ef\u80fd\u4f7f\u7b97\u6cd5\u4e0d\u80fd\u627e\u5230\u6700\u4f18\u89e3\uff0c\u8d2a\u5fc3\u7b97\u6cd5\u884c\u4e0d\u901a</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK10/#a-solution","title":"A solution","text":"<ul> <li>allow the algorithm to undo its decisions</li> <li>For each edge \\(( v, w )\\) with flow \\(f_{v, w}\\) in \\(G_f\\), add an edge \\(( w, v )\\) with flow \\(f_{v, w}\\) in \\(G_r\\) .</li> </ul> <p>Note : The algorithm works for \\(G\\) with cycles as well.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK10/#proposition-if-the-edge-capabilities-are-rational-numbers-this-algorithm-always-terminate-with-a-maximum-flow","title":"[Proposition] If the edge capabilities are rational numbers, this algorithm always terminate with a maximum flow.","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK10/#analysis","title":"Analysis","text":"<ul> <li> <p>An augmenting path can be found by an unweighted shortest path algorithm.</p> </li> <li> <p>\\(T=O(f|E|)\\) where \\(f\\) is the maximum flow.</p> </li> <li> <p>Always choose the augmenting path that allows the largest increase in flow</p> </li> <li> <p>\u5bf9Dijkstra\u7b97\u6cd5\u8fdb\u884c\u5355\u7ebf(single-line)\u4fee\u6539\u6765\u5bfb\u627e\u589e\u957f\u901a\u8def</p> </li> <li>\\(cap_{max}\\)\u4e3a\u6700\u5927\u8fb9\u5bb9\u91cf</li> <li>\\(O(|E|\\log cap_{max})\\)\u6761\u589e\u957f\u901a\u8def\u5c06\u8db3\u4ee5\u627e\u5230\u6700\u5927\u6d41\uff0c\u5bf9\u4e8e\u589e\u957f\u901a\u8def\u7684\u6bcf\u6b21\u8ba1\u7b97\u9700\u8981\\(O(|E|\\log|V|)\\)\u65f6\u95f4</li> </ul> <p>$$   T=T_{augmentation}\\times T_{find_a_path}\\   =O(|E|\\log cap_{max})\\times O(|E|\\log|V|)\\   =O(|E|^2\\log|V|\\log cap_{max})   $$</p> <ul> <li> <p>Always choose the augmenting path that has the least number of edges</p> </li> <li> <p>\u4f7f\u7528\u65e0\u6743\u6700\u77ed\u8def\u7b97\u6cd5\u6765\u5bfb\u627e\u589e\u957f\u8def\u5f84</p> </li> </ul> <p>$$   T=T_{augmentation}\\times T_{find_a_path}\\   =O(|E||V|)\\times O(|E|)\\   =O(|E|^2|V|)   $$</p> <p>Note : </p> <ul> <li>If every \\(v \\notin \\{ s, t \\}\\) has either a single incoming edge of capacity 1 or a single outgoing edge of capacity 1, then time bound is reduced to \\(O( |E| |V|^{1/2} )\\).</li> <li>The min-cost flow problem is to find, among all maximum flows, the one flow of minimum cost provided that each edge has a cost per unit of flow.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK10/#66-minimum-spanning-tree","title":"6.6 Minimum Spanning Tree","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK10/#definition-a-spanning-tree-of-a-graph-g-is-a-tree-which-consists-of-vg-and-a-subset-of-eg","title":"[Definition] A spanning tree of a graph \\(G\\) is a tree which consists of \\(V(G)\\) and a subset of \\(E(G)\\)","text":"<p>Note :</p> <ul> <li>The minimum spanning tree is a tree since it is acyclic, the number of edges is \\(|V|-1\\)</li> <li>It is minimum for the total cost of edges is minimized.</li> <li>It is spanning because it covers every vertex.</li> <li>A minimum spanning tree exists if \\(G\\) is connected.</li> <li>Adding a non-tree edge to a spanning tree, we obtain a cycle.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK10/#greedy-method","title":"Greedy Method","text":"<p>Make the best decision for each stage, under the following constrains :</p> <ul> <li>we must use only edges within the graph</li> <li>we must use exactly \\(|V|-1\\) edges</li> <li>we may not use edges that would produce a cycle</li> </ul> <ol> <li> <p>Prim\u2019s Algorithm</p> </li> <li> <p>\u5728\u7b97\u6cd5\u7684\u4efb\u4e00\u65f6\u523b\uff0c\u90fd\u53ef\u4ee5\u770b\u5230\u4e00\u4e2a\u5df2\u7ecf\u6dfb\u52a0\u5230\u6811\u4e0a\u7684\u9876\u70b9\u96c6\uff0c\u800c\u5176\u4f59\u9876\u70b9\u5c1a\u672a\u52a0\u5230\u8fd9\u68f5\u6811\u4e2d</p> </li> <li> <p>\u7b97\u6cd5\u5728\u6bcf\u4e00\u9636\u6bb5\u90fd\u53ef\u4ee5\u901a\u8fc7\u9009\u62e9\u8fb9\\((u, v)\\)\uff0c\u4f7f\u5f97\\((u,v)\\)\u7684\u503c\u662f\u6240\u6709\\(u\\) \u5728\u6811\u4e0a\u4f46\\(v\\)\u4e0d\u5728\u6811\u4e0a\u7684\u8fb9\u7684\u503c\u4e2d\u7684\u6700\u5c0f\u8005\uff0c\u800c\u627e\u51fa\u4e00\u4e2a\u65b0\u7684\u9876\u70b9\u5e76\u628a\u5b83\u6dfb\u52a0\u5230\u8fd9\u68f5\u6811\u4e2d</p> </li> <li> <p>Kruskal\u2019s Algorithm</p> </li> <li> <p>\u8fde\u7eed\u5730\u6309\u7167\u6700\u5c0f\u7684\u6743\u9009\u62e9\u8fb9,\uff0c\u5e76\u4e14\u5f53\u6240\u9009\u7684\u8fb9\u4e0d\u4ea7\u751f\u73af\u65f6\u5c31\u628a\u5b83\u4f5c\u4e3a\u53d6\u5b9a\u7684\u8fb9</p> <p><code>pseudocode  void Kruskal( Graph G )  {        T = { };      while ( T contains less than |V|-1 edges &amp;&amp; E is not empty )       {          choose a least cost edge (v, w) from E;  /*DeleteMin*/          delete (v, w) from E;          if ( (v, w) does not create a cycle in T )                  add (v, w) to T;  /*Union/Find*/          else                  discard (v, w);      }      if ( T contains fewer than |V|-1 edges )         Error( \u201cNo spanning tree\u201d );  }</code></p> <p>```c  void Kruskal(Graph G)  {     int EdgesAccepted;     DisjSet S;     PriorityQueue H;     Vertex U, V;     SetType Uset, Vset;     Edge E;</p> <pre><code>Initialize(S);\nReadGraphIntoHeapArray(G, H);\nBuildHeap(H);\n\nEdgesAccepted = 0;\nwhile(EdgesAccepted &lt; NumVertex-1)\n{\n    E = DeleteMin(H); /*E = (U,V)*/\n    Uset = Find(U, S);\n    Vset = Find(V, S);\n    if(Uset != Vset)\n    {\n        /*Accept the edge*/\n        EdgesAccepted++;\n        SetUnion(S, USet, VSet);\n    }\n}\n</code></pre> <p>}  ```</p> <p>$$  T=O(|E|\\log|E|)  $$</p> <p></p> </li> </ol>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK11/","title":"WEEK 11","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK11/#67-applications-of-depth-first-search","title":"6.7 Applications of Depth-First Search","text":"<pre><code>/*a generalization of preorder traversal*/\nvoid DFS(Vertex V)\n{   \n    visited[ V ] = true;  /*mark this vertex to avoid cycles*/\n    for ( each W adjacent to V )\n        if ( !visited[ W ] ) DFS( W );\n} /*T = O(|E|+|V|) as long as adjacency lists are used*/\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK11/#undirected-graphs","title":"Undirected Graphs","text":"<pre><code>void ListComponents(Graph G)\n{   \n    for ( each V in G ) \n        if ( !visited[ V ] ) \n        {\n            DFS( V );\n            printf(\"\\n\");\n        }\n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK11/#biconnectivity","title":"Biconnectivity","text":"<ul> <li>\\(v\\) is an articulation point if \\(G'=DeleteVertex(G, v)\\) has at least 2 connected components.</li> <li>\\(G\\) is a biconnected graph if \\(G\\) is connected and has no articulation points.</li> <li>A biconnected component is a maximal biconnected subgraph.</li> </ul> <p>Note : No edges can be shared by two or more biconnected components.  Hence \\(E(G)\\) is partitioned by the biconnected components of \\(G\\).</p> <p>Finding the biconnected components of a connected undirected \\(G\\) :</p> <ul> <li>Use depth first search to obtain a spanning tree of \\(G\\)</li> </ul> <p></p> <p></p> <ul> <li>Depth first number(\\(Num\\)) \u5148\u5e8f\u7f16\u53f7</li> <li>Back edges(\u80cc\u5411\u8fb9) = \\((u,v)\\notin\\) tree and \\(u\\) is an ancestor of \\(v\\).</li> </ul> <p>Note : If \\(u\\) is an ancestor of \\(v\\), then \\(Num(u)&lt;Num(v)\\).</p> <ul> <li>Find the articulation points in \\(G\\)</li> <li>The root is an articulation point if it has at least 2 children.</li> <li>Any other vertex \\(u\\) is an articulation point if \\(u\\) has at least 1 child, and it is impossible to move down at least 1 step and then jump up to \\(u\\)\u2018s ancestor</li> </ul> <ul> <li>\u5bf9\u4e8e\u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u751f\u6210\u6811\u4e0a\u7684\u6bcf\u4e00\u4e2a\u9876\u70b9\\(u\\)\uff0c\u8ba1\u7b97\u7f16\u53f7\u6700\u4f4e\u7684\u9876\u70b9\uff0c\u79f0\u4e4b\u4e3a\\(Low(u)\\)   $$   Low(u)=\\min{Num(u),\\min{Low(w)|w\\,is\\,a\\,child\\,of\\,u},\\min{Num(w)|(u,w)\\,is\\,a\\,back\\,edge}}   $$</li> </ul> <pre><code>/*Assign Num and compute Parents*/\nvoid AssignNum(Vertex V)\n{\n    Vertex W;\n    Num[V] = Counter++;\n    Visited[V] = True;\n    for each W adjacent to V\n        if(!Visited[W])\n        {\n            Parent[W] = V;\n            AssignNum(W);\n        }\n}\n</code></pre> <pre><code>/*Assign Low; also check for articulation points*/\nvoid AssignLow(Vertex V)\n{\n    Vertex W;\n    Low[V] = Num[V]; /*Rule 1*/\n    for each W adjacent to V\n    {\n        if(Num[W] &gt; Num[V]) /*Forward edge*/\n        {\n            Assignlow(W);\n            if(Low[W] &gt;= Num[V])\n                printf(\"%v is an articulation point\\n\", v);\n            Low[V] = Min(Low[V], Low[W]); /*Rule 3*/\n        }\n        else\n            if (Parent[V] != W) /*Back edge*/\n                Low[V] \uff1d Min(Low[V], Num[W]); /*Rule 2*/\n    }\n}\n</code></pre> <pre><code>void FindArt(Vertex V)\n{\n    Vertex W;\n    Visited[V] = True;\n    Low[V] = Num[V] = Counter++; /*Rule 1*/\n    for each W adjacent to V\n    {\n        if(!Visited[W]) /*Forward edge*/\n        {\n            Parent[W] = V;\n            FindArt(W);\n            if(Low[W] &gt;= Num[V])\n                printf(\"%v is an articulation point\\n\", v);\n            Low[V] = Min(Low[V], Low[W]); /*Rule 3*/\n        }\n        else\n            if(Parent[ V ] != W) /*Back edge*/\n                Low[V] = Min(Low[V], Num[W]); /*Rule 2*/\n    }\n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK11/#euler-circuits","title":"Euler Circuits","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK11/#proposition-an-euler-circuit-is-possible-only-if-the-graph-is-connected-and-each-vertex-has-an-even-degree","title":"[Proposition] An Euler circuit is possible only if the graph is connected and each vertex has an even degree.","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK11/#proposition-an-euler-tour-is-possible-if-there-are-exactly-two-vertices-having-odd-degree-one-must-start-at-one-of-the-odd-degree-vertices","title":"[Proposition] An Euler tour is possible if there are exactly two vertices having odd degree.  One must start at one of the odd-degree vertices.","text":"<p>Note:</p> <ul> <li>The path should be maintained as a linked list.</li> <li>For each adjacency list, maintain a pointer to the last edge scanned.</li> <li>\\(T=O(|E|+|V|)\\)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK11/#7-sorting","title":"7 Sorting","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK11/#71-preliminaries","title":"7.1 Preliminaries","text":"<pre><code>void X_Sort (ElementType A[], int N)\n</code></pre> <ul> <li>N must be a legal integer.</li> <li>Assume integer array for the sake of simplicity.</li> <li>\u2018&gt;\u2019 and \u2018&lt;\u2019 operators exist and are the only operations allowed on the input data.</li> <li>Consider internal sorting only. The entire sort can be done in main memory.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK11/#72-insertion-sort","title":"7.2 Insertion Sort","text":"<pre><code>void Insertion(ElementType A[], int N)\n{ \n    int j, P; \n    ElementType Tmp; \n\n    for ( P = 1; P &lt; N; P++ ) \n    { \n        Tmp = A[ P ];  /*the next coming card*/\n        for ( j = P; j &gt; 0 &amp;&amp; A[ j - 1 ] &gt; Tmp; j-- ) \n            A[ j ] = A[ j - 1 ]; \n            /*shift sorted cards to provide a position for the new coming card*/\n        A[ j ] = Tmp;  /*place the new card at the proper position*/\n    }/*end for-P-loop*/\n}\n</code></pre> <ul> <li> <p>The worst case : Input A[ ] is in reverse order   $$   T(N)=O(N^2)   $$</p> </li> <li> <p>The best case : Input A[ ] is in sorted order   $$   T(N)=O(N)   $$</p> </li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK11/#73-a-lower-bound-for-simple-sorting-algorithms","title":"7.3 A Lower Bound for Simple Sorting Algorithms","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK11/#definition-an-inversion-in-an-array-of-numbers-is-any-ordered-pairij-having-the-property-that-ij-but-aiaj","title":"[Definition] An inversion in an array of numbers is any ordered pair\\((i,j)\\) having the property that \\(i&lt;j\\) but \\(A[i]&gt;A[j]\\)","text":"<ul> <li> <p>Swapping two adjacent elements that are out of place removes exactly one inversion.</p> </li> <li> <p>\\(T(N,I)=O(I+N)\\) where \\(I\\) is the number of inversions in the original array.</p> </li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK11/#theorem-the-average-number-of-inversions-in-an-array-of-n-distinct-numbers-is-nn-14","title":"[Theorem] The average number of inversions in an array of \\(N\\) distinct numbers is \\(N(N-1)/4\\)","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK11/#theorem-any-algorithm-that-sorts-by-exchanging-adjacent-elements-requires-omegan2-time-on-average","title":"[Theorem] Any algorithm that sorts by exchanging adjacent elements requires \\(\\Omega(N^2)\\) time on average","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK12/","title":"WEEK 12","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK12/#74-shellsort","title":"7.4 Shellsort","text":"<ul> <li>Define an increment sequence \\(h_1 &lt; h_2 &lt; \\cdots &lt; h_t  ( h_1 = 1 )\\)</li> <li> <p>Define an \\(h_k\\)-sort at each phase for \\(k = t, t - 1,\\cdots, 1\\)</p> </li> <li> <p>\u6700\u540e\u4e00\u8f6e\u5c31\u662fInsertion Sort</p> </li> </ul> <p>Note : An \\(h_k\\)-sorted file that is then \\(h_{k-1}\\)-sorted remains \\(h_k\\)-sorted.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK12/#shells-increment-sequence","title":"Shell\u2019s Increment Sequence","text":"\\[ h_t=\\lfloor N/2\\rfloor,h_k=\\lfloor h_{k+1}/2\\rfloor \\] <pre><code>void Shellsort( ElementType A[ ], int N ) \n{ \n    int i, j, Increment; \n    ElementType Tmp; \n    for ( Increment = N / 2; Increment &gt; 0; Increment /= 2 )  /*h sequence */\n        for ( i = Increment; i &lt; N; i++ ) \n        { /* insertion sort */\n            Tmp = A[ i ]; \n            for ( j = i; j &gt;= Increment; j -= Increment ) \n                if( Tmp &lt; A[ j-Increment ] )\n                    A[ j ] = A[ j-Increment ]; \n                else \n                    break; \n            A[ j ] = Tmp;\n        } /* end for-I and for-Increment loops */\n}\n</code></pre> <ul> <li>[Theorem] The worst-case running time of Shellsort, using Shell\u2019s increments, is  \\(\\Theta( N^2 )\\).</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK12/#hibbards-increment-sequence","title":"Hibbard's Increment Sequence","text":"\\[ h_k=2^k-1 \\] <ul> <li>[Theorem] The worst-case running time of Shellsort, using Hibbard's increments, is  \\(\\Theta( N^{3/2} )\\).</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK12/#conjecture","title":"Conjecture","text":"<ul> <li>\\(T_{avg \u2013 Hibbard} ( N ) = O ( N^{5/4} )\\)</li> <li>Sedgewick\u2019s best sequence is \\(\\{1, 5, 19, 41, 109, \\cdots \\}\\) in which the terms are either of the form \\(9\\times4^i \u2013 9\\times2^i + 1\\) or    \\(4^i \u2013 3\\times2^i + 1\\).  \\(T_{avg} ( N ) = O ( N^{7/6} )\\) and \\(T_{worst}( N ) = O( N^{4/3} )\\).</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK12/#conclusion","title":"Conclusion","text":"<ul> <li>Shellsort is a very simple algorithm, yet with an extremely complex analysis.  </li> <li>It is good for sorting up to moderately large input (tens of thousands).</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK12/#75-heapsort","title":"7.5 Heapsort","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK12/#algorithm1","title":"Algorithm1","text":"<pre><code>void Heapsort( int N ) \n{\n    BuildHeap( H );\n    for ( i = 0; i &lt; N; i++ ) \n        TmpH[ i ] = DeleteMin( H );\n    for ( i = 0; i &lt; N; i++ ) \n        H[ i ] = TmpH[ i ];\n}\n</code></pre> \\[ T(N)=O(N\\log N) \\] <ul> <li>The space requirement is doubled.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK12/#algorithm2","title":"Algorithm2","text":"<pre><code>void Heapsort( ElementType A[ ], int N ) \n{\n    int i; \n    for ( i = N / 2; i &gt;= 0; i-- ) /*BuildHeap*/ \n        PercDown( A, i, N );\n    for ( i = N - 1; i &gt; 0; i-- ) \n    { \n        Swap( &amp;A[ 0 ], &amp;A[ i ] ); /*DeleteMax*/ \n        PercDown( A, 0, i ); \n    } \n}\n</code></pre> <ul> <li>[Theorem] The average number of comparisons used to heapsort a random permutation of N distinct items is \\(2N\\log N-O(N\\log\\log N)\\).</li> </ul> <p>Note : Although Heapsort gives the best average time, in practice it is slower than a version of Shellsort that uses Sedgewick\u2019s increment sequence.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK12/#76-mergesort","title":"7.6 Mergesort","text":"<pre><code>void MSort( ElementType A[ ], ElementType TmpArray[ ], int Left, int Right ) \n{   \n    int Center; \n    if ( Left &lt; Right ) \n    {  /*if there are elements to be sort*/\n        Center = (Left+Right)/2; \n        MSort(A, TmpArray, Left, Center);   /*T(N/2)*/\n        MSort(A, TmpArray, Center+1, Right);    /*T(N/2)*/\n        Merge(A, TmpArray, Left, Center+1, Right);  /*O(N)*/\n    } \n} \n\nvoid Mergesort( ElementType A[ ], int N ) \n{   \n    ElementType *TmpArray;  /*need O(N) extra space*/\n    TmpArray = malloc(N*sizeof(ElementType)); \n    if (TmpArray != NULL) \n    { \n        MSort(A, TmpArray, 0, N-1); \n        free(TmpArray); \n    } \n    else FatalError(\"No space for tmp array!!!\"); \n}\n</code></pre> <ul> <li>If a TmpArray is declared locally for each call of Merge, then \\(S(N) = O(N\\log N)\\).</li> </ul> <pre><code>/*Lpos = start of left half, Rpos = start of right half*/ \nvoid Merge( ElementType A[ ], ElementType TmpArray[ ], int Lpos, int Rpos, int RightEnd ) \n{   \n    int i, LeftEnd, NumElements, TmpPos; \n    LeftEnd = Rpos-1; \n    TmpPos = Lpos; \n    NumElements = RightEnd-Lpos+1; \n    while( Lpos &lt;= LeftEnd &amp;&amp; Rpos &lt;= RightEnd ) /*main loop*/ \n        if ( A[ Lpos ] &lt;= A[ Rpos ] ) \n            TmpArray[ TmpPos++ ] = A[ Lpos++ ]; \n        else \n            TmpArray[ TmpPos++ ] = A[ Rpos++ ]; \n    while( Lpos &lt;= LeftEnd ) /*Copy rest of first half*/ \n        TmpArray[ TmpPos++ ] = A[ Lpos++ ]; \n    while( Rpos &lt;= RightEnd ) /*Copy rest of second half*/ \n        TmpArray[ TmpPos++ ] = A[ Rpos++ ]; \n    for( i = 0; i &lt; NumElements; i++, RightEnd-- ) \n        /*Copy TmpArray back*/ \n        A[ RightEnd ] = TmpArray[ RightEnd ]; \n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK12/#analysis","title":"Analysis","text":"\\[ T(1)=O(1)\\\\ T(N)=2T(\\frac{N}{2})+O(N)\\\\ \\frac{T(N)}{N}=\\frac{T(\\frac{N}{2})}{\\frac{N}{2}}+1\\\\ \\cdots\\\\ \\frac{T(\\frac{N}{2^{k-1}})}{\\frac{N}{2^{k-1}}}=\\frac{T(1)}{1}+1\\\\ T(N)=O(N+N\\log N) \\] <p>Note : Mergesort requires linear extra memory, and copying an array is slow. It is hardly ever used for internal sorting, but is quite useful for external sorting.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK13/","title":"WEEK 13","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK13/#77-quicksort","title":"7.7 Quicksort","text":"<ul> <li>the fastest known sorting algorithm in practice</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK13/#algorithm","title":"Algorithm","text":"<pre><code>void Quicksort( ElementType A[ ], int N )\n{\n    if (N &lt; 2) return;\n    pivot = pick any element in A[ ]; \n    Partition S = { A[ ] \\ pivot } into two disjoint sets:\n        A1 = { a in S | a &lt;= pivot } and A2 = { a in S | a &gt;= pivot };\n    A = Quicksort(A1, N1) and { pivot } and Quicksort(A2, N2);\n}\n</code></pre> <ul> <li>The pivot is placed at the right place once and for all.</li> <li>\u8981\u7814\u7a76\u7684\u95ee\u9898\u662f\u5982\u4f55\u9009\u53d6\u67a2\u7ebd\u5143\u548c\u5982\u4f55\u5212\u5206</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK13/#picking-the-pivot","title":"Picking the Pivot","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK13/#a-wrong-way","title":"A Wrong Way","text":"<ul> <li>Pivot = A[ 0 ]</li> <li>The worst case : A[ ] is presorted, quicksort will take \\(O(N^2)\\) time to do nothing</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK13/#a-safe-maneuver","title":"A Safe Maneuver","text":"<ul> <li>Pivot = random select from A[ ]</li> <li>random number generation is expensive</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK13/#median-of-three-partitioning","title":"Median-of-Three Partitioning","text":"<ul> <li>Pivot = median(left, center, right)</li> <li>Eliminates the bad case for sorted input and actually reduces the running time by about 5%.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK13/#partitioning-strategy","title":"Partitioning Strategy","text":"<ul> <li>\u5f53\\(i\\)\u5728\\(j\\)\u7684\u5de6\u8fb9\u65f6\uff0c\u6211\u4eec\u5c06\\(i\\)\u53f3\u79fb\uff0c\u79fb\u8fc7\u90a3\u4e9b\u5c0f\u4e8e\u67a2\u7ebd\u5143\u7684\u5143\u7d20\uff0c\u5e76\u5c06\\(j\\)\u5de6\u79fb\uff0c\u79fb\u8fc7\u90a3\u4e9b\u5927\u4e8e\u67a2\u7ebd\u5143\u7684\u5143\u7d20</li> <li>\u5f53\\(i\\)\u548c\\(j\\)\u505c\u6b62\u65f6\uff0c\\(i\\)\u6307\u5411\u4e00\u4e2a\u5927\u5143\u7d20\u800c\\(j\\)\u6307\u5411\u4e00\u4e2a\u5c0f\u5143\u7d20\uff0c\u5982\u679c\\(i\\)\u5728\\(j\\)\u7684\u5de6\u8fb9\uff0c\u90a3\u4e48\u5c06\u8fd9\u4e24\u4e2a\u5143\u7d20\u4e92\u6362</li> <li>\u91cd\u590d\u8be5\u8fc7\u7a0b\u76f4\u5230\\(i\\)\u548c\\(j\\)\u5f7c\u6b64\u4ea4\u9519\u4e3a\u6b62</li> <li>\u5212\u5206\u7684\u6700\u540e\u4e00\u6b65\u662f\u5c06\u67a2\u7ebd\u5143\u4e0e\\(i\\)\u6240\u6307\u5411\u7684\u5143\u7d20\u4ea4\u6362</li> <li>\u5982\u679c\\(i\\)\u548c\\(j\\)\u9047\u5230\u7b49\u4e8e\u67a2\u7ebd\u5143\u7684\u952e\u503c\uff0c\u5c31\u8ba9\\(i\\)\u548c\\(j\\)\u90fd\u505c\u6b62\uff0c\u56e0\u4e3a\u82e5\u90fd\u4e0d\u505c\u6b62\\(T(N)=O(N^2)\\)</li> <li>There will be many dummy swaps, but at least the sequence will be partitioned into two equal-sized subsequences.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK13/#small-arrays","title":"Small Arrays","text":"<ul> <li>Quicksort is slower than insertion sort for small \\(N(\\leq 20)\\).</li> <li>Cutoff when \\(N\\) gets small and use other efficient algorithms (such as insertion sort).</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK13/#implementation","title":"Implementation","text":"<pre><code>void Quicksort( ElementType A[ ], int N ) \n{ \n    Qsort( A, 0, N-1 ); \n    /*A:the array*/\n    /*0:Left index*/\n    /*N\u20131:Right index*/\n}\n</code></pre> <pre><code>/* Return median of Left, Center, and Right */ \n/* Order these and hide the pivot */ \nElementType Median3( ElementType A[ ], int Left, int Right ) \n{\n    int Center = ( Left+Right )/2; \n    if ( A[ Left ] &gt; A[ Center ] ) \n        Swap( &amp;A[ Left ], &amp;A[ Center ] ); \n    if ( A[ Left ] &gt; A[ Right ] ) \n        Swap( &amp;A[ Left ], &amp;A[ Right ] ); \n    if ( A[ Center ] &gt; A[ Right ] ) \n        Swap( &amp;A[ Center ], &amp;A[ Right ] ); \n    /*Invariant: A[ Left ] &lt;= A[ Center ] &lt;= A[ Right ]*/ \n    Swap( &amp;A[ Center ], &amp;A[ Right-1 ] ); /*Hide pivot*/ \n    /*only need to sort A[ Left+1 ] \u2026 A[ Right\u20132 ]*/\n    return A[ Right-1 ];  /*Return pivot*/ \n}\n</code></pre> <pre><code>void Qsort( ElementType A[ ], int Left, int Right ) \n{\n    int i, j; \n    ElementType Pivot; \n    if ( Left + Cutoff &lt;= Right ) \n    {   /*if the sequence is not too short*/\n        Pivot = Median3( A, Left, Right );  /*select pivot*/\n        i = Left;     \n        j = Right \u2013 1;  /*why not set Left+1 and Right-2?*/\n        for( ; ; ) \n        { \n            while ( A[ ++i ] &lt; Pivot ) { }  /*scan from left*/\n            while ( A[ --j ] &gt; Pivot ) { }  /*scan from right*/\n            if ( i &lt; j ) \n                Swap( &amp;A[ i ], &amp;A[ j ] );  /*adjust partition*/\n            else break;  /*partition done*/\n        } \n        Swap( &amp;A[ i ], &amp;A[ Right-1 ] ); /*restore pivot */ \n        Qsort( A, Left, i-1 );    /*recursively sort left part*/\n        Qsort( A, i+1, Right );   /*recursively sort right part*/\n    }  /*end if - the sequence is long*/\n    else /*do an insertion sort on the short subarray*/ \n        InsertionSort( A+Left, Right-Left+1 );\n}\n</code></pre> <p>Note : If set i = Left+1 and j = Right-2, there will be an infinite loop if A[i] = A[j] = pivot.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK13/#analysis","title":"Analysis","text":"\\[ T(N)=T(i)+T(N-i-1)+cN \\] <ul> <li> <p>\\(i\\) is the number of the elements in \\(S_1\\).</p> </li> <li> <p>The Worst Case   $$   T(N)=T(N-1)+cN   $$</p> </li> </ul> <p>$$   T(N-1)=T(N-2)+c(N-1)   $$</p> <p>$$   \\cdots   $$</p> <p>$$   T(2)=T(1)+2c   $$</p> <p>$$   T(N)=T(1)+c\\sum^N_{i=2}i=O(N^2)   $$</p> <ul> <li>The Best Case   $$   T(N)=2T(N/2)+cN   $$</li> </ul> <p>$$   \\frac{T(N)}{N}=\\frac{T(N/2)}{N/2}+c   $$</p> <p>$$   \\frac{T(N/2)}{N/2}=\\frac{T(N/4)}{N/4}+c   $$</p> <p>$$   \\cdots   $$</p> <p>$$   \\frac{T(2)}{2}=\\frac{T(1)}{1}+c   $$</p> <p>$$   \\frac{T(N)}{N}=\\frac{T(1)}{1}+c\\log N\\frac{T(N)}{N}=\\frac{T(1)}{1}+c\\log N   $$</p> <p>$$   T(N)=cN\\log N+N=O(N\\log N)   $$</p> <ul> <li> <p>The Average Case</p> </li> <li> <p>Assume the average value of \\(T( i )\\) for any \\(i\\) is \\(\\frac{1}{N}\\left[\\sum^{N-1}_{j=0}T(j)\\right]\\)     $$     T(N)=\\frac{2}{N}\\left[\\sum^{N-1}_{j=0}T(j)\\right]+cN     $$</p> </li> </ul> <p>$$   NT(N)=2\\left[\\sum^{N-1}_{j=0}T(j)\\right]+cN^2   $$</p> <p>$$   (N-1)T(N-1)=2\\left[\\sum^{N-2}_{j=0}T(j)\\right]+c(N-1)^2   $$</p> <p>$$   NT(N)-(N-1)T(N-1)=2T(N-1)+2cN-c   $$</p> <p>$$   NT(N)=(N+1)T(N-1)+2cN   $$</p> <p>$$   \\frac{T(N)}{N+1}=\\frac{T(N-1)}{N}+\\frac{2c}{N+1}   $$</p> <p>$$   \\frac{T(N-1)}{N}=\\frac{T(N-2)}{N-1}+\\frac{2c}{N}   $$</p> <p>$$   \\cdots   $$</p> <p>$$   \\frac{T(2)}{3}=\\frac{T(1)}{2}+\\frac{2c}{3}   $$</p> <p>$$   \\frac{T(N)}{N+1}=\\frac{T(1)}{2}+2c\\sum^{N+1}_{i=3}\\frac{1}{i}   $$</p> <p>$$   T(N)=O(N\\log N)   $$</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK13/#quickselect","title":"Quickselect","text":"<ul> <li>\u67e5\u627e\u7b2c\\(K\\)\u6700\u5927(\u6700\u5c0f)\u5143</li> </ul> <pre><code>/*Places the kth sma11est element in the kth position*/\n/*Because arrays start at 0, this will be index k-1*/\nvoid Qselect(ElementType A[ ], int k, int Left, int Right)\n{\n    int i, j;\n    ElementType Pivot;\n\n    if (Left + Cutoff &lt;= Right)\n    {\n        Pivot = Median3(A, Left, Right);\n        i = Left; \n        j = Right-1;\n        for( ; ; )\n        {\n            while(A[ ++i ] &lt; Pivot){ }\n            while(A[ --j ] &gt; Pivot){ }\n            if(i &lt; j)\n                Swap(&amp;A[ i ], &amp;A[ j ]);\n            else\n                break;\n        }\n        Swap(&amp;A[ i ], &amp;A[ Right-1 ]); /*Restore pivot*/\n\n        if(k &lt;= i)\n            Qselect(A, k, Left, i-1);\n        else if (k &gt; i+1)\n            Qselect(A, k, i+1, Right);\n    }\n    else /*Doan insertion sort on the subarray*/\n        InsertionSort(A+Left, Right-Left+1);\n}\n</code></pre> <p>\u6b63\u786e\u7b54\u6848\u662fD</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK13/#78-sorting-large-structures","title":"7.8 Sorting Large Structures","text":"<ul> <li>Swapping large structures can be very much expensive.</li> <li>Add a pointer field to the structure and swap pointers instead \u2013 indirect sorting. Physically rearrange the structures at last if it is really necessary.</li> <li>Table Sort</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK13/#79-a-general-lower-bound-for-sorting","title":"7.9 A General Lower Bound for Sorting","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK13/#theorem-any-algorithm-that-sorts-by-comparisons-only-must-have-a-worst-case-computing-time-of-omeganlog-n","title":"[Theorem] Any algorithm that sorts by comparisons only must have a worst case computing time of \\(\\Omega(N\\log N)\\).","text":"<ul> <li>When sorting \\(N\\) distinct elements, there are \\(N!\\) different possible results.</li> <li>Thus any decision tree must have at least \\(N!\\) leaves.</li> <li>If the height of the tree is \\(k\\), then \\(N! \\leq 2^{k-1}\\rarr k\\geq\\log(N!)+1\\) </li> <li>Since \\(N!\\geq (N/2)^{N/2}\\) and \\(\\log_2N!\\geq(N/2)\\log_2(N/2) = \\Theta(N\\log_2N )\\)</li> <li>Therefore \\(T(N)=k\\geq c\\cdot N\\log_2 N\\)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK13/#710-bucket-sort","title":"7.10 Bucket Sort","text":"<pre><code>Algorithm\n{\n    initialize count[ ];\n    while(read in a student\u2019s record)\n        insert to list count[stdnt.grade];\n    for(int i = 0; i &lt; M; i++) \n    {\n        if(count[i]) output list count[i];\n    }\n}\n</code></pre> \\[ T(N,M)=O(M+N) \\]"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK13/#711-radix-sort","title":"7.11 Radix Sort","text":"<ul> <li>\\(T=O(P(N+B))\\) where \\(P\\) is the number of passes, \\(N\\) is the number of elements to sort, and \\(B\\) is the number of buckets.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK13/#msdmost-significant-digit-sort-and-lsdleast-significant-digit-sort","title":"MSD(Most Significant Digit) Sort and LSD(Least Significant Digit) Sort","text":"<ul> <li>\u7a33\u5b9a\u7684\u6392\u5e8f\u7b97\u6cd5\uff1a\u5192\u6ce1\u6392\u5e8f\u3001\u63d2\u5165\u6392\u5e8f\u3001\u5f52\u5e76\u6392\u5e8f\u3001\u57fa\u6570\u6392\u5e8f</li> <li>\u4e0d\u7a33\u5b9a\u7684\u6392\u5e8f\u7b97\u6cd5\uff1a\u9009\u62e9\u6392\u5e8f\u3001\u5feb\u901f\u6392\u5e8f\u3001\u5e0c\u5c14\u6392\u5e8f\u3001\u5806\u6392\u5e8f</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK14/","title":"WEEK 14","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK14/#8-hashing","title":"8 Hashing","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK14/#81-general-idea","title":"8.1 General Idea","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK14/#symbol-table-adt","title":"Symbol Table ADT","text":"<ul> <li>Objects : A set of name-attribute pairs, where the names are unique</li> <li>Operations :</li> <li>SymTab Create(TableSize) </li> <li>Boolean IsIn(symtab, name)</li> <li>Attribute  Find(symtab, name) </li> <li>SymTab  Insert(symtab, name, attr)</li> <li>SymTab  Delete(symtab, name) </li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK14/#hash-tables","title":"Hash Tables","text":"<ul> <li>A collision occurs when we hash two nonidentical identifiers into the same bucket.</li> <li>An overflow occurs when we hash a new identifier into a full bucket.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK14/#82-hash-function","title":"8.2 Hash Function","text":"<ul> <li>\\(f(x)\\) must be easy to compute and minimize the number of collisions.</li> <li>\\(f(x)\\) should be unbiased. For any \\(x\\) and any \\(i\\), we have that \\(Probability(f(x)=i)=\\frac{1}{b}\\). Such kind of a hash function is called a uniform hash function.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK14/#83-separate-chaining","title":"8.3 Separate Chaining","text":"<ul> <li>keep a list of all keys that hash to the same value</li> </ul> <pre><code>struct ListNode; \ntypedef struct ListNode *Position; \nstruct HashTbl; \ntypedef struct HashTbl *HashTable; \nstruct ListNode { \n    ElementType Element; \n    Position Next; \n}; \ntypedef Position List; \n/* List *TheList will be an array of lists, allocated later */ \n/* The lists use headers (for simplicity), */ \n/* though this wastes space */ \nstruct HashTbl { \n    int TableSize; \n    List *TheLists; \n}; \n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK14/#create-an-empty-table","title":"Create an empty table","text":"<pre><code>HashTable InitializeTable( int TableSize ) \n{   \n    HashTable H; \n    int i; \n    if ( TableSize &lt; MinTableSize ) \n    { \n        Error( \"Table size too small\" );  \n        return NULL;  \n    } \n    H = malloc( sizeof( struct HashTbl ) );  /*Allocate table*/\n    if ( H == NULL ) FatalError( \"Out of space!!!\" ); \n    H-&gt;TableSize = NextPrime( TableSize );  /*Better be prime*/\n    H-&gt;TheLists = malloc( sizeof( List )* H-&gt;TableSize );  /*Array of lists*/\n    if ( H-&gt;TheLists == NULL ) FatalError( \"Out of space!!!\" );\n    H-&gt;TheList = malloc(H-&gt;TableSize*sizeof(struct ListNode));\n    for( i = 0; i &lt; H-&gt;TableSize; i++ ) \n    {   /*Allocate list headers*/\n        //H-&gt;TheLists[ i ] = malloc( sizeof( struct ListNode ) ); /* Slow! */\n        if ( H-&gt;TheLists[ i ] == NULL ) FatalError( \"Out of space!!!\" ); \n        else H-&gt;TheLists[ i ]-&gt;Next = NULL;\n    } \n    return H; \n} \n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK14/#find-a-key-from-a-hash-table","title":"Find a key from a hash table","text":"<pre><code>Position Find ( ElementType Key, HashTable H ) \n{ \n    Position P; \n    List L; \n    L = H-&gt;TheLists[ Hash( Key, H-&gt;TableSize ) ]; \n    P = L-&gt;Next; \n    while( P != NULL &amp;&amp; P-&gt;Element != Key )  /*Probably need strcmp*/ \n        P = P-&gt;Next; \n    return P; \n} \n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK14/#insert-a-key-into-a-hash-table","title":"Insert a key into a hash table","text":"<pre><code>void Insert ( ElementType Key, HashTable H ) \n{ \n    Position Pos, NewCell; \n    List L; \n    Pos = Find( Key, H ); \n    if ( Pos == NULL ) \n    {   /*Key is not found, then insert*/\n        NewCell = malloc( sizeof( struct ListNode ) ); \n        if ( NewCell == NULL ) FatalError( \"Out of space!!!\" ); \n        else \n        { \n            L = H-&gt;TheLists[ Hash( Key, H-&gt;TableSize ) ]; /*Compute again is bad*/\n            NewCell-&gt;Next = L-&gt;Next; \n            NewCell-&gt;Element = Key; /*Probably need strcpy!*/ \n            L-&gt;Next = NewCell; \n        } \n    } \n} \n</code></pre> <p>Note : Make the TableSize about as large as the number of keys expected (i.e. to make the loading density factor \\(\\lambda\\approx\\)1).</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK14/#84-open-addressing","title":"8.4 Open Addressing","text":"<ul> <li>find another empty cell to solve collision(avoiding pointers)</li> </ul> <pre><code>Algorithm: insert key into an array of hash table\n{\n    index = hash(key);\n    initialize i = 0 ------ the counter of probing;\n    while (collision at index) \n    {\n        index = (hash(key)+f(i))%TableSize; /*f(i) is collision resolving function*/\n        if (table is full) break;\n        else i++;\n    }\n    if (table is full) ERROR (\u201cNo space left\u201d);\n    else insert key at index;\n}\n</code></pre> <p>Note : Generally \\(\\lambda&lt;0.5\\).</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK14/#linear-probing","title":"Linear Probing","text":"<ul> <li>\\(F(i)\\) is a linear function of \\(i\\), such as \\(F(i)=i\\).</li> <li>\u9010\u4e2a\u63a2\u6d4b\u6bcf\u4e2a\u5355\u5143(\u5fc5\u8981\u65f6\u53ef\u4ee5\u7ed5\u56de)\u4ee5\u67e5\u627e\u51fa\u4e00\u4e2a\u7a7a\u5355\u5143</li> <li>\u4f7f\u7528\u7ebf\u6027\u63a2\u6d4b\u7684\u9884\u671f\u63a2\u6d4b\u6b21\u6570\u5bf9\u4e8e\u63d2\u5165\u548c\u4e0d\u6210\u529f\u7684\u67e5\u627e\u6765\u8bf4\u5927\u7ea6\u662f\\(\\frac{1}{2}(1+\\frac{1}{(1-\\lambda)^2})\\)\uff0c\u5bf9\u4e8e\u6210\u529f\u7684\u67e5\u627e\u6765\u8bf4\u662f\\(\\frac{1}{2}(1+\\frac{1}{1-\\lambda})\\)</li> <li>Cause primary clustering : any key that hashes into the cluster will add to the cluster after several attempts to resolve the collision.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK15/","title":"WEEK 15","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK15/#quadratic-probing","title":"Quadratic Probing","text":"<ul> <li>\\(F(i)\\) is a quadratic function of \\(i\\), such as \\(F(i)=i^2\\).</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK15/#theorem-if-quadratic-probing-is-used-and-the-table-size-is-prime-then-a-new-element-can-always-be-inserted-if-the-table-is-at-least-half-empty","title":"[Theorem] If quadratic probing is used, and the table size is prime, then a new element can always be inserted if the table is at least half empty.","text":"<p>Note : If the table size is a prime of the form \\(4k + 3\\), then the quadratic probing  \\(f(i) = \\pm i^2\\) can probe the entire table.</p> <pre><code>HashTable InitializeTable(int TableSize)\n{\n    HashTable H;\n    int i;\n    if(TableSize &lt; MinTableSize)\n    {\n        Error(\"Table size too small\");\n        return NULL;\n    }\n    /*Allocate table*/\n    H = malloc(sizeof(struct HashTbl));\n    if(H == NULL)\n        Fatal Error(\"Out of space!!!\");\n    H-&gt;TableSize = NextPrime(TableSize);\n\n    /*Allocate array of Cells*/\n    H-&gt;TheCells = malloc(sizeof(Cell)*H-&gt;TableSize);\n    if(H-&gt;TheCells == NULL)\n        FatalError(\"Out of space!!!\");\n\n    for(i = 0; i &lt; H-&gt;TableSize; i++)\n        H-&gt;TheCells[ i ].Info = Empty;\n    return H;\n}\n</code></pre> <pre><code>Position Find(ElementType Key, HashTable H) \n{   \n    Position CurrentPos; \n    int CollisionNum; \n    CollisionNum = 0; \n    CurrentPos = Hash(Key, H-&gt;TableSize); \n    while(H-&gt;TheCells[ CurrentPos ].Info != Empty &amp;&amp;\n          H-&gt;TheCells[ CurrentPos ].Element != Key) \n    { \n        CurrentPos += 2*++CollisionNum-1; \n        if (CurrentPos &gt;= H-&gt;TableSize)  \n            CurrentPos -= H-&gt;TableSize;   /*Faster than mod*/\n    } \n    return CurrentPos; \n} \n</code></pre> <pre><code>void Insert(ElementType Key, HashTable H) \n{ \n    Position Pos; \n    Pos = Find(Key, H); \n    if (H-&gt;TheCells[ Pos ].Info != Legitimate) \n    { /*OK to insert here*/ \n        H-&gt;TheCells[ Pos ].Info = Legitimate; \n        H-&gt;TheCells[ Pos ].Element = Key; /*Probably need strcpy*/ \n    } \n} \n</code></pre> <p>Note :</p> <ul> <li>Insertion will be seriously slowed down if there are too many deletions intermixed with insertions.</li> <li>Although primary clustering is solved, secondary clustering occurs, that is, keys that hash to the same position will probe the same alternative cells.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK15/#double-hashing","title":"Double Hashing","text":"<ul> <li>\\(f(i)=i*hash_2(x)\\)</li> <li>\\(hash_2(x)\\not\\equiv 0\\)</li> <li>make sure that all cells can be probed</li> <li>\\(hash_2(x)=R-(x\\%R)\\) with \\(R\\) a prime smaller than TableSize, will work well.</li> </ul> <p>Note :</p> <ul> <li>If double hashing is correctly implemented, simulations imply that the expected number of probes is almost the same as for a random collision resolution strategy.</li> <li>Quadratic probing does not require the use of a second hash function and is thus likely to be simpler and faster in practice.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/DS%20WEEK15/#85-rehashing","title":"8.5 Rehashing","text":"<ul> <li>Build another table that is about twice as big.</li> <li>Scan down the entire original hash table for non-deleted elements.</li> <li>Use a new function to hash those elements into the new table.</li> <li>When to rehash</li> <li>As soon as the table is half full</li> <li>When an insertion fails</li> <li>When the table reaches a certain load factor</li> </ul> <p>Note : Usually there should have been N/2 insertions before rehash, so O(N) rehash only adds a constant cost to each insertion. However, in an interactive system, the unfortunate user whose insertion caused a rehash could see a slowdown.</p> <pre><code>HashTable Rehash(HashTable H)\n{\n    int i, OldSize;\n    Cell *OldCells;\n    OldCells = H-&gt;TheCells;\n    OldSize = H-&gt;TableSize;\n\n    /*Get a new, empty table*/\n    H = InitializeTable(2*OldSize);\n    /*Scan through old table, reinserting into new*/\n    for(i = 0; i &lt; OldSize; i++)\n        if(OldCells[i].Info == Legitimate)\n            Insert(OldCells[i].Element, H);\n    free(OldCells);\n\n    return H;\n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/","title":"Foundation of Data Structure","text":"<p>by OE.Heart</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#1-algorithm-analysis","title":"1 Algorithm Analysis","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#definition-an-algorithm-is-a-finite-set-of-instructions-that-if-followed-accomplishes-a-particular-task-in-addition-all-algorithms-must-satisfy-the-following-criteria","title":"[Definition] An algorithm is a finite set of instructions that, if followed, accomplishes a particular task. In addition, all algorithms must satisfy the following criteria.","text":"<ol> <li> <p>Input : There are zero or more quantities that are externally supplied.</p> </li> <li> <p>Output : At least one quantity is produced.</p> </li> <li> <p>Definiteness : Each instruction is clear and unambiguous.</p> </li> <li> <p>Finiteness : the algorithm terminates after finite number of steps</p> </li> <li> <p>Effectiveness : basic enough to be carried out ; feasible</p> </li> <li> <p>A program does not have to be finite. (eg. an operation system)</p> </li> <li> <p>An algorithm can be described by human languages, flow charts, some programming languages, or pseudocode.</p> </li> </ol>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#example-selection-sort-sort-a-set-of-ngeq1-integers-in-increasing-order","title":"[Example] Selection Sort : Sort a set of \\(n\\geq1\\) integers in increasing order","text":"<pre><code>for (i = 0; i &lt; n; i++){\n    Examine list[i] to list[n-1] and suppose that the smallest integer is at list[min];\n    Interchange list[i] and list[min];\n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#11-what-to-analyze","title":"1.1 What to Analyze","text":"<ul> <li> <p>Machine and compiler-dependent run times.</p> </li> <li> <p>Time and space complexities : machine and compiler independent.</p> </li> <li> <p>Assumptions:</p> </li> </ul> <ol> <li> <p>instructions are executed sequentially \u987a\u5e8f\u6267\u884c</p> </li> <li> <p>each instruction is simple, and takes exactly one time unit</p> </li> <li>integer size is fixed and we have infinite memory</li> </ol> <ul> <li>\\(T_{avg}(N)\\, and\\, T_{worst}(N)\\) : the average and worst case time complexities as functions of input size \\(N\\)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#example-matrix-addition","title":"[Example] Matrix addition","text":"<pre><code>void add(int a[][MAX_SIZE],\n         int b[][MAX_SIZE],\n         int c[][MAX_SIZE],\n         int rows, int cols) \n{\n    int i, j;\n    for (i=0; i&lt;rows; i++)/*rows+1*/\n        for (j=0;j&lt;cols;j++)/*rows(cols+1)*/\n            c[i][j] = a[i][j]+b[i][j];/*rows*cols*/\n}\n</code></pre> \\[ T(rows, cols) = 2rows\\times cols + 2rows+1 \\] <ul> <li>\u975e\u5bf9\u79f0</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#example-iterative-function-for-summing-a-list-of-numbers","title":"[Example] Iterative function for summing a list of numbers","text":"<pre><code>float sum (float list[], int n)\n{  /*add a list of numbers*/\n    float tempsum = 0; /*count = 1*/\n    int i;\n    for (i=0; i&lt;n; i++)\n        /*count++*/\n        tempsum  += list[i]; /*count++*/\n    /*count++ for last excutaion of for*/\n   return tempsum; /*count++*/\n}\n</code></pre> \\[ T_{sum}(n)=2n+3 \\]"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#example-recursive-function-for-summing-a-list-of-numbers","title":"[Example] Recursive function for summing a list of numbers","text":"<pre><code>float rsum (float list[], int n)\n{/*add a list of numbers*/\n    if (n) /*count++*/\n        return rsum(list, n-1) + list[n-1];\n        /*count++*/\n    return 0; /*count++*/\n}\n</code></pre> \\[ T_{rsum}(n)=2n+2 \\] <p>But it takes more time to compute each step.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#12-asymptotic-notationoomegathetao","title":"1.2 Asymptotic Notation(\\(O,\\Omega,\\Theta,o\\))","text":"<ul> <li>predict the growth ; compare the time complexities of two programs ; asymptotic(\u6e10\u8fdb\u7684) behavior</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#definition-tnofn-if-there-are-positive-constants-c-and-n_0-such-that-tnleq-ccdot-fn-for-all-ngeq-n_0upper-bound","title":"[Definition] \\(T(N)=O(f(N))\\) if there are positive constants \\(c\\) and \\(n_0\\) such that \\(T(N)\\leq c\\cdot f(N)\\) for all \\(N\\geq n_0\\).(upper bound)","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#definition-tnomegagn-if-there-are-positive-constants-c-and-n_0-such-that-tngeq-ccdot-fn-for-all-ngeq-n_0lower-bound","title":"[Definition] \\(T(N)=\\Omega(g(N))\\) if there are positive constants \\(c\\) and \\(n_0\\) such that \\(T(N)\\geq c\\cdot f(N)\\) for all \\(N\\geq n_0\\).(lower bound)","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#definition-tnthetahn-if-and-only-if-tnohn-and-tnomegahn","title":"[Definition] \\(T(N)=\\Theta(h(N))\\) if and only if \\(T(N)=O(h(N))\\) and \\(T(N)=\\Omega(h(N))\\).","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#definition-tnopn-if-tnopn-and-tnneqthetapn","title":"[Definition] \\(T(N)=o(p(N))\\) if \\(T(n)=O(p(N))\\) and \\(T(N)\\neq\\Theta(p(N))\\).","text":"<ul> <li> <p>\\(2N+3=O(N)=O(N^{k\\geq1})=O(2^N)=\\ldots\\) take the smallest \\(f(N)\\)</p> </li> <li> <p>\\(2^N+N^2=\\Omega(2^N)=\\Omega(N^2)=\\Omega(N)=\\Omega(1)=\\ldots\\) take the largest \\(g(N)\\)</p> </li> <li> <p>Rules of Asymptotic Notation</p> </li> </ul> <ol> <li>If \\(T_1(N)=O(f(N))\\) and \\(T_2=O(g(N))\\), then</li> </ol> <p>(1) \\(T_1(N)+T_2(N)=max(O(f(N)),O(g(N)))\\)</p> <p>(2) \\(T_1(N)*T_2(N)=O(f(N)*g(N))\\)</p> <ol> <li> <p>\u82e5\\(T(N)\\)\u662f\u4e00\u4e2a\\(k\\)\u6b21\u591a\u9879\u5f0f\uff0c\u5219\\(T(N)=\\Theta(N^k)\\)</p> </li> <li> <p>\\(log_kN=O(N)\\) for any constant \\(k\\) (logarithms grow very slowly)</p> </li> </ol> <p></p> <p></p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#example-matrix-addition_1","title":"[Example] Matrix addition","text":"<pre><code>void add(int a[][MAX_SIZE],\n         int b[][MAX_SIZE],\n         int c[][MAX_SIZE],\n         int rows, int cols) \n{\n    int i, j;\n    for (i=0; i&lt;rows; i++)\n        for (j=0;j&lt;cols;j++)\n            c[i][j] = a[i][j]+b[i][j];\n}\n</code></pre> \\[ T(rows,cols)=\\Theta(rows\\cdot cols) \\]"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#general-rules","title":"General Rules","text":"<ul> <li> <p>For loops : The running time of a for loop is at most the running time of the statements inside the for loop (including tests) times the number of iterations.</p> </li> <li> <p>Nested for loops : The total running time of a statement inside a group of nested loops is the running time of the statements multiplied by the product of the sizes of all the for loops.</p> </li> <li> <p>Consecutive statements : These just add (which means that the maximum is the one that counts).</p> </li> <li> <p>If/else : For the fragment       if ( Condition )  S1;           else  S2;</p> </li> </ul> <p>The running time is never more than the running time of the test plus the larger of the running time of S1 and S2.</p> <p></p> <ul> <li>Recursions : </li> </ul> <p>[Example] Fibonacci number   $$   Fib(0)=Fib(1)=1, Fib(n)=Fib(n-1)+Fib(n-2)   $$</p> <p><code>c   lont int Fib (int N) /*T(N)*/   {       if (N&lt;=1) /*O(1)*/           return 1; /*O(1)*/       else           return Fib(N-1)+Fib(N-2);   }      /*O(1)*//*T(N-1)*//*T(N-2)*/</code></p> <p>$$   T(N)=T(N-1)+T(N-2)+2\\geq Fib(N)\\   \\left(\\frac{3}{2} \\right)^n\\leq Fib(N)\\leq\\left(\\frac{5}{3}\\right)^n   $$</p> <p>\u65f6\u95f4\u590d\u6742\u5ea6\uff1a\\(O(2^N)\\) \\(T(N)\\) grows exponentially</p> <p>\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a\\(O(N)\\)</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#13-compare-the-algorithms","title":"1.3 Compare the Algorithms","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#example","title":"[Example] \u6700\u5927\u5b50\u5e8f\u5217\u548c","text":"<p>Algorithm 1</p> <pre><code>int  MaxSubsequenceSum ( const int A[ ],  int  N ) \n{ \n    int ThisSum, MaxSum, i, j, k; \n    MaxSum = 0;   /* initialize the maximum sum */\n    for( i = 0; i &lt; N; i++ )  /* start from A[ i ] */\n        for( j = i; j &lt; N; j++ ) {   /* end at A[ j ] */\n            ThisSum = 0; \n            for( k = i; k &lt;= j; k++ ) \n                ThisSum += A[ k ];  /* sum from A[ i ] to A[ j ] */\n            if ( ThisSum &gt; MaxSum ) \n                MaxSum = ThisSum;  /* update max sum */\n        }  /* end for-j and for-i */\n    return MaxSum; \n}\n</code></pre> \\[ T(N)=O(N^3) \\] <p>Algotithm 2</p> <pre><code>int  MaxSubsequenceSum ( const int A[ ],  int  N ) \n{ \n    int ThisSum, MaxSum, i, j; \n    MaxSum = 0;   /* initialize the maximum sum */\n    for( i = 0; i &lt; N; i++ ) {   /* start from A[ i ] */\n        ThisSum = 0; \n        for( j = i; j &lt; N; j++ ) {   /* end at A[ j ] */\n            ThisSum += A[ j ];  /* sum from A[ i ] to A[ j ] */\n            if ( ThisSum &gt; MaxSum ) \n                MaxSum = ThisSum;  /* update max sum */\n        }  /* end for-j */\n    }  /* end for-i */\n    return MaxSum; \n} \n</code></pre> \\[ T(N)=O(N^2) \\] <p>Algorithm 3 Divide and Conquer  \u5206\u6cbb\u6cd5</p> <pre><code>static int MaxSubSum(const int A[ ], int Left, int Right)\n{\n    int MaxLeftSum, MaxRightSum;\n    int MaxLeftBorderSum, MaxRightBorderSum;\n    int LeftBorderSum, RightBorderSum;\n    int Center, i;\n\n    if (Left == Right)\n        if (A[Left] &gt; 0)\n            return A[Left];\n        else\n            return 0;\n\n    Center = (Left + Right) / 2;\n    MaxLeftSum = MaxSubSum(A, Left, Center);\n    MaxRightSum = MaxSubSum(A, Center + 1, Right);\n\n    MaxLeftBorderSum = 0;\n    LeftBorderSum = 0;\n    for (i = Center; i &gt;= Left; i--)\n    {\n        LeftBorderSum += A[i];\n        if (LeftBorderSum &gt; MaxLeftBorderSum)\n            MaxLeftBorderSum = LeftBorderSum;\n    }\n\n    MaxRightBorderSum = 0;\n    RightBorderSum = 0;\n    for (i = Center+1; i &lt;= Right; i++)\n    {\n        RightBorderSum += A[i];\n        if (RightBorderSum &gt; MaxRightBorderSum)\n            MaxRightBorderSum = RightBorderSum;\n    }\n\n    return Max3(MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum);\n}\n\nint MaxSubsequenceSum(const int A[ ], int N)\n{\n    return MaxSubSum(A, 0, N - 1);\n}\n</code></pre> \\[ \\because T(N)=2T(\\frac N2)+cN\\quad T(1)=O(1)\\\\ T(\\frac N2)=2T(\\frac N {2^2})+c\\frac N2\\\\ \\cdots\\\\ T(1)=2T(\\frac N{2^k})+c\\frac N{2^{k-1}}\\\\ \\therefore T(N)=2^kT(\\frac N{2^k})+kcN=N\\cdot O(1)+cN\\log N \\] <p>Algorithm 4 On-line Algorithm  \u5728\u7ebf\u7b97\u6cd5</p> <pre><code>int MaxSubsequenceSum( const int  A[ ],  int  N ) \n{ \n    int ThisSum, MaxSum, j; \n    ThisSum = MaxSum = 0; \n    for ( j = 0; j &lt; N; j++ ) { \n        ThisSum += A[ j ]; \n        if ( ThisSum &gt; MaxSum ) \n            MaxSum = ThisSum; \n        else if ( ThisSum &lt; 0 ) \n            ThisSum = 0;\n    }  /* end for-j */\n    return MaxSum; \n} \n</code></pre> \\[ T(N)=O(N) \\] <ul> <li>A[ ] is scanned once only. \u626b\u63cf\u4e00\u6b21\uff0c\u65e0\u9700\u5b58\u50a8\uff08\u5904\u7406streaming data\uff09</li> <li>\u5728\u4efb\u610f\u65f6\u523b\uff0c\u7b97\u6cd5\u90fd\u80fd\u5bf9\u5b83\u5df2\u7ecf\u8bfb\u5165\u7684\u6570\u636e\u7ed9\u51fa\u5b50\u5e8f\u5217\u95ee\u9898\u7684\u6b63\u786e\u7b54\u6848(\u5176\u4ed6\u7b97\u6cd5\u4e0d\u5177\u6709\u8fd9\u4e2a\u7279\u6027)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#14-logrithms-in-the-running-time","title":"1.4 Logrithms in the Running Time","text":"<ul> <li>\u5982\u679c\u4e00\u4e2a\u7b97\u6cd5\u7528\u5e38\u6570\u65f6\u95f4\u5c06\u95ee\u9898\u7684\u5927\u5c0f\u524a\u51cf\u4e3a\u5176\u4e00\u90e8\u5206(\u901a\u5e38\u662f1/2)\uff0c\u90a3\u4e48\u8be5\u7b97\u6cd5\u5c31\u662f\\(O(logN)\\)\u7684</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#example-binary-search","title":"[Example] Binary Search","text":"<pre><code>int BinarySearch ( const ElementType A[ ], ElementType X, int N ) \n{ \n    int  Low, Mid, High; \n    Low = 0;  High = N - 1; \n    while ( Low &lt;= High ) { \n        Mid = ( Low + High ) / 2; \n        if ( A[ Mid ] &lt; X ) \n            Low = Mid + 1; \n        else \n            if ( A[ Mid ] &gt; X ) \n                High = Mid - 1; \n            else \n                return  Mid; /* Found */ \n    }  /* end while */\n    return  NotFound; /* NotFound is defined as -1 */ \n} \n</code></pre> \\[ T_{worst}(N)=O(\\log N) \\]"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#example-euclids-algorithm","title":"[Example] Euclid\u2019s Algorithm","text":"<pre><code>int Gcd(int M, int N)\n{\n    int Rem;\n\n    while (N &gt; 0)\n    {\n        Rem = M % N;\n        M = N;\n        N = Rem;\n    }\n    return M;\n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#example-efficient-exponentiation","title":"[Example] Efficient exponentiation","text":"<pre><code>long int Pow(long int X, int N)\n{\n    if (N == 0) return 1;\n    if (N == 1) return X;\n    if (IsEven(N)) return Pow(X*X, N/2);/*return Pow(X, N/2)*Pow(X, N/2) affects the efficiency*/\n    else return Pow(X*X, N/2)*X; /*return Pow(X, N-1)*X is the same*/\n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#15-checking-your-analysis","title":"1.5 Checking Your Analysis","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#method-1","title":"Method 1","text":"<p>When \\(T(N)=O(N)\\), check if \\(T(2N)/T(N)\\approx2\\)</p> <p>When \\(T(N)=O(N^2)\\), check if \\(T(2N)/T(N)\\approx4\\)</p> <p>When \\(T(N)=O(N^3)\\), check if \\(T(2N)/T(N)\\approx8\\)</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#method-2","title":"Method 2","text":"<p>When \\(T(N)=O(f(N))\\), check if $\\lim\\limits_{N\\rightarrow\\infty}\\frac{T(N)}{f(N)}\\approx C $</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#2-list-stacks-and-queues","title":"2 LIst, Stacks and Queues","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#21-abstract-data-typeadt","title":"2.1 Abstract Data Type(ADT)  \u62bd\u8c61\u6570\u636e\u7c7b\u578b","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#definition-data-type-objects-and","title":"[Definition] Data Type = {Objects} and","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#definition-an-abstract-data-typeadt-is-a-data-type-that-is-organized-in-such-a-way-that-the-specification-on-the-objects-and-specification-of-the-operations-on-the-objects-are-separated-from-the-representation-of-the-objects-and-the-implementation-on-the-operations","title":"[Definition] An Abstract Data Type(ADT) is a data type that is organized in such a way that the specification on the objects and specification of the operations on the objects are separated from the representation of the objects and the implementation on the operations.","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#22-the-list-adt","title":"2.2 The List ADT","text":"<ul> <li>Objects : N items</li> <li>Operations</li> <li>Finding the length</li> <li>Printing</li> <li>Making an empty</li> <li>Finding</li> <li>Inserting</li> <li>Deleting</li> <li>Finding next</li> <li>Finding previous</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#simple-array-implementation-of-lists","title":"Simple Array implementation of Lists","text":"<ul> <li> <p>Sequential mapping \u8fde\u7eed\u5b58\u50a8\uff0c\u8bbf\u95ee\u5feb</p> </li> <li> <p>Find_Kth take \\(O(1)\\) time.</p> </li> <li> <p>MaxSize has to be estimated.</p> </li> <li> <p>Insertion and Deletion not only take \\(O(N)\\) times, but also involve a lot of data movements which takes time.</p> </li> </ul> <p></p> <p>Query \u67e5\u8be2</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#linked-lists","title":"Linked Lists","text":"<ul> <li> <p>Location of nodes may change on differrent runs.</p> </li> <li> <p>Insertion \u5148\u8fde\u540e\u65ad</p> </li> <li> <p>Deletion \u5148\u8fde\u540e\u91ca\u653e</p> </li> <li> <p>\u9891\u7e41malloc\u548cfree\u7cfb\u7edf\u5f00\u9500\u8f83\u5927</p> </li> <li> <p>Finding take \\(O(N)\\) times.</p> </li> </ul> <p><code>c   /*Return true if L is empty*/   int IsEmpty(List L)   {     return L-&gt;Next == NULL;   }</code></p> <p><code>c   /*Return true if P is the last position in list L*/   /*Parameter L is unused in this implementation*/   int IsLast(Position P, List L)   {     return P-&gt;Next == NULL;   }</code></p> <p>```c   /Return Position of X in L; NULL if not found/   Position Find(Element X, List L)   {     Position P;</p> <pre><code>P = L-&gt;Next;\nwhile (P != NULL &amp;&amp; P-&gt;Element != X) P = P-&gt;Next;\n\nreturn P;\n</code></pre> <p>}   ```</p> <p>```c   /Delete first occurence of X from a list/   /Assume use of a header node/   void Delete(ElementType X, List L)   {     Position P, TmpCell;</p> <pre><code>P = FindPrevious(X, L);\n\nif (!IsLast(P, L))\n{\n    TmpCell = P-&gt;Next;\n    P-&gt;Next = TmpCell-&gt;Next;\n    free(TmpCell);\n}\n</code></pre> <p>}   ```</p> <p>```c   /If X is not found, then Next field of returned/   /Assumes a header/   Position FindPrevious(ElementType X, List L)   {     Position P;</p> <pre><code>P = L;\nwhile (P-&gt;Next != NULL &amp;&amp; P-&gt;Next-&gt;Element != X) P = P-&gt;Next;\n\nreturn P;\n</code></pre> <p>}   ```</p> <p>```c   /Insert (after legal position P)/   /Header implementation assumed/   /Parameter L is unused in this implementation/   void Insert(ElementType X, List L, Position P)   {     Position TmpCell;</p> <pre><code>TmpCell = malloc(sizeof(struct Node));\nif (TmpCell == NULL) FatalError(\"Out of space!\")\n\nTmpCell-&gt;Element = X;\nTmpeCell-&gt;Next = P-&gt;Next;\nP-&gt;Next = TmpCell;\n</code></pre> <p>}   ```</p> <p>```c   void DeleteList(List L)   {     Position P, Tmp;</p> <pre><code>P = L-&gt;Next;\nL-&gt;Next = NULL;\nwhile (P != NULL)\n{\n    Tmp = P-&gt;Next;\n    free(P);\n    P = Tmp;\n}\n</code></pre> <p>}   ```</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#doubly-linked-circular-lists","title":"Doubly Linked Circular Lists","text":"<ul> <li>Finding take \\(O(\\frac N 2)\\) times.</li> </ul> <p>The correct answer is D.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#two-applications","title":"Two Applications","text":"<ol> <li> <p>The Polynomial ADT</p> </li> <li> <p>Objects : </p> </li> <li> <p>Operations : </p> </li> <li> <p>Finding degree</p> </li> <li>Addition</li> <li>Subtraction</li> <li> <p>Multiplication</p> </li> <li> <p>Differentiation</p> </li> <li> <p>[Representation 1]</p> </li> </ol> <p><code>c   typedef struct {     int CoeffArray [ MaxDegree + 1 ] ;     int HighPower;   }  *Polynomial ;</code></p> <p><code>c   /*\u5c06\u591a\u9879\u5f0f\u521d\u59cb\u5316\u4e3a\u96f6*/   void ZeroPolynomial(Polynomial Poly)   {     int i;     for(i = O; i &lt;= MaxDegree; i++)         Poly-&gt;CoeffArray[ i ] = O;     Poly-&gt;HighPower = O;   }</code></p> <p>```c   /\u4e24\u4e2a\u591a\u9879\u5f0f\u76f8\u52a0/   void AddPolynomial(const Polynomial Poly1, const Polynomial Poly2, Polynomial PolySum)   {       int i;</p> <pre><code>  ZeroPolynomial(PolySum);\nPolySum-&gt;HighPower = Max(Poly1-&gt;HighPower, Poly2-&gt;HighPower);\n\n  for (i = PolySum-&gt;HighPower; i &gt;= O; i--)\n    PolySum-&gt;CoeffArray[ i ] = Poly1-&gt;CoeffArray[ i ] + Poly2-&gt;CoeffArray[ i ];\n</code></pre> <p>}   ```</p> <p>```c   void MultPolynomial(const Polynomial Poly1, const Polynomial Poly2, Polynomial PolyProd)   {       int i, j;</p> <pre><code>  ZeroPolynomial (PolyProd);\nPolyProd-&gt;HighPower = Poly1-&gt;HighPower + Poly2-&gt;HighPower;\n\n  if(PolyProd-&gt;HighPower &gt; MaxDegree)\n    Error(\"Exceeded array size\");\nelse\n    for(i = O; i &lt;= Poly1-&gt;HighPower; i++)\n        for(j = O; j &lt;= Poly2-&gt;HighPower; j++)\n            PolyProd-&gt;CoeffArray[ i + j ] += Poly1-&gt;CoeffArray[ i ] * Poly2-&gt;CoeffArray[ j ];\n</code></pre> <p>}   ```</p> <ul> <li>[Representation 2]</li> </ul> <p><code>c   typedef struct poly_node *poly_ptr;   struct poly_node{       int Coefficient;  /* assume coefficients are integers */       int Exponent;       poly_ptr Next;   };   typedef poly_ptr a;    /* nodes sorted by exponent */</code></p> <ul> <li> <p>\u53ea\u5b58\u50a8\u975e\u96f6\u9879</p> </li> <li> <p>Multilists</p> </li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#cursor-implementation-of-linked-listsno-pointer","title":"Cursor Implementation of Linked Lists(no pointer)","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#23-the-stack-adt","title":"2.3 The Stack ADT","text":"<ul> <li>Last-In-First-Out (LIFO)</li> <li>Objects : A finite ordered list with zero or more elements.</li> <li>Operations :</li> <li>IsEmpty</li> <li>CreatStack</li> <li>DisposeStack</li> <li>MakeEmpty</li> <li>Push</li> <li>Top</li> <li>Pop</li> <li>A Pop(or Top) on an empty stack in an error in the stack ADT.</li> <li>Push on a full stack is an implementation error but not an ADT error.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#linked-list-implementation-with-a-header-node","title":"Linked List Implementation (with a header node)","text":"<ul> <li>The calls to malloc and free are expensive. Simply keep another stack as a recycle bin.</li> </ul> <p><code>c   int IsEmpty(Stack S)   {     return S-&gt;Next == NULL;   }</code></p> <p>```c   Stack CreateStack(void)   {     Stack S;     S = malloc(sizeof(struct Node));     if (S == NULL)         Fatal Error(\"Out of space!\");     S-&gt;Next == NULL;     MakeEmpty(S);     return S;   }</p> <p>void MakeEmpty(Stack S)   {     if (S == NULL)         Error(\"Must use CreateStack first\");     else         while(!IsEmpty(S)) Pop(S);   }   ```</p> <p><code>c   void Push(ElementType X, Stack S)   {     PtrToNode TmpCell;     TmpCell = malloc(sizeof(struct Node));     if (TmpCell == NULL)         Fatal Error(\"Out of space!\") ;     else     {         TmpCell-&gt;Element = X;         TmpCe11-&gt;Next = S-&gt;Next;         S-&gt;Next = TmpCell;     }   }</code></p> <p><code>c   ElementType Top(Stack S)   {     if(!IsEmpty(S))         return S-&gt;Next-&gt;Element;     Error(\"Empty stack\") ;     return O; /* Return value used to avoid warning*/   }</code></p> <p><code>c   void Pop(Stack s)   {     PtrToNode FirstCell;     if(IsEmpty(S))         Error(\"Empty stack\") ;     else     {         FirstCe11 = S-&gt;Next;         S-&gt;Next = S-&gt;Next-&gt;Next;         free(FirstCe11);     }   }</code></p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#array-implementation-of-stacks","title":"Array Implementation of Stacks","text":"<pre><code>struct StackRecord {\n    int Capacity;          /* size of stack */\n    int TopOfStack;        /* the top pointer */\n    /* ++ for push, -- for pop, -1 for empty stack */\n    ElementType *Array;    /* array for stack elements */\n}; \n</code></pre> <ul> <li> <p>The stack model must be well encapsulated(\u5c01\u88c5).  That is, no part of your code, except for the stack routines, can attempt to access the Array or TopOfStack variable.</p> </li> <li> <p>Error check must be done before Push or Pop (Top).</p> </li> </ul> <p>```c   Stack CreateStack(int MaxElements)   {     Stack S;     if(MaxElements &lt; MinStackSize)     Error(\"Stack size is too small\") ;     S = malloc(sizeof(struct StackRecord));     if (S == NULL)         Fatal Error(\"Out of space!!!\") ;</p> <pre><code>S-&gt;Array = malloc(sizeof(ElementType) * MaxElements) ;\nif(S-&gt;Array = NULL)\n    Fatal Error(\"Out of space!!!\");\nS-&gt;Capacity = MaxElements;\nMakeEmpty(S) ;\nreturn S;\n</code></pre> <p>}   ```</p> <p><code>c   void DisposeStack(Stack S)   {     if(S != NULL)     {         free(S-&gt;Array);         free(S);     }   }</code></p> <p><code>c   int IsEmpty(Stack S)   {     return S-&gt;TopOfStack == EmptyTOS;   }</code></p> <p><code>c   void MakeEmpty(Stack S)   {     S-&gt;TopOfStack = EmptyTOS;   }</code></p> <p><code>c   void Push(ElementType X, Stack S)   {     if (IsFull(S))         Error(\"Full stack\");     else         S-&gt;Array[ ++S-&gt;TopOfStack ] = X;   }</code></p> <p><code>c   ElementType Top(Stack S)   {     if(! IsEmpty(S))         return S-&gt;Array[ S-&gt;TopOfStack ];     Error(\"Empty stack\") ;     return O; /* Return value used to avoid warning*/   }</code></p> <p><code>c   void Pop(Stack S)   {     if(IsEmpty(S))         Error(\"Empty stack\") ;     else         S-&gt;TopOfStack--;   }</code></p> <p><code>c   ElementType TopAndPop(Stack S)   {     if(!Is Empty(S))         return S-&gt;Array[ S-&gt;TopOfStack-- ];     Error(\"Empty stack\");     return O; /* Return value used to avoid warnin */   }</code></p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#application","title":"Application","text":"<ol> <li>Balancing Symbols</li> </ol> <p>\u68c0\u67e5\u62ec\u53f7\u662f\u5426\u5e73\u8861</p> <p><code>pseudocode    Algorithm  {        Make an empty stack S;        while (read in a character c) {            if (c is an opening symbol)                Push(c, S);            else if (c is a closing symbol) {                if (S is empty)  { ERROR; exit; }                else  {  /* stack is okay */                    if  (Top(S) doesn\u2019t match c)  { ERROR, exit; }                    else  Pop(S);                }  /* end else-stack is okay */            }  /* end else-if-closing symbol */        } /* end while-loop */         if (S is not empty)  ERROR;    }</code></p> <ol> <li> <p>Postfix Evaluation \u540e\u7f00\u8868\u8fbe\u5f0f</p> </li> <li> <p>Infix to Postfix Conversion</p> </li> <li> <p>\u8bfb\u5230\u4e00\u4e2a\u64cd\u4f5c\u6570\u65f6\u7acb\u5373\u628a\u5b83\u653e\u5230\u8f93\u51fa\u4e2d</p> </li> <li>\u8bfb\u5230\u4e00\u4e2a\u64cd\u4f5c\u7b26\u65f6\u4ece\u6808\u4e2d\u5f39\u51fa\u6808\u5143\u7d20\u76f4\u5230\u53d1\u73b0\u4f18\u5148\u7ea7\u66f4\u4f4e\u7684\u5143\u7d20\u4e3a\u6b62\uff0c\u518d\u5c06\u64cd\u4f5c\u7b26\u538b\u5165\u6808\u4e2d</li> <li>The order of operands is the same in infix and postfix.</li> <li>Operators with higher precedence appear before those with lower precedence.</li> <li>Never pop a \u2019(\u2018 from the stack except when processing a \u2018)\u2019.</li> <li>When \u2018(\u2019 is not in the stack, its precedence is the highest; but when it is in the stack, its precedence is the lowest. </li> <li> <p>Exponentiation associates right to left.</p> </li> <li> <p>Function Calls (System Stack)</p> </li> </ol> <p></p> <p>Note : Recursion can always be completely removed. Non recursive programs are generally faster than equivalent recursive programs. However, recursive programs are in general much simpler and easier to understand.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#24-the-queue-adt","title":"2.4 The Queue ADT","text":"<ul> <li>First-In-First-Out (FIFO)</li> <li>Objects : A finite ordered list with zero or more elements.</li> <li>Operations : </li> <li>IsEmpty</li> <li>CreatQueue</li> <li>DisposeQueue</li> <li>MakeEmpty</li> <li>Enqueue</li> <li>Front</li> <li>Dequeue</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#array-implementation-of-queues","title":"Array Implementation of Queues","text":"<pre><code>struct QueueRecord {\n    int Capacity ;       /* max size of queue */\n    int Front;           /* the front pointer */\n    int Rear;            /* the rear pointer */\n    int Size;            /* Optional - the current size of queue */\n    ElementType *Array;  /* array for queue elements */\n }; \n</code></pre> <p>Circular Queue :</p> <p></p> <ul> <li>The maximum capacity of this queue is 5.</li> </ul> <p>Note : Adding a Size field can avoid wasting one empty space to distinguish \u201cfull\u201d from \u201cempty\u201d.  </p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#3-trees","title":"3 Trees","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#31-preliminaries","title":"3.1 Preliminaries","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#definition-a-tree-is-a-collection-of-nodes-the-collection-can-be-empty-otherwise-a-tree-consists-of-1-a-distinguished-node-r-called-the-root-2-and-zero-or-more-nonempty-subtrees-each-of-whose-roots-are-connected-by-a-directed-edge-from-r","title":"[Definition] A tree is a  collection of nodes. The collection can be empty; otherwise, a tree consists of (1)  a distinguished node r, called the root; (2) and zero or more nonempty (sub)trees, each of whose roots are connected by a directed edge from r.","text":"<ul> <li> <p>Subtrees must not connect together.  Therefore every node in the tree is the root of some subtree.</p> </li> <li> <p>There are N-1 edges in a tree with N nodes</p> </li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#terminologies","title":"Terminologies","text":"<ul> <li>degree of a node : \u7ed3\u70b9\u7684\u5b50\u6811\u4e2a\u6570</li> <li>degree of a tree : \u7ed3\u70b9\u7684\u5ea6\u7684\u6700\u5927\u503c</li> <li>parent : \u6709\u5b50\u6811\u7684\u7ed3\u70b9</li> <li>children : the roots of the subtrees of a parent</li> <li>siblings : children of the same parent</li> <li>leaf(terminal node) : a node with degree 0(no children)</li> <li>path from \\(n_1\\) to \\(n_k\\) : a unique sequence of nodes \\(n_1,n_2,\\cdots,n_k\\) such that \\(n_i\\) is the parent of \\(n_{i+1}\\) for \\(1\\leq i&lt;k\\) </li> <li>length of path : \u8def\u5f84\u4e0a\u8fb9\u7684\u6761\u6570</li> <li>depth of \\(n_i\\) : \u4ece\u6839\u7ed3\u70b9\u5230\\(n_i\\)\u7ed3\u70b9\u7684\u8def\u5f84\u7684\u957f\u5ea6(\\(Depth(root)=0\\))</li> <li>height of \\(n_i\\) : \u4ece\\(n_i\\)\u7ed3\u70b9\u5230\u53f6\u7ed3\u70b9\u7684\u6700\u957f\u8def\u5f84\u7684\u957f\u5ea6(\\(Height(leaf)=0\\))</li> <li>height/depth of a tree : \u6839\u7ed3\u70b9\u7684\u9ad8\u5ea6/\u6700\u6df1\u7684\u53f6\u7ed3\u70b9\u7684\u6df1\u5ea6</li> <li>ancestors of a node : \u4ece\u6b64\u7ed3\u70b9\u5230\u6839\u7ed3\u70b9\u7684\u8def\u5f84\u4e0a\u7684\u6240\u6709\u7ed3\u70b9</li> <li>descendants of a node : \u6b64\u7ed3\u70b9\u7684\u5b50\u6811\u4e2d\u7684\u6240\u6709\u7ed3\u70b9</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#list-representation","title":"List Representation","text":"<ul> <li>The size of each node depends on the number of branches.</li> </ul> <p>The correct answer is T.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#firstchild-nextsibling-representation","title":"FirstChild-NextSibling Representation","text":"<ul> <li>The representation is not unique since the children in a tree can be of any order.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#32-binary-trees","title":"3.2 Binary Trees","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#definition-a-binary-tree-is-a-tree-in-which-no-node-can-have-more-than-two-children","title":"[Definition] A binary tree is a tree in which no node can have more than two children.","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#tree-traversals-visit-each-node-exactly-once","title":"Tree Traversals (visit each node exactly once)","text":"<ol> <li>Preorder Traversal</li> </ol> <p><code>pseudocode    void preorder( tree_ptr tree )    {         if( tree )           {            visit ( tree );            for (each child C of tree )                preorder ( C );        }    }</code></p> <ol> <li>Postorder Traversal</li> </ol> <p><code>pseudocode    void postorder( tree_ptr tree )    {       if( tree )        {            for (each child C of tree )             postorder ( C );            visit ( tree );        }    }</code></p> <ol> <li>Levelorder Traversal</li> </ol> <p><code>pseudocode    void levelorder( tree_ptr tree )    {        enqueue ( tree );        while (queue is not empty)         {            visit ( T = dequeue ( ) );            for (each child C of T )                enqueue ( C );        }    }</code></p> <ol> <li>Inorder Traversal</li> </ol> <p><code>pseudocode    void inorder( tree_ptr  tree )    {       if( tree )        {         inorder ( tree-&gt;Left );             visit ( tree-&gt;Element );             inorder ( tree-&gt;Right );       }    }</code></p> <p>Iterative Program :</p> <p><code>pseudocode    void iter_inorder( tree_ptr tree )    {      Stack  S = CreateStack( MAX_SIZE );     for ( ; ; )       {         for ( ; tree; tree = tree-&gt;Left )             Push ( tree, S );             tree = Top ( S );               Pop( S );             if ( !tree ) break;             visit ( tree-&gt;Element );             tree = tree-&gt;Right;         }    }</code></p> <p></p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#threaded-binary-trees","title":"Threaded Binary Trees","text":"<ul> <li> <p>A full binary tree with \\(n\\) nodes has \\(2n\\) links, and \\(n+1\\) of them are NULL.</p> </li> <li> <p>Replace the NULL links by \u201cthreads\u201d which will make traversals easier.</p> </li> </ul> <p>Rules :</p> <ul> <li>If Tree-&gt;Left is null, replace it with a pointer to the inorder predecessor(\u4e2d\u5e8f\u524d\u9a71) of Tree.</li> <li>If Tree-&gt;Right is null, replace it with a pointer to the inorder successor(\u4e2d\u5e8f\u540e\u7ee7) of Tree.</li> <li>There must not be any loose threads.  Therefore a threaded binary tree must have a head node of which the left child points to the first node.</li> </ul> <pre><code>typedef struct ThreadedTreeNode *PtrToThreadedNode;\ntypedef struct PtrToThreadedNode ThreadedTree;\ntypedef struct ThreadedTreeNode \n{\n    int LeftThread;        /* if it is TRUE, then Left */\n    ThreadedTree Left;     /* is a thread, not a child ptr.*/\n    ElementType Element;\n    int RightThread;       /* if it is TRUE, then Right */\n    ThreadedTree Right;    /* is a thread, not a child ptr.*/\n}\n</code></pre> <ul> <li>\u7ebf\u7d22\u5316\u7684\u5b9e\u8d28\u5c31\u662f\u5c06\u4e8c\u53c9\u94fe\u8868\u4e2d\u7684\u7a7a\u6307\u9488\u6539\u4e3a\u6307\u5411\u524d\u9a71\u6216\u540e\u7ee7\u7684\u7ebf\u7d22\u3002\u7531\u4e8e\u524d\u9a71\u548c\u540e\u7ee7\u4fe1\u606f\u53ea\u6709\u5728\u904d\u5386\u8be5\u4e8c\u53c9\u6811\u65f6\u624d\u80fd\u5f97\u5230\uff0c\u6240\u4ee5\uff0c\u7ebf\u7d22\u5316\u7684\u8fc7\u7a0b\u5c31\u662f\u5728\u904d\u5386\u7684\u8fc7\u7a0b\u4e2d\u4fee\u6539\u7a7a\u6307\u9488\u7684\u8fc7\u7a0b\u3002</li> </ul> <p></p> <ul> <li>In a tree, the order of children does not matter. But in a binary tree, left child and right child are different.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#properties-of-binary-trees","title":"Properties of Binary Trees","text":"<ul> <li>The maximum number of nodes on level \\(i\\) is \\(2^{i-1},i\\geq1\\).</li> <li>The maximum number of nodes in a binary tree of depth \\(k\\) is \\(2^k-1,k\\geq1\\).</li> <li>For any nonempty binary tree, \\(n_0 = n_2 + 1\\) where \\(n_0\\) is the number of leaf nodes and \\(n_2\\) is the number of nodes of degree 2.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#33-binary-search-trees","title":"3.3 Binary Search Trees","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#definition-a-binary-search-tree-is-a-binary-tree-it-may-be-empty-if-it-is-not-empty-it-satisfies-the-following-properties","title":"[Definition] A binary search tree is a binary tree.  It may be empty.  If it is not empty, it satisfies the following properties:","text":"<ul> <li>\u6bcf\u4e2a\u7ed3\u70b9\u6709\u4e00\u4e2a\u4e92\u4e0d\u4e0d\u540c\u7684\u503c</li> <li>\u82e5\u5de6\u5b50\u6811\u975e\u7a7a\uff0c\u5219\u5de6\u5b50\u6811\u4e0a\u6240\u6709\u7ed3\u70b9\u7684\u503c\u5747\u5c0f\u4e8e\u6839\u7ed3\u70b9\u7684\u503c</li> <li>\u82e5\u53f3\u5b50\u6811\u975e\u7a7a\uff0c\u5219\u53f3\u5b50\u6811\u4e0a\u6240\u6709\u7ed3\u70b9\u7684\u503c\u5747\u5927\u4e8e\u6839\u7ed3\u70b9\u7684\u503c</li> <li>\u5de6\u3001\u53f3\u5b50\u6811\u4e5f\u662f\u662f\u4e00\u68f5\u4e8c\u53c9\u67e5\u627e\u6811</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#adt","title":"ADT","text":"<ul> <li>Objects : A finite ordered list with zero or more elements.</li> <li>Operations :</li> <li>SearchTree  MakeEmpty( SearchTree T )</li> <li>Position  Find( ElementType X, SearchTree T )</li> <li>Position  FindMin( SearchTree T )</li> <li>Position  FindMax( SearchTree T )</li> <li>SearchTree  Insert( ElementType X, SearchTree T )</li> <li>SearchTree  Delete( ElementType X, SearchTree T )</li> <li>ElementType  Retrieve( Position P )</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#implementations","title":"Implementations","text":"<ol> <li>Find</li> </ol> <p><code>pseudocode    Position Find( ElementType X, SearchTree T )     {      if ( T == NULL )          return NULL;  /* not found in an empty tree */        if ( X &lt; T-&gt;Element )  /* if smaller than root */            return Find( X, T-&gt;Left );  /* search left subtree */        else          if ( X &gt; T-&gt;Element )  /* if larger than root */             return  Find( X, T-&gt;Right );  /* search right subtree */            else   /* if X == root */             return  T;  /* found */    }</code></p> <ul> <li>\\(T(N)=S(N)=O(d)\\) where \\(d\\) is the depth of X</li> </ul> <p>Iterative program :</p> <p><code>pseudocode    Position Iter_Find( ElementType X, SearchTree T )     {      while ( T )     {         if ( X == T-&gt;Element )               return T;  /* found */            if ( X &lt; T-&gt;Element )                T = T-&gt;Left; /*move down along left path */            else                 T = T-&gt; Right; /* move down along right path */        }  /* end while-loop */        return NULL;   /* not found */    }</code></p> <ol> <li>FindMin</li> </ol> <p><code>pseudocode    Position FindMin( SearchTree T )     {      if ( T == NULL )            return NULL; /* not found in an empty tree */        else             if ( T-&gt;Left == NULL ) return T;  /* found left most */            else return FindMin( T-&gt;Left );   /* keep moving to left */    }</code></p> <ol> <li>FindMax</li> </ol> <p><code>pseudocode    Position FindMax( SearchTree T )     {      if ( T != NULL )          while ( T-&gt;Right != NULL )                T = T-&gt;Right;   /* keep moving to find right most */        return T;  /* return NULL or the right most */    }</code></p> <ol> <li>Insert</li> </ol> <p><code>pseudocode    SearchTree Insert( ElementType X, SearchTree T )     {         if ( T == NULL ) /* Create and return a one-node tree */         {          T = malloc( sizeof( struct TreeNode ) );          if ( T == NULL )              FatalError( \"Out of space!!!\" );          else          {              T-&gt;Element = X;              T-&gt;Left = T-&gt;Right = NULL;          }         }  /* End creating a one-node tree */        else  /* If there is a tree */             if ( X &lt; T-&gt;Element )              T-&gt;Left = Insert( X, T-&gt;Left );          else              if ( X &gt; T-&gt;Element )                  T-&gt;Right = Insert( X, T-&gt;Right );          /* Else X is in the tree already; we'll do nothing */         return  T;   /* Do not forget this line!! */     }</code></p> <ul> <li>\u5185\u5b58\u8d8a\u754c\u540e\u4e0d\u4f1a\u9a6c\u4e0a\u62a5\u9519\uff0c\u5728\u4e0b\u4e00\u6b21free\u6216malloc\u65f6\u4f1a\u5931\u8d25</li> <li>Handle duplicated keys</li> <li> <p>\\(T(N)=O(d)\\)</p> </li> <li> <p>Delete</p> </li> <li> <p>Delete a leaf node : Reset its parent link to NULL</p> </li> <li>Delete a degree 1 node : Replace the node by its single child</li> <li>Delete a degree 2 node : \u7528\u5de6\u5b50\u6811\u6700\u5927\u503c\u7ed3\u70b9\u6216\u53f3\u5b50\u6811\u6700\u5c0f\u503c\u7ed3\u70b9\u66ff\u6362</li> </ul> <p><code>pseudocode    SearchTree Delete( ElementType X, SearchTree T )     {         Position TmpCell;         if ( T == NULL ) Error( \"Element not found\" );         else if ( X &lt; T-&gt;Element )  /* Go left */          T-&gt;Left = Delete( X, T-&gt;Left );         else if ( X &gt; T-&gt;Element )  /* Go right */          T-&gt;Right = Delete( X, T-&gt;Right );      else  /* Found element to be deleted */          if ( T-&gt;Left &amp;&amp; T-&gt;Right ) {  /* Two children */          /* Replace with smallest in right subtree */              TmpCell = FindMin( T-&gt;Right );              T-&gt;Element = TmpCell-&gt;Element;              T-&gt;Right = Delete( T-&gt;Element, T-&gt;Right );  } /* End if */         else          {  /* One or zero child */              TmpCell = T;              if ( T-&gt;Left == NULL ) /* Also handles 0 child */                  T = T-&gt;Right;              else if ( T-&gt;Right == NULL )                   T = T-&gt;Left;              free( TmpCell );            }  /* End else 1 or 0 child */          return  T;     }</code></p> <ul> <li>\\(T(N)=O(d)\\)</li> </ul> <p>Note : If there are not many deletions, then lazy deletion may be employed: add a flag field to each node, to mark if a node is active or is deleted.  Therefore we can delete a node without actually freeing the space of that node.  If a deleted key is reinserted, we won\u2019t have to call malloc again.</p> <ol> <li> <p>Average-Case Analysis</p> </li> <li> <p>The average depth over all nodes in a tree is \\(O(logN)\\) on the assumption that all trees are equally likely.</p> </li> <li>\u5c06\\(n\\)\u4e2a\u5143\u7d20\u5b58\u5165\u4e8c\u53c9\u641c\u7d22\u6811\uff0c\u6811\u7684\u9ad8\u5ea6\u5c06\u7531\u63d2\u5165\u5e8f\u5217\u51b3\u5b9a</li> </ol> <p></p> <p>The correct answer is A.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#4-priority-queues-heaps","title":"4 Priority Queues (Heaps)","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#41-adt-model","title":"4.1 ADT Model","text":"<ul> <li>Objects :A finite ordered list with zero or more elements.</li> <li>Operations :</li> <li>PriorityQueue  Initialize( int MaxElements ); </li> <li>void  Insert( ElementType X, PriorityQueue H ); </li> <li>ElementType  DeleteMin( PriorityQueue H ); </li> <li>ElementType  FindMin( PriorityQueue H ); </li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#42-implementations","title":"4.2 Implementations","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#array","title":"Array","text":"<ul> <li> <p>Insertion \u2014 add one item at the end ~\\(\\Theta(1)\\)</p> </li> <li> <p>Deletion \u2014 find the largest / smallest key ~\\(\\Theta(n)\\)</p> </li> </ul> <p>\u200b                     remove the item and shift array ~\\(O(n)\\)</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#linked-list","title":"Linked List","text":"<ul> <li> <p>Insertion \u2014 add to the front of the chain ~\\(\\Theta(1)\\)</p> </li> <li> <p>Deletion \u2014 find the largest / smallest key ~\\(\\Theta(n)\\)</p> </li> </ul> <p>\u200b                      remove the item ~\\(\\Theta(1)\\)</p> <ul> <li>Never more deletions than insertions</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#ordered-array","title":"Ordered Array","text":"<ul> <li>Insertion \u2014 find the proper position ~\\(O(\\log n)\\)</li> </ul> <p>\u200b                      shift array and add the item  ~\\(O(n)\\)</p> <ul> <li>Deletion \u2014 remove the first / last item ~\\(\\Theta(1)\\)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#ordered-linked-list","title":"Ordered Linked List","text":"<ul> <li>Insertion \u2014 find the proper position ~\\(O(n)\\)</li> </ul> <p>\u200b                      add the item  ~\\(\\Theta(1)\\)</p> <ul> <li>Deletion \u2014 remove the first / last item ~\\(\\Theta(1)\\)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#binary-search-tree","title":"Binary Search Tree","text":"<ul> <li>Both insertion and deletion will take \\(O(\\log N)\\) only.</li> <li>Only delete the the minimum element, always delete from the left subtrees.</li> <li>Keep a balanced tree </li> <li>But there are many operations related to AVL tree that we don't really need for a priority queue.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#43-binary-heap","title":"4.3 Binary Heap","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#structure-property","title":"Structure Property","text":"<p>[Definition] A binary tree with \\(n\\) nodes and height \\(h\\) is complete  if  its nodes correspond to the nodes numbered from \\(1\\) to \\(n\\) in the perfect binary tree of height \\(h\\).</p> <ul> <li> <p>A complete binary tree of height \\(h\\) has between \\(2^h\\) and \\(2^{h+1}-1\\) nodes.</p> </li> <li> <p>\\(h=\\lfloor\\log N\\rfloor\\)</p> </li> <li> <p>Array Representation : BT[n + 1]  ( BT[0] is not used)</p> </li> </ul> <p></p> <p>[Lemma] </p> <ol> <li>\\(index\\,of\\,parent(i)=\\left\\{    \\begin{array}{rcl}    \\lfloor i/2\\rfloor &amp;&amp; {i\\neq1}\\\\    None &amp;&amp; {i=1}\\\\    \\end{array} \\right.\\)</li> <li>\\(index\\,of\\,left\\_child(i)=\\left\\{    \\begin{array}{rcl}    2i &amp;&amp; {2i\\leq n}\\\\    None &amp;&amp; {2i&gt;n}\\\\    \\end{array} \\right.\\)</li> <li>\\(index\\,of\\,right\\_child(i)=\\left\\{    \\begin{array}{rcl}    2i+1 &amp;&amp; {2i+1\\leq n}\\\\    None &amp;&amp; {2i+1&gt;n}\\\\    \\end{array} \\right.\\)</li> </ol> <pre><code>PriorityQueue Initialize( int MaxElements ) \n{ \n    PriorityQueue H; \n    if ( MaxElements &lt; MinPQSize ) \n        return Error( \"Priority queue size is too small\" ); \n    H = malloc(sizeof( struct HeapStruct )); \n    if ( H == NULL ) \n        return FatalError( \"Out of space!!!\" ); \n    /* Allocate the array plus one extra for sentinel */ \n    H-&gt;Elements = malloc(( MaxElements + 1 ) * sizeof( ElementType )); \n    if ( H-&gt;Elements == NULL ) \n        return FatalError( \"Out of space!!!\" ); \n    H-&gt;Capacity = MaxElements; \n    H-&gt;Size = 0; \n    H-&gt;Elements[0] = MinData;  /* set the sentinel */\n    return H; \n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#heap-order-property","title":"Heap Order Property","text":"<p>[Definition] A min tree is a tree in which the key value in each node is no larger than the key values in its children (if any).  A min heap is a complete binary tree that is also a min tree.</p> <ul> <li>We can declare a max heap by changing the heap order property.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#basic-heap-operations","title":"Basic Heap Operations","text":"<ol> <li>Insertion</li> </ol> <p><code>c    /*H-&gt;Element[ 0 ] is a sentinel that is no larger than the minimum element in the heap.*/     void Insert( ElementType X, PriorityQueue H )     {      int i;         if ( IsFull( H ))         {          Error( \"Priority queue is full\" );          return;         }         for ( i = ++H-&gt;Size; H-&gt;Elements[ i/2 ] &gt; X; i /= 2 )          H-&gt;Elements[ i ] = H-&gt;Elements[ i/2 ]; /*Percolate up, faster than swap*/        H-&gt;Elements[ i ] = X;     }</code></p> <p>$$    T(N)=O(\\log N)    $$</p> <ol> <li>DeleteMin</li> </ol> <p><code>c    ElementType DeleteMin( PriorityQueue H )     {         int i, Child;         ElementType MinElement, LastElement;         if ( IsEmpty( H ) )         {             Error( \"Priority queue is empty\" );             return H-&gt;Elements[ 0 ];           }         MinElement = H-&gt;Elements[ 1 ];  /*Save the min element*/        LastElement = H-&gt;Elements[ H-&gt;Size-- ];  /*Take last and reset size*/        for ( i = 1; i * 2 &lt;= H-&gt;Size; i = Child )  /*Find smaller child*/         {            Child = i * 2;             if (Child != H-&gt;Size &amp;&amp; H-&gt;Elements[Child+1] &lt; H-&gt;Elements[Child])                  Child++;                 if ( LastElement &gt; H-&gt;Elements[ Child ] )   /*Percolate one level*/                  H-&gt;Elements[ i ] = H-&gt;Elements[ Child ];             else                  break;   /*Find the proper position*/        }         H-&gt;Elements[ i ] = LastElement;         return MinElement;     }</code></p> \\[ T(N)=O(\\log N) \\]"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#other-heap-operations","title":"Other Heap Operations","text":"<ul> <li> <p>\u67e5\u627e\u9664\u6700\u5c0f\u503c\u4e4b\u5916\u7684\u503c\u9700\u8981\u5bf9\u6574\u4e2a\u5806\u8fdb\u884c\u7ebf\u6027\u626b\u63cf</p> </li> <li> <p>DecreaseKey \u2014 Percolate up</p> </li> <li> <p>IncreaseKey \u2014 Percolate down</p> </li> <li> <p>Delete</p> </li> <li> <p>BuildHeap</p> </li> </ul> <p>\u5c06N \u4e2a\u5173\u952e\u5b57\u4ee5\u4efb\u610f\u987a\u5e8f\u653e\u5165\u6811\u4e2d\uff0c\u4fdd\u6301\u7ed3\u6784\u7279\u6027\uff0c\u518d\u6267\u884c\u4e0b\u6ee4</p> <p><code>c    for (i = N/2; i &gt; 0; i--)     PercolateDown(i);</code></p> <p>$$    T(N)=O(N)    $$</p> <p>[Theorem] For the perfect binary tree of height \\(h\\) containing \\(2^{h+1}-1\\) nodes, the sum of the heights of the nodes is \\(2^{h+1}-1-(h+1)\\).</p> <p></p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#44-applications-of-priority-queues","title":"4.4 Applications of Priority Queues","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#heap-sort","title":"Heap Sort","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#k","title":"\u67e5\u627e\u4e00\u4e2a\u5e8f\u5217\u4e2d\u7b2ck\u5c0f\u7684\u5143\u7d20","text":"<p>The function is to find the <code>K</code>-th smallest element in a list <code>A</code> of <code>N</code> elements.  The function <code>BuildMaxHeap(H, K)</code> is to arrange elements <code>H[1]</code> ... <code>H[K]</code> into a max-heap.  </p> <pre><code>ElementType FindKthSmallest ( int A[], int N, int K )\n{   /* it is assumed that K&lt;=N */\n    ElementType *H;\n    int i, next, child;\n\n    H = (ElementType*)malloc((K+1)*sizeof(ElementType));\n    for ( i = 1; i &lt;= K; i++ ) H[i] = A[i-1];\n    BuildMaxHeap(H, K);\n\n    for ( next = K; next &lt; N; next++ ) {\n        H[0] = A[next];\n        if ( H[0] &lt; H[1] ) {\n            for ( i = 1; i*2 &lt;= K; i = child ) {\n                child = i*2;\n                if ( child != K &amp;&amp; H[child+1] &gt; H[child] ) child++;\n                if ( H[0] &lt; H[child] )\n                    H[i] = H[child];\n                else break;\n            }\n            H[i] = H[0];\n        }\n    }\n    return H[1];\n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#45-d-heaps-all-nodes-have-d-children","title":"4.5 \\(d\\)-Heaps \u2014 All nodes have \\(d\\) children","text":"<p>Note :</p> <ul> <li>DeleteMin will take \\(d-1\\) comparisons to find the smallest child. Hence the total time complexity would be \\(O(d \\log_d N)\\).</li> <li>2 or /2 is merely a bit shift, but d or /d is not.</li> <li>When the priority queue is too large to fit entirely in main memory, a d-heap will become interesting.</li> </ul> <p></p> <p></p> <p>\u6b63\u786e\u7b54\u6848\u662f4\uff0c\u6ce8\u610f\u201cin the process\u201d</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#5-the-disjoint-set","title":"5 The Disjoint Set","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#51-equivalence-relations","title":"5.1 Equivalence Relations","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#definition-a-relation-r-is-defined-on-a-set-s-if-for-every-pair-of-elements-a-b-a-b-in-s-a-r-b-is-either-true-or-false-if-a-r-b-is-true-then-we-say-that-a-is-related-to-b","title":"[Definition] A relation R is defined on a set S if for every pair of elements (a, b), a, b \\(\\in\\) S, a R b is either true or false.  If a R b is true, then we say that a is related to b.","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#definition-a-relation-over-a-set-s-is-said-to-be-an-equivalence-relation-over-s-if-it-is-symmetric-reflexive-and-transitive-over-s","title":"[Definition] A relation, ~, over a set, S, is said to be an equivalence relation over S if it is symmetric, reflexive, and transitive over S.","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#definition-two-members-x-and-y-of-a-set-s-are-said-to-be-in-the-same-equivalence-class-if-x-y","title":"[Definition] Two members x and y of a set S are said to be in the same equivalence class if x ~ y.","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#52-the-dynamic-equivalence-problem","title":"5.2 The Dynamic Equivalence Problem","text":"<ul> <li>Given an equivalence relation ~, decide for any a and b if a ~ b</li> </ul> <p><code>pseudocode   Algorithm: (Union/Find)   {     /* step 1: read the relations in */       Initialize N disjoint sets;       while ( read in a ~ b )       {         if ( !(Find(a) == Find(b)) )  /*Dynamic(on-line)*/             Union the two sets;       } /* end-while */       /* step 2: decide if a ~ b */       while ( read in a and b )           if ( Find(a) == Find(b) )             output( true );           else                output( false );   }</code></p> <ul> <li> <p>Elements of the sets : \\(1,2,3,\\cdots,N\\)</p> </li> <li> <p>Sets : \\(S_1,S_2,\\cdots\\,and\\,S_i\\bigcap S_j=\\emptyset\\,(if\\quad i\\neq j)\\)</p> </li> <li> <p>Operations :</p> </li> <li> <p>Union( \\(i, j\\) ) = Replace \\(S_i\\) and \\(S_j\\) by \\(S=S_i\\bigcup S_j\\)</p> </li> <li>Find( \\(i\\) ) = Find the set \\(S_k\\) which contains the element \\(i\\)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#53-basic-data-structure","title":"5.3 Basic Data Structure","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#union-i-j","title":"Union( \\(i, j\\) )","text":"<ul> <li> <p>Make \\(S_i\\) a subtree of \\(S_j\\), or vice versa, that is to set the parent pointer of one of the roots to the other root.</p> </li> <li> <p>Implementation 1 :</p> </li> </ul> <p></p> <ul> <li> <p>Implementation 2 :</p> </li> <li> <p>The elements are numbered from 1 to N, hence they can be used as indices of an array.</p> </li> <li> <p>S[ element ] = the element\u2019s parent</p> </li> <li> <p>Note : S[ root ] = 0 and set name = root index</p> </li> <li>\u6570\u7ec4\u521d\u59cb\u5316\u5168\u90e8\u4e3a0</li> </ul> <p><code>c   void SetUnion(DisjSet S, SetType Rt1, SetType Rt2)   {     S[Rt2] = Rt1;   }</code></p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#find-i","title":"Find( \\(i\\) )","text":"<ul> <li>Implementation 1 :</li> </ul> <ul> <li>Implementation 2 :</li> </ul> <p><code>c   SetType Find(ElementType X, DisjSet S)   {     for ( ; S[X]&gt;0; X=S[X]);     return X;   }</code></p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#analysis","title":"Analysis","text":"<ul> <li>Union and find are always paired. Thus we consider the performance of a sequence of union-find operations.</li> </ul> <pre><code>Algorithm using union-find operations:\n{  \n    Initialize Si = { i }  for  i = 1, ..., 12 ;\n    for ( k = 1; k &lt;= 9; k++ )  /* for each pair i R j */\n    {\n        if ( Find( i ) != Find( j ) )\n            SetUnion( Find( i ), Find( j ) );\n    }\n}\n</code></pre> <ul> <li>Worst case : \\(T(N)=\\Theta(N^2)\\)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#54-smart-union-algorithms","title":"5.4 Smart Union Algorithms","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#union-by-size","title":"Union-by-Size","text":"<ul> <li> <p>Always change the smaller tree</p> </li> <li> <p>S[Root] = -size, initialized to be -1</p> </li> <li> <p>[Lemma] Let T be a tree created by union-by-size with N nodes, then \\(height(T)\\leq\\lfloor\\log_2N\\rfloor+1\\).</p> </li> </ul> <p>Proved by induction. Each element can have its set name changed at most \\(\\log_2N\\) times.</p> <ul> <li>Time complexity of \\(N\\) Union and \\(M\\) Find operations is now \\(O(N+M\\log_2N)\\).</li> </ul> <pre><code>/* Assumes Rootl and Root2 are roots*/\nvoid SetUnion(DisjSet S, SetType Root1, SetType Root2)\n{\n    if (S[Root1] &lt;= S[Root2])\n    {\n        S[Root1] += S[Root2];\n        S[Root2] = Root1;\n    }\n    else\n    {\n        S[Root2] += S[Root1];\n        S[Root1] = Root2;\n    }\n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#union-by-height","title":"Union-by-Height","text":"<ul> <li>Always change the shallow tree</li> <li>\u4fdd\u8bc1\u6240\u6709\u7684\u6811\u7684\u6df1\u5ea6\u6700\u591a\u662f\\(O(logN)\\)</li> </ul> <pre><code>/* Assumes Rootl and Root2 are roots*/\nvoid SetUnion(DisjSet S, SetType Root1, SetType Root2)\n{\n    if ( S[Root2] &lt; S[Root1])  /*Root2 is deeper set*/\n        S[Root1] = Root2;      /*Make Root2 new root*/\n    else\n    {\n        if (S[Root1] == S[Root2])  /*Same height*/\n            S[Root1]--;\n        S[Root2] = Root1;\n    }\n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#55-path-compression","title":"5.5 Path Compression","text":"<ul> <li>\u4eceX\u5230Root\u7684\u8def\u5f84\u4e0a\u7684\u6bcf\u4e00\u4e2a\u7ed3\u70b9\u90fd\u4f7f\u5b83\u7684\u7236\u7ed3\u70b9\u53d8\u6210Root</li> </ul> <pre><code>SetType Find( ElementType X, DisjSet S )\n{\n    if ( S[ X ] &lt;= 0 )    \n        return X;\n    else \n        return S[ X ] = Find( S[ X ], S );\n}\n</code></pre> <pre><code>SetType Find( ElementType X, DisjSet S )\n{   \n    ElementType root, trail, lead;\n    for ( root = X; S[ root ] &gt; 0; root = S[ root ] );  /* find the root */\n    for ( trail = X; trail != root; trail = lead )\n    {\n        lead = S[ trail ];   \n        S[ trail ] = root;   \n    }  /* collapsing */\n    return root;\n}\n</code></pre> <ul> <li>Note : Not compatible with union-by-height since it changes the heights.  Just take \u201cheight\u201d as an estimated rank.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#56-worst-case-for-union-by-rank-and-path-compression","title":"5.6 Worst Case for Union-by-Rank and Path Compression","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#lemma-let-tmn-be-the-maximum-time-required-to-process-an-intermixed-sequence-of-mgeq-n-finds-and-n-1-unions-then-k_1malphamnleq-tmnleq-k_2malphamn-for-some-positive-constants-k_1-and-k_2","title":"[Lemma] Let \\(T(M,N)\\) be the maximum time required to process an intermixed sequence of \\(M\\geq N\\) finds and \\(N-1\\) unions, then \\(k_1M\\alpha(M,N)\\leq T(M,N)\\leq k_2M\\alpha(M,N)\\) for some positive constants \\(k_1\\) and \\(k_2\\).","text":"<ul> <li>Ackermann\u2019s Function   $$   A(i,j)=\\left{   \\begin{array}{rcl}   2^j &amp;&amp; {i=1,j\\geq1}\\   A(i-1,2) &amp;&amp; {i\\geq2,j=1}\\   A(i-1,A(i,j-1)) &amp;&amp; {i\\geq2,j\\geq2}\\   \\end{array} \\right.   $$</li> </ul> <p>$$   A(2,4)=2^{2^{2^{2^2}}}=2^{65536}   $$</p> <ul> <li>\\(\\alpha(M,N)=min\\{i\\geq1|A(i,\\lfloor M/N\\rfloor)&gt;\\log N\\}\\leq O(\\log^*N)\\leq4\\)</li> </ul> <p>\\(\\log^*N\\) (inverse Ackermann function) = number of times the logarithm is applied to \\(N\\) until the result \\(\\leq1\\).</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#57-conclusion","title":"5.7 Conclusion","text":"<p>\u4e00\u5171\u6709\u4e94\u79cd\u7b97\u6cd5\uff0c\u6ce8\u610f\u770b\u6e05\u9898\u8bbe</p> <ul> <li> <p>No smart union</p> </li> <li> <p>Union-by-size</p> </li> <li> <p>Union-by-height</p> </li> <li> <p>Union-by-size + Path Compression</p> </li> <li> <p>Union-by-height + Path Compression</p> </li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#6-graph-algorithms","title":"6 Graph Algorithms","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#61-definitions","title":"6.1 Definitions","text":"<ul> <li>\\(G( V, E )\\) where \\(G\\) = graph, \\(V = V( G )\\) = finite nonempty set of vertices, and \\(E = E( G )\\) = finite set of edges.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#undirected-graph","title":"Undirected graph","text":"<ul> <li>\\(( v_i , v_j ) = ( v_j , v_i )\\) = the same edge.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#directed-graphdiagraph","title":"Directed graph(diagraph)","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#restrictions","title":"Restrictions","text":"<ul> <li>Self loop is illegal.</li> <li>Multigraph is not considered.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#complete-graph","title":"Complete graph","text":"<ul> <li>A graph that has the maximum number of edges.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#adjacent","title":"Adjacent","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#subgraph","title":"Subgraph","text":"\\[ G'\\subset G=V(G')\\subseteq V(G) \\&amp;\\&amp; E(G')\\subseteq E(G) \\]"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#path","title":"Path","text":"<ul> <li>Path(\\(\\subset G\\)) from \\(v_p\\) to \\(v_q\\) = \\(\\{v_p,v_{i1},v_{i2},\\cdots,v_{in},v_q\\}\\) such that \\((v_p,v_{i1}),(v_{i1},v_{i2}),\\cdots,(v_{in},v_q)\\) belong to \\(E(G)\\)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#length-of-a-path","title":"Length of a path","text":"<ul> <li>number of edges on the path</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#simple-path","title":"Simple path","text":"<ul> <li>\\(v_{i1},v_{i2},\\cdots,v_{in}\\) are distinct.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#cycle","title":"Cycle","text":"<ul> <li>simple path with \\(v_p=v_q\\)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#connected","title":"Connected","text":"<ul> <li>\\(v_i\\) and \\(v_j\\) in an undirected \\(G\\) are connected if there is a path from \\(v_i\\) to \\(v_j\\) (and hence there is also a path from \\(v_j\\) to \\(v_i\\))</li> <li>An undirected graph \\(G\\) is connected if every pair of distinct \\(v_i\\) and \\(v_j\\) are connected</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#connected-component-of-an-undirected-g","title":"(Connected) Component of an undirected G","text":"<ul> <li>the maximal connected subgraph</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#tree","title":"Tree","text":"<ul> <li>a graph that is connected and acyclic(\u975e\u5faa\u73af\u7684)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#dag","title":"DAG","text":"<ul> <li>a directed acyclic graph</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#strongly-connected-directed-graph-g","title":"Strongly connected directed graph G","text":"<ul> <li>For every pair of \\(v_i\\) and \\(v_j\\) in \\(V( G )\\), there exist directed paths from \\(v_i\\) to \\(v_j\\) and from \\(v_j\\) to \\(v_i\\).  </li> <li>If the graph is connected without direction to the edges, then it is said to be weakly connected</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#strongly-connected-component","title":"Strongly connected component","text":"<ul> <li>the maximal subgraph that is strongly connected</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#degree","title":"Degree","text":"<ul> <li> <p>number of edges incident to v</p> </li> <li> <p>For a directed G, we have in-degree and out-degree.</p> </li> <li> <p>Given G with \\(n\\) vertices and \\(e\\) edges, then   $$   e=(\\sum_{i=0}^{n-1}d_i)/2\\quad where\\quad d_i=degree(v_i)   $$</p> </li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#62-representation-of-graphs","title":"6.2 Representation of Graphs","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#adjacency-matrix","title":"Adjacency Matrix","text":"<p>Note : If G is undirected, then adj_mat[][] is symmetric. Thus we can save space by storing only half of the matrix.</p> <p></p> <ul> <li> <p>This representation wastes space if the graph has a lot of vertices but very few edges.</p> </li> <li> <p>To find out whether or not \\(G\\) is connected, we\u2019ll have to examine all edges. In this case \\(T\\) and \\(S\\) are both \\(O( n^2 )\\).</p> </li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#adjacency-lists","title":"Adjacency Lists","text":"<ul> <li>Replace each row by a linked list</li> </ul> <p>Note : The order of nodes in each list does not matter.</p> <ul> <li>For undirected \\(G\\), \\(S\\) = \\(n\\) heads + \\(2e\\) nodes  = \\((n+2e)\\) ptrs + \\(2e\\) ints</li> <li>Degree(i) = number of nodes in graph[i](if \\(G\\) is undirected)</li> <li>\\(T\\) of examine \\(E(G)\\) = \\(O(n+e)\\)</li> </ul> <p></p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#adjacency-multilists","title":"Adjacency Multilists","text":"<ul> <li>Sometimes we need to mark the edge after examine it, and then find the next edge.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#weighted-edges","title":"Weighted Edges","text":"<ul> <li>adj_mat [ i ] [ j ] = weight</li> <li>adjacency lists / multilists :  add a weight field to the node</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#63-topological-sort","title":"6.3 Topological Sort","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#aov-network","title":"AOV Network","text":"<ul> <li>digraph \\(G\\) in which \\(V( G )\\) represents activities and \\(E( G )\\) represents precedence relations </li> <li>Feasible AOV network must be a directed acyclic graph.</li> <li>\\(i\\)  is a predecessor of \\(j\\) = there is a path from \\(i\\)  to \\(j\\)</li> <li>\\(i\\)  is an immediate predecessor of  \\(j\\) = \\(&lt; i,  j &gt; \\in E( G )\\). Then \\(j\\) is called a successor(immediate successor) of \\(i\\)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#partial-order","title":"Partial order","text":"<ul> <li>a precedence relation which is both transitive and irreflexive </li> </ul> <p>Note : If the precedence relation is reflexive, then there must be an \\(i\\) such that \\(i\\) is a predecessor of \\(i\\).  That is, \\(i\\) must be done before \\(i\\) is started. Therefore if a project is feasible, it must be irreflexive.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#definition-a-topological-order-is-a-linear-ordering-of-the-vertices-of-a-graph-such-that-for-any-two-vertices-i-j-if-i-is-a-predecessor-of-j-in-the-network-then-i-precedes-j-in-the-linear-ordering","title":"[Definition] A topological order is a linear ordering  of the vertices of a graph such that, for any two vertices, \\(i\\), \\(j\\), if \\(i\\) is a predecessor of \\(j\\) in the network then \\(i\\) precedes \\(j\\) in the linear ordering.","text":"<p>Note : The topological orders may not be unique for a network.</p> <pre><code>/*Test an AOV for feasibility, and generate a topological order if possible*/\nvoid Topsort( Graph G )\n{   \n    int Counter;\n    Vertex V, W;\n    for ( Counter = 0; Counter &lt; NumVertex; Counter++ ) \n    {\n        V = FindNewVertexOfDegreeZero( );\n        if ( V == NotAVertex ) \n        {\n            Error ( \u201cGraph has a cycle\u201d );   \n            break;  \n        }\n        TopNum[ V ] = Counter; /* or output V */\n        for ( each W adjacent to V )\n            Indegree[ W ]\u2013\u2013;\n    }\n}\n</code></pre> \\[ T=O(|V|^2) \\] <pre><code>/*Improvment:Keep all the unassigned vertices of degree 0 in a special box (queue or stack)*/\nvoid Topsort( Graph G )\n{   \n    Queue Q;\n    int Counter = 0;\n    Vertex V, W;\n    Q = CreateQueue( NumVertex );  \n    MakeEmpty( Q );\n    for ( each vertex V )\n        if ( Indegree[ V ] == 0 ) Enqueue( V, Q );\n    while ( !IsEmpty( Q ) ) \n    {\n        V = Dequeue( Q );\n        TopNum[ V ] = ++Counter; /* assign next */\n        for ( each W adjacent to V )\n            if (\u2013\u2013Indegree[ W ] == 0 ) Enqueue( W, Q );\n    }  /* end-while */\n    if ( Counter != NumVertex )\n    Error( \u201cGraph has a cycle\u201d );\n    DisposeQueue( Q ); /* free memory */\n}\n</code></pre> \\[ T=O(|V|+|E|) \\]"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#64-shortest-path-algorithms","title":"6.4 Shortest Path Algorithms","text":"<p>Given a digraph \\(G = ( V, E )\\), and a cost function \\(c( e )\\) for \\(e \\in E( G )\\). </p> <p>The length of a path \\(P\\) from source to destination is \\(\\sum_{e_i\\subset P} c(e_i)\\)(also called weighted path length).</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#single-source-shortest-path-problem","title":"Single-Source Shortest-Path Problem","text":"<p>Given as input a weighted graph, \\(G = ( V, E )\\), and a distinguished vertex \\(s\\), find the shortest weighted path from \\(s\\) to every other vertex in \\(G\\).</p> <p>Note: If there is no negative-cost cycle, the shortest path from \\(s\\) to \\(s\\) is defined to be zero.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#unweighted-shortest-path","title":"Unweighted Shortest Path","text":"<ul> <li>Breadth-first search \u5e7f\u5ea6\u4f18\u5148\u904d\u5386</li> </ul> <p>Implementation : </p> <ul> <li>Table[ i ].Dist ::= distance from \\(s\\) to \\(v_i\\)  / initialized to be \\(\\infin\\) except for \\(s\\) /</li> <li>Table[ i ].Known ::= 1 if \\(v_i\\) is checked; or 0 if not</li> <li>Table[ i ].Path ::= for tracking the path   / initialized to be 0 /</li> </ul> <pre><code>void Unweighted( Table T )\n{   \n    int CurrDist;\n    Vertex V, W;\n    for ( CurrDist = 0; CurrDist &lt; NumVertex; CurrDist++ ) \n    {\n        for ( each vertex V )\n            if ( !T[ V ].Known &amp;&amp; T[ V ].Dist == CurrDist ) \n            {\n                T[ V ].Known = true;\n                for ( each W adjacent to V )\n                    if ( T[ W ].Dist == Infinity ) \n                    {\n                        T[ W ].Dist = CurrDist + 1;\n                        T[ W ].Path = V;\n                    } /* end-if Dist == Infinity */\n            } /* end-if !Known &amp;&amp; Dist == CurrDist */\n    }  /* end-for CurrDist */\n}\n</code></pre> <p>The worst case : </p> <p> $$ T(N)=O(|V|^2) $$ Improvement :</p> <pre><code>void Unweighted( Table T )\n{   \n    /* T is initialized with the source vertex S given */\n    Queue Q;\n    Vertex V, W;\n    Q = CreateQueue( NumVertex );\n    MakeEmpty( Q );\n    Enqueue( S, Q ); /* Enqueue the source vertex */\n    while ( !IsEmpty( Q ) ) \n    {\n        V = Dequeue( Q );\n        T[ V ].Known = true; /* not really necessary */\n        for ( each W adjacent to V )\n            if ( T[ W ].Dist == Infinity ) \n            {\n                T[ W ].Dist = T[ V ].Dist + 1;\n                T[ W ].Path = V;\n                Enqueue( W, Q );\n            } /* end-if Dist == Infinity */\n    } /* end-while */\n    DisposeQueue( Q ); /* free memory */\n}\n</code></pre> \\[ T=O(|V|+|E|) \\]"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#weighted-shorted-path","title":"Weighted Shorted Path","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#dijkstras-algorithm","title":"Dijkstra\u2019s Algorithm","text":"<ul> <li>Let S = { \\(s\\) and \\(v_i\\)\u2019s whose shortest paths have been found }</li> <li>For any \\(u\\notin S\\),  define distance [ u ] = minimal length of path { \\(s\\rightarrow(v_i\\in S)\\rightarrow u\\) }.  If the paths are generated in non-decreasing order, then :</li> <li>the shortest path must go through only \\(v_i\\in S\\)</li> <li>Greedy Method : \\(u\\) is chosen so that distance[ u ] = min{ \\(w \\notin S\\) | distance[ w ] }  (If \\(u\\) is not unique, then we may select any of them)</li> <li>if distance[\\(u_1\\)] &lt; distance[\\(u_2\\)] and add \\(u_1\\) into \\(S\\), then distance [ \\(u_2\\) ] may change.  If so, a shorter path from \\(s\\) to \\(u_2\\) must go through \\(u_1\\) and distance [ \\(u_2\\) ] = distance [ \\(u_1\\) ] + length(&lt; \\(u_1\\), \\(u_2\\)&gt;).</li> </ul> <pre><code>typedef int Vertex;\nstruct TableEntry\n{\n    List Header; /*Adjacency list*/\n    int Known;\n    DistType Dist;\n    Vertex Path;\n};\n/*Vertices are numbered from 0*/\n#define NotAVertex (-1)\ntypedef struct TableEntry Table[ NumVertex ];\n</code></pre> <pre><code>void InitTable(Vertex Start, Graph G, Table T)\n{ \n    int i;\n    ReadGraph(G, T); /* Read graph somehow */\n    for(i = 0; i &lt; NumVertex; i++)\n    {\n        T[ i ].Known = False;\n        T[ i ].Dist = Infinity;\n        T[ i ].Path = NotAVertex;\n    }\n    T[ Start ].dist = O;\n}\n</code></pre> <pre><code>/*Print shortest path to V after Dijkstra has run*/\n/*Assume that the path exists*/\nvoid PrintPath(Vertex V, Table T)\n{\n    if (T[ V ].Path != NotAVertex)\n    {\n        PrintPath(T[ V ].Path, T);\n        printf(\" to\") ;\n    }\n    printf(\"%v\", V) ; /* %v is pseudocode * /\n</code></pre> <pre><code>void Dijkstra( Table T )\n{ \n    Vertex V, W;\n    for ( ; ; ) \n    {\n        V = smallest unknown distance vertex;\n        if ( V == NotAVertex ) break; \n        T[ V ].Known = true;\n        for ( each W adjacent to V )\n            if ( !T[ W ].Known ) \n                if ( T[ V ].Dist + Cvw &lt; T[ W ].Dist ) \n                {\n                    Decrease( T[ W ].Dist to T[ V ].Dist + Cvw );\n                    T[ W ].Path = V;\n                } /* end-if update W */\n    } /* end-for( ; ; ) */\n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#implementation-1","title":"Implementation 1","text":"<ul> <li>Simply scan the table to find the smallest unknown distance vertex.\u2014\u2014\\(O(|V|)\\)</li> <li>Good if the graph is dense</li> </ul> \\[ T=O(|V|^2+|E|) \\]"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#implementation-2","title":"Implementation 2","text":"<ul> <li> <p>\u5806\u4f18\u5316</p> </li> <li> <p>Keep distances in a priority queue and call <code>DeleteMin</code> to find the smallest unknown distance vertex.\u2014\u2014\\(O(\\log|V|)\\)</p> </li> <li> <p>\u66f4\u65b0\u7684\u5904\u7406\u65b9\u6cd5</p> </li> <li> <p>Method 1 : <code>DecreaseKey</code>\u2014\u2014\\(O(\\log|V|)\\)</p> <p>\\(T=O(|V|\\log|V|+|E|\\log|V|)=O(|E|\\log|V|)\\)</p> </li> <li> <p>Method 2 : insert W with updated Dist into the priority queue</p> <p>Must keep doing <code>DeleteMin</code> until an unknown vertex emerges</p> <p>\\(T=O(|E|\\log|V|)\\) but requires \\(|E|\\) <code>DeleteMin</code> with <code>|E|</code> space</p> </li> <li> <p>Good if the graph is sparse</p> </li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#improvements","title":"Improvements","text":"<ul> <li>Pairing heap</li> <li>Fibonacci heap</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#graphs-with-negative-edge-costs","title":"Graphs with Negative Edge Costs","text":"<pre><code>void WeightedNegative( Table T )\n{\n    Queue Q;\n    Vertex V, W;\n    Q = CreateQueue (NumVertex );  \n    MakeEmpty( Q );\n    Enqueue( S, Q ); /*Enqueue the source vertex*/\n    while ( !IsEmpty( Q ) ) \n    {\n        V = Dequeue( Q );\n        for ( each W adjacent to V )\n        if ( T[ V ].Dist + Cvw &lt; T[ W ].Dist ) \n        {\n            T[ W ].Dist = T[ V ].Dist + Cvw;\n            T[ W ].Path = V;\n            if ( W is not already in Q )\n                Enqueue( W, Q );\n        } /*end-if update*/\n    } /*end-while */\n    DisposeQueue( Q ); /*free memory*/\n}\n</code></pre> <p>Note : Negative-cost cycle will cause indefinite loop</p> \\[ T=O(|V|\\times|E|) \\]"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#acyclic-graphs","title":"Acyclic Graphs","text":"<ul> <li>If the graph is acyclic, vertices may be selected in topological order since when a vertex is selected, its distance can no longer be lowered without any incoming edges from unknown nodes.</li> <li>\\(T=O(|E|+|V|)\\) and no priority queue is needed.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#aoeactivity-on-edge-networks","title":"AOE(Activity on Edge) Networks","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#all-pairs-shortest-path-problem","title":"All-Pairs Shortest Path Problem","text":"<ul> <li>For all pairs of \\(v_i\\) and \\(v_j\\) ( \\(i\\neq j\\) ), find the shortest path between.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#method-1_1","title":"Method 1","text":"<ul> <li>Use single-source algorithm for \\(|V|\\) times.</li> <li>\\(T=O(|V|^3)\\), works fast on sparse graph.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#method-2_1","title":"Method 2","text":"<ul> <li>\u52a8\u6001\u89c4\u5212</li> <li>\\(O(|V|^3)\\) algorithm given in Chapter 10, works faster on dense graphs.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#65-network-flow-problems","title":"6.5 Network Flow Problems","text":"<ul> <li>Determine the maximum amount of flow that can pass from \\(s\\) to \\(t\\).</li> </ul> <p>Note : Total coming in (\\(v\\)) = Total going out (\\(v\\)) where \\(v \\notin \\{ s, t \\}\\)</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#a-simple-algorithm","title":"A Simple Algorithm","text":"<ul> <li>\u6d41\u56fe\\(G_f\\)\u8868\u793a\u7b97\u6cd5\u7684\u4efb\u610f\u9636\u6bb5\u5df2\u7ecf\u8fbe\u5230\u7684\u6d41\uff0c\u5f00\u59cb\u65f6\\(G_f\\)\u7684\u6240\u6709\u8fb9\u90fd\u6ca1\u6709\u6d41\uff0c\u7b97\u6cd5\u7ec8\u6b62\u65f6\\(G_f\\)\u5305\u542b\u6700\u5927\u6d41</li> <li>\u6b8b\u4f59\u56fe(residual graph)\\(G_r\\)\u8868\u793a\u5bf9\u4e8e\u6bcf\u6761\u8fb9\u8fd8\u80fd\u6dfb\u52a0\u4e0a\u591a\u5c11\u6d41\uff0c\\(G_r\\)\u7684\u8fb9\u53eb\u505a\u6b8b\u4f59\u8fb9(residual edge)</li> </ul> <p>Step 1 : Find any path from \\(s\\) to \\(t\\) in \\(G_r\\) , which is called augmenting path(\u589e\u957f\u901a\u8def).</p> <p>Step 2 : Take the minimum edge on this path as the amount of flow and add to \\(G_f\\).</p> <p>Step 3 : Update \\(G_r\\) and remove the 0 flow edges.</p> <p>Step 4 : If there is a path from \\(s\\) to \\(t\\) in \\(G_r\\) then go to Step 1, or end the algorithm.</p> <ul> <li>Step 1\u4e2d\u521d\u59cb\u9009\u62e9\u7684\u8def\u5f84\u53ef\u80fd\u4f7f\u7b97\u6cd5\u4e0d\u80fd\u627e\u5230\u6700\u4f18\u89e3\uff0c\u8d2a\u5fc3\u7b97\u6cd5\u884c\u4e0d\u901a</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#a-solution","title":"A solution","text":"<ul> <li>allow the algorithm to undo its decisions</li> <li>For each edge \\(( v, w )\\) with flow \\(f_{v, w}\\) in \\(G_f\\), add an edge \\(( w, v )\\) with flow \\(f_{v, w}\\) in \\(G_r\\) .</li> </ul> <p>Note : The algorithm works for \\(G\\) with cycles as well.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#proposition-if-the-edge-capabilities-are-rational-numbers-this-algorithm-always-terminate-with-a-maximum-flow","title":"[Proposition] If the edge capabilities are rational numbers, this algorithm always terminate with a maximum flow.","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#analysis_1","title":"Analysis","text":"<ul> <li> <p>An augmenting path can be found by an unweighted shortest path algorithm.</p> </li> <li> <p>\\(T=O(f|E|)\\) where \\(f\\) is the maximum flow.</p> </li> <li> <p>Always choose the augmenting path that allows the largest increase in flow</p> </li> <li> <p>\u5bf9Dijkstra\u7b97\u6cd5\u8fdb\u884c\u5355\u7ebf(single-line)\u4fee\u6539\u6765\u5bfb\u627e\u589e\u957f\u901a\u8def</p> </li> <li>\\(cap_{max}\\)\u4e3a\u6700\u5927\u8fb9\u5bb9\u91cf</li> <li>\\(O(|E|\\log cap_{max})\\)\u6761\u589e\u957f\u901a\u8def\u5c06\u8db3\u4ee5\u627e\u5230\u6700\u5927\u6d41\uff0c\u5bf9\u4e8e\u589e\u957f\u901a\u8def\u7684\u6bcf\u6b21\u8ba1\u7b97\u9700\u8981\\(O(|E|\\log|V|)\\)\u65f6\u95f4</li> </ul> <p>$$   T=T_{augmentation}\\times T_{find_a_path}\\   =O(|E|\\log cap_{max})\\times O(|E|\\log|V|)\\   =O(|E|^2\\log|V|\\log cap_{max})   $$</p> <ul> <li> <p>Always choose the augmenting path that has the least number of edges</p> </li> <li> <p>\u4f7f\u7528\u65e0\u6743\u6700\u77ed\u8def\u7b97\u6cd5\u6765\u5bfb\u627e\u589e\u957f\u8def\u5f84</p> </li> </ul> <p>$$   T=T_{augmentation}\\times T_{find_a_path}\\   =O(|E||V|)\\times O(|E|)\\   =O(|E|^2|V|)   $$</p> <p>Note : </p> <ul> <li>If every \\(v \\notin \\{ s, t \\}\\) has either a single incoming edge of capacity 1 or a single outgoing edge of capacity 1, then time bound is reduced to \\(O( |E| |V|^{1/2} )\\).</li> <li>The min-cost flow problem is to find, among all maximum flows, the one flow of minimum cost provided that each edge has a cost per unit of flow.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#66-minimum-spanning-tree","title":"6.6 Minimum Spanning Tree","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#definition-a-spanning-tree-of-a-graph-g-is-a-tree-which-consists-of-vg-and-a-subset-of-eg","title":"[Definition] A spanning tree of a graph \\(G\\) is a tree which consists of \\(V(G)\\) and a subset of \\(E(G)\\)","text":"<p>Note :</p> <ul> <li>The minimum spanning tree is a tree since it is acyclic, the number of edges is \\(|V|-1\\)</li> <li>It is minimum for the total cost of edges is minimized.</li> <li>It is spanning because it covers every vertex.</li> <li>A minimum spanning tree exists if \\(G\\) is connected.</li> <li>Adding a non-tree edge to a spanning tree, we obtain a cycle.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#greedy-method","title":"Greedy Method","text":"<p>Make the best decision for each stage, under the following constrains :</p> <ul> <li>we must use only edges within the graph</li> <li>we must use exactly \\(|V|-1\\) edges</li> <li>we may not use edges that would produce a cycle</li> </ul> <ol> <li> <p>Prim\u2019s Algorithm</p> </li> <li> <p>\u5728\u7b97\u6cd5\u7684\u4efb\u4e00\u65f6\u523b\uff0c\u90fd\u53ef\u4ee5\u770b\u5230\u4e00\u4e2a\u5df2\u7ecf\u6dfb\u52a0\u5230\u6811\u4e0a\u7684\u9876\u70b9\u96c6\uff0c\u800c\u5176\u4f59\u9876\u70b9\u5c1a\u672a\u52a0\u5230\u8fd9\u68f5\u6811\u4e2d</p> </li> <li> <p>\u7b97\u6cd5\u5728\u6bcf\u4e00\u9636\u6bb5\u90fd\u53ef\u4ee5\u901a\u8fc7\u9009\u62e9\u8fb9\\((u, v)\\)\uff0c\u4f7f\u5f97\\((u,v)\\)\u7684\u503c\u662f\u6240\u6709\\(u\\) \u5728\u6811\u4e0a\u4f46\\(v\\)\u4e0d\u5728\u6811\u4e0a\u7684\u8fb9\u7684\u503c\u4e2d\u7684\u6700\u5c0f\u8005\uff0c\u800c\u627e\u51fa\u4e00\u4e2a\u65b0\u7684\u9876\u70b9\u5e76\u628a\u5b83\u6dfb\u52a0\u5230\u8fd9\u68f5\u6811\u4e2d</p> </li> <li> <p>Kruskal\u2019s Algorithm</p> </li> <li> <p>\u8fde\u7eed\u5730\u6309\u7167\u6700\u5c0f\u7684\u6743\u9009\u62e9\u8fb9,\uff0c\u5e76\u4e14\u5f53\u6240\u9009\u7684\u8fb9\u4e0d\u4ea7\u751f\u73af\u65f6\u5c31\u628a\u5b83\u4f5c\u4e3a\u53d6\u5b9a\u7684\u8fb9</p> <p><code>pseudocode  void Kruskal( Graph G )  {        T = { };      while ( T contains less than |V|-1 edges &amp;&amp; E is not empty )       {          choose a least cost edge (v, w) from E;  /*DeleteMin*/          delete (v, w) from E;          if ( (v, w) does not create a cycle in T )                  add (v, w) to T;  /*Union/Find*/          else                  discard (v, w);      }      if ( T contains fewer than |V|-1 edges )         Error( \u201cNo spanning tree\u201d );  }</code></p> <p>```c  void Kruskal(Graph G)  {     int EdgesAccepted;     DisjSet S;     PriorityQueue H;     Vertex U, V;     SetType Uset, Vset;     Edge E;</p> <pre><code>Initialize(S);\nReadGraphIntoHeapArray(G, H);\nBuildHeap(H);\n\nEdgesAccepted = 0;\nwhile(EdgesAccepted &lt; NumVertex-1)\n{\n    E = DeleteMin(H); /*E = (U,V)*/\n    Uset = Find(U, S);\n    Vset = Find(V, S);\n    if(Uset != Vset)\n    {\n        /*Accept the edge*/\n        EdgesAccepted++;\n        SetUnion(S, USet, VSet);\n    }\n}\n</code></pre> <p>}  ```</p> <p>$$  T=O(|E|\\log|E|)  $$</p> <p></p> </li> </ol>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#67-applications-of-depth-first-search","title":"6.7 Applications of Depth-First Search","text":"<pre><code>/*a generalization of preorder traversal*/\nvoid DFS(Vertex V)\n{   \n    visited[ V ] = true;  /*mark this vertex to avoid cycles*/\n    for ( each W adjacent to V )\n        if ( !visited[ W ] ) DFS( W );\n} /*T = O(|E|+|V|) as long as adjacency lists are used*/\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#undirected-graphs","title":"Undirected Graphs","text":"<pre><code>void ListComponents(Graph G)\n{   \n    for ( each V in G ) \n        if ( !visited[ V ] ) \n        {\n            DFS( V );\n            printf(\"\\n\");\n        }\n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#biconnectivity","title":"Biconnectivity","text":"<ul> <li>\\(v\\) is an articulation point if \\(G'=DeleteVertex(G, v)\\) has at least 2 connected components.</li> <li>\\(G\\) is a biconnected graph if \\(G\\) is connected and has no articulation points.</li> <li>A biconnected component is a maximal biconnected subgraph.</li> </ul> <p>Note : No edges can be shared by two or more biconnected components.  Hence \\(E(G)\\) is partitioned by the biconnected components of \\(G\\).</p> <p>Finding the biconnected components of a connected undirected \\(G\\) :</p> <ul> <li>Use depth first search to obtain a spanning tree of \\(G\\)</li> </ul> <p></p> <p></p> <ul> <li>Depth first number(\\(Num\\)) \u5148\u5e8f\u7f16\u53f7</li> <li>Back edges(\u80cc\u5411\u8fb9) = \\((u,v)\\notin\\) tree and \\(u\\) is an ancestor of \\(v\\).</li> </ul> <p>Note : If \\(u\\) is an ancestor of \\(v\\), then \\(Num(u)&lt;Num(v)\\).</p> <ul> <li> <p>Find the articulation points in \\(G\\)</p> </li> <li> <p>The root is an articulation point if it has at least 2 children.</p> </li> <li>Any other vertex \\(u\\) is an articulation point if \\(u\\) has at least 1 child, and it is impossible to move down at least 1 step and then jump up to \\(u\\)\u2018s ancestor</li> </ul> <ul> <li>\u5bf9\u4e8e\u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u751f\u6210\u6811\u4e0a\u7684\u6bcf\u4e00\u4e2a\u9876\u70b9\\(u\\)\uff0c\u8ba1\u7b97\u7f16\u53f7\u6700\u4f4e\u7684\u9876\u70b9\uff0c\u79f0\u4e4b\u4e3a\\(Low(u)\\)   $$   Low(u)=\\min{Num(u),\\min{Low(w)|w\\,is\\,a\\,child\\,of\\,u},\\min{Num(w)|(u,w)\\,is\\,a\\,back\\,edge}}   $$</li> </ul> <pre><code>/*Assign Num and compute Parents*/\nvoid AssignNum(Vertex V)\n{\n    Vertex W;\n    Num[V] = Counter++;\n    Visited[V] = True;\n    for each W adjacent to V\n        if(!Visited[W])\n        {\n            Parent[W] = V;\n            AssignNum(W);\n        }\n}\n</code></pre> <pre><code>/*Assign Low; also check for articulation points*/\nvoid AssignLow(Vertex V)\n{\n    Vertex W;\n    Low[V] = Num[V]; /*Rule 1*/\n    for each W adjacent to V\n    {\n        if(Num[W] &gt; Num[V]) /*Forward edge*/\n        {\n            Assignlow(W);\n            if(Low[W] &gt;= Num[V])\n                printf(\"%v is an articulation point\\n\", v);\n            Low[V] = Min(Low[V], Low[W]); /*Rule 3*/\n        }\n        else\n            if (Parent[V] != W) /*Back edge*/\n                Low[V] \uff1d Min(Low[V], Num[W]); /*Rule 2*/\n    }\n}\n</code></pre> <pre><code>void FindArt(Vertex V)\n{\n    Vertex W;\n    Visited[V] = True;\n    Low[V] = Num[V] = Counter++; /*Rule 1*/\n    for each W adjacent to V\n    {\n        if(!Visited[W]) /*Forward edge*/\n        {\n            Parent[W] = V;\n            FindArt(W);\n            if(Low[W] &gt;= Num[V])\n                printf(\"%v is an articulation point\\n\", v);\n            Low[V] = Min(Low[V], Low[W]); /*Rule 3*/\n        }\n        else\n            if(Parent[ V ] != W) /*Back edge*/\n                Low[V] = Min(Low[V], Num[W]); /*Rule 2*/\n    }\n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#euler-circuits","title":"Euler Circuits","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#proposition-an-euler-circuit-is-possible-only-if-the-graph-is-connected-and-each-vertex-has-an-even-degree","title":"[Proposition] An Euler circuit is possible only if the graph is connected and each vertex has an even degree.","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#proposition-an-euler-tour-is-possible-if-there-are-exactly-two-vertices-having-odd-degree-one-must-start-at-one-of-the-odd-degree-vertices","title":"[Proposition] An Euler tour is possible if there are exactly two vertices having odd degree.  One must start at one of the odd-degree vertices.","text":"<p>Note:</p> <ul> <li>The path should be maintained as a linked list.</li> <li>For each adjacency list, maintain a pointer to the last edge scanned.</li> <li>\\(T=O(|E|+|V|)\\)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#7-sorting","title":"7 Sorting","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#71-preliminaries","title":"7.1 Preliminaries","text":"<pre><code>void X_Sort (ElementType A[], int N)\n</code></pre> <ul> <li>N must be a legal integer.</li> <li>Assume integer array for the sake of simplicity.</li> <li>\u2018&gt;\u2019 and \u2018&lt;\u2019 operators exist and are the only operations allowed on the input data.</li> <li>Consider internal sorting only. The entire sort can be done in main memory.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#72-insertion-sort","title":"7.2 Insertion Sort","text":"<pre><code>void Insertion(ElementType A[], int N)\n{ \n    int j, P; \n    ElementType Tmp; \n\n    for ( P = 1; P &lt; N; P++ ) \n    { \n        Tmp = A[ P ];  /*the next coming card*/\n        for ( j = P; j &gt; 0 &amp;&amp; A[ j - 1 ] &gt; Tmp; j-- ) \n            A[ j ] = A[ j - 1 ]; \n            /*shift sorted cards to provide a position for the new coming card*/\n        A[ j ] = Tmp;  /*place the new card at the proper position*/\n    }/*end for-P-loop*/\n}\n</code></pre> <ul> <li> <p>The worst case : Input A[ ] is in reverse order   $$   T(N)=O(N^2)   $$</p> </li> <li> <p>The best case : Input A[ ] is in sorted order   $$   T(N)=O(N)   $$</p> </li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#73-a-lower-bound-for-simple-sorting-algorithms","title":"7.3 A Lower Bound for Simple Sorting Algorithms","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#definition-an-inversion-in-an-array-of-numbers-is-any-ordered-pairij-having-the-property-that-ij-but-aiaj","title":"[Definition] An inversion in an array of numbers is any ordered pair\\((i,j)\\) having the property that \\(i&lt;j\\) but \\(A[i]&gt;A[j]\\)","text":"<ul> <li> <p>Swapping two adjacent elements that are out of place removes exactly one inversion.</p> </li> <li> <p>\\(T(N,I)=O(I+N)\\) where \\(I\\) is the number of inversions in the original array.</p> </li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#theorem-the-average-number-of-inversions-in-an-array-of-n-distinct-numbers-is-nn-14","title":"[Theorem] The average number of inversions in an array of \\(N\\) distinct numbers is \\(N(N-1)/4\\)","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#theorem-any-algorithm-that-sorts-by-exchanging-adjacent-elements-requires-omegan2-time-on-average","title":"[Theorem] Any algorithm that sorts by exchanging adjacent elements requires \\(\\Omega(N^2)\\) time on average","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#74-shellsort","title":"7.4 Shellsort","text":"<ul> <li>Define an increment sequence \\(h_1 &lt; h_2 &lt; \\cdots &lt; h_t  ( h_1 = 1 )\\)</li> <li> <p>Define an \\(h_k\\)-sort at each phase for \\(k = t, t - 1,\\cdots, 1\\)</p> </li> <li> <p>\u6700\u540e\u4e00\u8f6e\u5c31\u662fInsertion Sort</p> </li> </ul> <p>Note : An \\(h_k\\)-sorted file that is then \\(h_{k-1}\\)-sorted remains \\(h_k\\)-sorted.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#shells-increment-sequence","title":"Shell\u2019s Increment Sequence","text":"\\[ h_t=\\lfloor N/2\\rfloor,h_k=\\lfloor h_{k+1}/2\\rfloor \\] <pre><code>void Shellsort( ElementType A[ ], int N ) \n{ \n    int i, j, Increment; \n    ElementType Tmp; \n    for ( Increment = N / 2; Increment &gt; 0; Increment /= 2 )  /*h sequence */\n        for ( i = Increment; i &lt; N; i++ ) \n        { /* insertion sort */\n            Tmp = A[ i ]; \n            for ( j = i; j &gt;= Increment; j -= Increment ) \n                if( Tmp &lt; A[ j-Increment ] )\n                    A[ j ] = A[ j-Increment ]; \n                else \n                    break; \n            A[ j ] = Tmp;\n        } /* end for-I and for-Increment loops */\n}\n</code></pre> <ul> <li>[Theorem] The worst-case running time of Shellsort, using Shell\u2019s increments, is  \\(\\Theta( N^2 )\\).</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#hibbards-increment-sequence","title":"Hibbard's Increment Sequence","text":"\\[ h_k=2^k-1 \\] <ul> <li>[Theorem] The worst-case running time of Shellsort, using Hibbard's increments, is  \\(\\Theta( N^{3/2} )\\).</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#conjecture","title":"Conjecture","text":"<ul> <li>\\(T_{avg \u2013 Hibbard} ( N ) = O ( N^{5/4} )\\)</li> <li>Sedgewick\u2019s best sequence is \\(\\{1, 5, 19, 41, 109, \\cdots \\}\\) in which the terms are either of the form \\(9\\times4^i \u2013 9\\times2^i + 1\\) or    \\(4^i \u2013 3\\times2^i + 1\\).  \\(T_{avg} ( N ) = O ( N^{7/6} )\\) and \\(T_{worst}( N ) = O( N^{4/3} )\\).</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#conclusion","title":"Conclusion","text":"<ul> <li>Shellsort is a very simple algorithm, yet with an extremely complex analysis.  </li> <li>It is good for sorting up to moderately large input (tens of thousands).</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#75-heapsort","title":"7.5 Heapsort","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#algorithm1","title":"Algorithm1","text":"<pre><code>void Heapsort( int N ) \n{\n    BuildHeap( H );\n    for ( i = 0; i &lt; N; i++ ) \n        TmpH[ i ] = DeleteMin( H );\n    for ( i = 0; i &lt; N; i++ ) \n        H[ i ] = TmpH[ i ];\n}\n</code></pre> \\[ T(N)=O(N\\log N) \\] <ul> <li>The space requirement is doubled.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#algorithm2","title":"Algorithm2","text":"<pre><code>void Heapsort( ElementType A[ ], int N ) \n{\n    int i; \n    for ( i = N / 2; i &gt;= 0; i-- ) /*BuildHeap*/ \n        PercDown( A, i, N );\n    for ( i = N - 1; i &gt; 0; i-- ) \n    { \n        Swap( &amp;A[ 0 ], &amp;A[ i ] ); /*DeleteMax*/ \n        PercDown( A, 0, i ); \n    } \n}\n</code></pre> <ul> <li>[Theorem] The average number of comparisons used to heapsort a random permutation of N distinct items is \\(2N\\log N-O(N\\log\\log N)\\).</li> </ul> <p>Note : Although Heapsort gives the best average time, in practice it is slower than a version of Shellsort that uses Sedgewick\u2019s increment sequence.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#76-mergesort","title":"7.6 Mergesort","text":"<pre><code>void MSort( ElementType A[ ], ElementType TmpArray[ ], int Left, int Right ) \n{   \n    int Center; \n    if ( Left &lt; Right ) \n    {  /*if there are elements to be sort*/\n        Center = (Left+Right)/2; \n        MSort(A, TmpArray, Left, Center);   /*T(N/2)*/\n        MSort(A, TmpArray, Center+1, Right);    /*T(N/2)*/\n        Merge(A, TmpArray, Left, Center+1, Right);  /*O(N)*/\n    } \n} \n\nvoid Mergesort( ElementType A[ ], int N ) \n{   \n    ElementType *TmpArray;  /*need O(N) extra space*/\n    TmpArray = malloc(N*sizeof(ElementType)); \n    if (TmpArray != NULL) \n    { \n        MSort(A, TmpArray, 0, N-1); \n        free(TmpArray); \n    } \n    else FatalError(\"No space for tmp array!!!\"); \n}\n</code></pre> <ul> <li>If a TmpArray is declared locally for each call of Merge, then \\(S(N) = O(N\\log N)\\).</li> </ul> <pre><code>/*Lpos = start of left half, Rpos = start of right half*/ \nvoid Merge( ElementType A[ ], ElementType TmpArray[ ], int Lpos, int Rpos, int RightEnd ) \n{   \n    int i, LeftEnd, NumElements, TmpPos; \n    LeftEnd = Rpos-1; \n    TmpPos = Lpos; \n    NumElements = RightEnd-Lpos+1; \n    while( Lpos &lt;= LeftEnd &amp;&amp; Rpos &lt;= RightEnd ) /*main loop*/ \n        if ( A[ Lpos ] &lt;= A[ Rpos ] ) \n            TmpArray[ TmpPos++ ] = A[ Lpos++ ]; \n        else \n            TmpArray[ TmpPos++ ] = A[ Rpos++ ]; \n    while( Lpos &lt;= LeftEnd ) /*Copy rest of first half*/ \n        TmpArray[ TmpPos++ ] = A[ Lpos++ ]; \n    while( Rpos &lt;= RightEnd ) /*Copy rest of second half*/ \n        TmpArray[ TmpPos++ ] = A[ Rpos++ ]; \n    for( i = 0; i &lt; NumElements; i++, RightEnd-- ) \n        /*Copy TmpArray back*/ \n        A[ RightEnd ] = TmpArray[ RightEnd ]; \n}\n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#analysis_2","title":"Analysis","text":"\\[ T(1)=O(1)\\\\ T(N)=2T(\\frac{N}{2})+O(N)\\\\ \\frac{T(N)}{N}=\\frac{T(\\frac{N}{2})}{\\frac{N}{2}}+1\\\\ \\cdots\\\\ \\frac{T(\\frac{N}{2^{k-1}})}{\\frac{N}{2^{k-1}}}=\\frac{T(1)}{1}+1\\\\ T(N)=O(N+N\\log N) \\] <p>Note : Mergesort requires linear extra memory, and copying an array is slow. It is hardly ever used for internal sorting, but is quite useful for external sorting.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#77-quicksort","title":"7.7 Quicksort","text":"<ul> <li>the fastest known sorting algorithm in practice</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#algorithm","title":"Algorithm","text":"<pre><code>void Quicksort( ElementType A[ ], int N )\n{\n    if (N &lt; 2) return;\n    pivot = pick any element in A[ ]; \n    Partition S = { A[ ] \\ pivot } into two disjoint sets:\n        A1 = { a in S | a &lt;= pivot } and A2 = { a in S | a &gt;= pivot };\n    A = Quicksort(A1, N1) and { pivot } and Quicksort(A2, N2);\n}\n</code></pre> <ul> <li>The pivot is placed at the right place once and for all.</li> <li>\u8981\u7814\u7a76\u7684\u95ee\u9898\u662f\u5982\u4f55\u9009\u53d6\u67a2\u7ebd\u5143\u548c\u5982\u4f55\u5212\u5206</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#picking-the-pivot","title":"Picking the Pivot","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#a-wrong-way","title":"A Wrong Way","text":"<ul> <li>Pivot = A[ 0 ]</li> <li>The worst case : A[ ] is presorted, quicksort will take \\(O(N^2)\\) time to do nothing</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#a-safe-maneuver","title":"A Safe Maneuver","text":"<ul> <li>Pivot = random select from A[ ]</li> <li>random number generation is expensive</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#median-of-three-partitioning","title":"Median-of-Three Partitioning","text":"<ul> <li>Pivot = median(left, center, right)</li> <li>Eliminates the bad case for sorted input and actually reduces the running time by about 5%.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#partitioning-strategy","title":"Partitioning Strategy","text":"<ul> <li>\u5f53\\(i\\)\u5728\\(j\\)\u7684\u5de6\u8fb9\u65f6\uff0c\u6211\u4eec\u5c06\\(i\\)\u53f3\u79fb\uff0c\u79fb\u8fc7\u90a3\u4e9b\u5c0f\u4e8e\u67a2\u7ebd\u5143\u7684\u5143\u7d20\uff0c\u5e76\u5c06\\(j\\)\u5de6\u79fb\uff0c\u79fb\u8fc7\u90a3\u4e9b\u5927\u4e8e\u67a2\u7ebd\u5143\u7684\u5143\u7d20</li> <li>\u5f53\\(i\\)\u548c\\(j\\)\u505c\u6b62\u65f6\uff0c\\(i\\)\u6307\u5411\u4e00\u4e2a\u5927\u5143\u7d20\u800c\\(j\\)\u6307\u5411\u4e00\u4e2a\u5c0f\u5143\u7d20\uff0c\u5982\u679c\\(i\\)\u5728\\(j\\)\u7684\u5de6\u8fb9\uff0c\u90a3\u4e48\u5c06\u8fd9\u4e24\u4e2a\u5143\u7d20\u4e92\u6362</li> <li>\u91cd\u590d\u8be5\u8fc7\u7a0b\u76f4\u5230\\(i\\)\u548c\\(j\\)\u5f7c\u6b64\u4ea4\u9519\u4e3a\u6b62</li> <li>\u5212\u5206\u7684\u6700\u540e\u4e00\u6b65\u662f\u5c06\u67a2\u7ebd\u5143\u4e0e\\(i\\)\u6240\u6307\u5411\u7684\u5143\u7d20\u4ea4\u6362</li> <li>\u5982\u679c\\(i\\)\u548c\\(j\\)\u9047\u5230\u7b49\u4e8e\u67a2\u7ebd\u5143\u7684\u952e\u503c\uff0c\u5c31\u8ba9\\(i\\)\u548c\\(j\\)\u90fd\u505c\u6b62\uff0c\u56e0\u4e3a\u82e5\u90fd\u4e0d\u505c\u6b62\\(T(N)=O(N^2)\\)</li> <li>There will be many dummy swaps, but at least the sequence will be partitioned into two equal-sized subsequences.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#small-arrays","title":"Small Arrays","text":"<ul> <li>Quicksort is slower than insertion sort for small \\(N(\\leq 20)\\).</li> <li>Cutoff when \\(N\\) gets small and use other efficient algorithms (such as insertion sort).</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#implementation","title":"Implementation","text":"<pre><code>void Quicksort( ElementType A[ ], int N ) \n{ \n    Qsort( A, 0, N-1 ); \n    /*A:the array*/\n    /*0:Left index*/\n    /*N\u20131:Right index*/\n}\n</code></pre> <pre><code>/* Return median of Left, Center, and Right */ \n/* Order these and hide the pivot */ \nElementType Median3( ElementType A[ ], int Left, int Right ) \n{\n    int Center = ( Left+Right )/2; \n    if ( A[ Left ] &gt; A[ Center ] ) \n        Swap( &amp;A[ Left ], &amp;A[ Center ] ); \n    if ( A[ Left ] &gt; A[ Right ] ) \n        Swap( &amp;A[ Left ], &amp;A[ Right ] ); \n    if ( A[ Center ] &gt; A[ Right ] ) \n        Swap( &amp;A[ Center ], &amp;A[ Right ] ); \n    /*Invariant: A[ Left ] &lt;= A[ Center ] &lt;= A[ Right ]*/ \n    Swap( &amp;A[ Center ], &amp;A[ Right-1 ] ); /*Hide pivot*/ \n    /*only need to sort A[ Left+1 ] \u2026 A[ Right\u20132 ]*/\n    return A[ Right-1 ];  /*Return pivot*/ \n}\n</code></pre> <pre><code>void Qsort( ElementType A[ ], int Left, int Right ) \n{\n    int i, j; \n    ElementType Pivot; \n    if ( Left + Cutoff &lt;= Right ) \n    {   /*if the sequence is not too short*/\n        Pivot = Median3( A, Left, Right );  /*select pivot*/\n        i = Left;     \n        j = Right \u2013 1;  /*why not set Left+1 and Right-2?*/\n        for( ; ; ) \n        { \n            while ( A[ ++i ] &lt; Pivot ) { }  /*scan from left*/\n            while ( A[ --j ] &gt; Pivot ) { }  /*scan from right*/\n            if ( i &lt; j ) \n                Swap( &amp;A[ i ], &amp;A[ j ] );  /*adjust partition*/\n            else break;  /*partition done*/\n        } \n        Swap( &amp;A[ i ], &amp;A[ Right-1 ] ); /*restore pivot */ \n        Qsort( A, Left, i-1 );    /*recursively sort left part*/\n        Qsort( A, i+1, Right );   /*recursively sort right part*/\n    }  /*end if - the sequence is long*/\n    else /*do an insertion sort on the short subarray*/ \n        InsertionSort( A+Left, Right-Left+1 );\n}\n</code></pre> <p>Note : If set i = Left+1 and j = Right-2, there will be an infinite loop if A[i] = A[j] = pivot.</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#analysis_3","title":"Analysis","text":"\\[ T(N)=T(i)+T(N-i-1)+cN \\] <ul> <li> <p>\\(i\\) is the number of the elements in \\(S_1\\).</p> </li> <li> <p>The Worst Case   $$   T(N)=T(N-1)+cN   $$</p> </li> </ul> <p>$$   T(N-1)=T(N-2)+c(N-1)   $$</p> <p>$$   \\cdots   $$</p> <p>$$   T(2)=T(1)+2c   $$</p> <p>$$   T(N)=T(1)+c\\sum^N_{i=2}i=O(N^2)   $$</p> <ul> <li>The Best Case   $$   T(N)=2T(N/2)+cN   $$</li> </ul> <p>$$   \\frac{T(N)}{N}=\\frac{T(N/2)}{N/2}+c   $$</p> <p>$$   \\frac{T(N/2)}{N/2}=\\frac{T(N/4)}{N/4}+c   $$</p> <p>$$   \\cdots   $$</p> <p>$$   \\frac{T(2)}{2}=\\frac{T(1)}{1}+c   $$</p> <p>$$   \\frac{T(N)}{N}=\\frac{T(1)}{1}+c\\log N\\frac{T(N)}{N}=\\frac{T(1)}{1}+c\\log N   $$</p> <p>$$   T(N)=cN\\log N+N=O(N\\log N)   $$</p> <ul> <li> <p>The Average Case</p> </li> <li> <p>Assume the average value of \\(T( i )\\) for any \\(i\\) is \\(\\frac{1}{N}\\left[\\sum^{N-1}_{j=0}T(j)\\right]\\)     $$     T(N)=\\frac{2}{N}\\left[\\sum^{N-1}_{j=0}T(j)\\right]+cN     $$</p> </li> </ul> <p>$$   NT(N)=2\\left[\\sum^{N-1}_{j=0}T(j)\\right]+cN^2   $$</p> <p>$$   (N-1)T(N-1)=2\\left[\\sum^{N-2}_{j=0}T(j)\\right]+c(N-1)^2   $$</p> <p>$$   NT(N)-(N-1)T(N-1)=2T(N-1)+2cN-c   $$</p> <p>$$   NT(N)=(N+1)T(N-1)+2cN   $$</p> <p>$$   \\frac{T(N)}{N+1}=\\frac{T(N-1)}{N}+\\frac{2c}{N+1}   $$</p> <p>$$   \\frac{T(N-1)}{N}=\\frac{T(N-2)}{N-1}+\\frac{2c}{N}   $$</p> <p>$$   \\cdots   $$</p> <p>$$   \\frac{T(2)}{3}=\\frac{T(1)}{2}+\\frac{2c}{3}   $$</p> <p>$$   \\frac{T(N)}{N+1}=\\frac{T(1)}{2}+2c\\sum^{N+1}_{i=3}\\frac{1}{i}   $$</p> <p>$$   T(N)=O(N\\log N)   $$</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#quickselect","title":"Quickselect","text":"<ul> <li>\u67e5\u627e\u7b2c\\(K\\)\u6700\u5927(\u6700\u5c0f)\u5143</li> </ul> <pre><code>/*Places the kth sma11est element in the kth position*/\n/*Because arrays start at 0, this will be index k-1*/\nvoid Qselect(ElementType A[ ], int k, int Left, int Right)\n{\n    int i, j;\n    ElementType Pivot;\n\n    if (Left + Cutoff &lt;= Right)\n    {\n        Pivot = Median3(A, Left, Right);\n        i = Left; \n        j = Right-1;\n        for( ; ; )\n        {\n            while(A[ ++i ] &lt; Pivot){ }\n            while(A[ --j ] &gt; Pivot){ }\n            if(i &lt; j)\n                Swap(&amp;A[ i ], &amp;A[ j ]);\n            else\n                break;\n        }\n        Swap(&amp;A[ i ], &amp;A[ Right-1 ]); /*Restore pivot*/\n\n        if(k &lt;= i)\n            Qselect(A, k, Left, i-1);\n        else if (k &gt; i+1)\n            Qselect(A, k, i+1, Right);\n    }\n    else /*Doan insertion sort on the subarray*/\n        InsertionSort(A+Left, Right-Left+1);\n}\n</code></pre> <p>\u6b63\u786e\u7b54\u6848\u662fD</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#78-sorting-large-structures","title":"7.8 Sorting Large Structures","text":"<ul> <li>Swapping large structures can be very much expensive.</li> <li>Add a pointer field to the structure and swap pointers instead \u2013 indirect sorting. Physically rearrange the structures at last if it is really necessary.</li> <li>Table Sort</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#79-a-general-lower-bound-for-sorting","title":"7.9 A General Lower Bound for Sorting","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#theorem-any-algorithm-that-sorts-by-comparisons-only-must-have-a-worst-case-computing-time-of-omeganlog-n","title":"[Theorem] Any algorithm that sorts by comparisons only must have a worst case computing time of \\(\\Omega(N\\log N)\\).","text":"<ul> <li>When sorting \\(N\\) distinct elements, there are \\(N!\\) different possible results.</li> <li>Thus any decision tree must have at least \\(N!\\) leaves.</li> <li>If the height of the tree is \\(k\\), then \\(N! \\leq 2^{k-1}\\rarr k\\geq\\log(N!)+1\\) </li> <li>Since \\(N!\\geq (N/2)^{N/2}\\) and \\(\\log_2N!\\geq(N/2)\\log_2(N/2) = \\Theta(N\\log_2N )\\)</li> <li>Therefore \\(T(N)=k\\geq c\\cdot N\\log_2 N\\)</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#710-bucket-sort","title":"7.10 Bucket Sort","text":"<pre><code>Algorithm\n{\n    initialize count[ ];\n    while(read in a student\u2019s record)\n        insert to list count[stdnt.grade];\n    for(int i = 0; i &lt; M; i++) \n    {\n        if(count[i]) output list count[i];\n    }\n}\n</code></pre> \\[ T(N,M)=O(M+N) \\]"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#711-radix-sort","title":"7.11 Radix Sort","text":"<ul> <li>\\(T=O(P(N+B))\\) where \\(P\\) is the number of passes, \\(N\\) is the number of elements to sort, and \\(B\\) is the number of buckets.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#msdmost-significant-digit-sort-and-lsdleast-significant-digit-sort","title":"MSD(Most Significant Digit) Sort and LSD(Least Significant Digit) Sort","text":"<ul> <li>\u7a33\u5b9a\u7684\u6392\u5e8f\u7b97\u6cd5\uff1a\u5192\u6ce1\u6392\u5e8f\u3001\u63d2\u5165\u6392\u5e8f\u3001\u5f52\u5e76\u6392\u5e8f\u3001\u57fa\u6570\u6392\u5e8f</li> <li>\u4e0d\u7a33\u5b9a\u7684\u6392\u5e8f\u7b97\u6cd5\uff1a\u9009\u62e9\u6392\u5e8f\u3001\u5feb\u901f\u6392\u5e8f\u3001\u5e0c\u5c14\u6392\u5e8f\u3001\u5806\u6392\u5e8f</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#8-hashing","title":"8 Hashing","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#81-general-idea","title":"8.1 General Idea","text":""},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#symbol-table-adt","title":"Symbol Table ADT","text":"<ul> <li>Objects : A set of name-attribute pairs, where the names are unique</li> <li>Operations :</li> <li>SymTab Create(TableSize) </li> <li>Boolean IsIn(symtab, name)</li> <li>Attribute  Find(symtab, name) </li> <li>SymTab  Insert(symtab, name, attr)</li> <li>SymTab  Delete(symtab, name) </li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#hash-tables","title":"Hash Tables","text":"<ul> <li>A collision occurs when we hash two nonidentical identifiers into the same bucket.</li> <li>An overflow occurs when we hash a new identifier into a full bucket.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#82-hash-function","title":"8.2 Hash Function","text":"<ul> <li>\\(f(x)\\) must be easy to compute and minimize the number of collisions.</li> <li>\\(f(x)\\) should be unbiased. For any \\(x\\) and any \\(i\\), we have that \\(Probability(f(x)=i)=\\frac{1}{b}\\). Such kind of a hash function is called a uniform hash function.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#83-separate-chaining","title":"8.3 Separate Chaining","text":"<ul> <li>keep a list of all keys that hash to the same value</li> </ul> <pre><code>struct ListNode; \ntypedef struct ListNode *Position; \nstruct HashTbl; \ntypedef struct HashTbl *HashTable; \nstruct ListNode { \n    ElementType Element; \n    Position Next; \n}; \ntypedef Position List; \n/* List *TheList will be an array of lists, allocated later */ \n/* The lists use headers (for simplicity), */ \n/* though this wastes space */ \nstruct HashTbl { \n    int TableSize; \n    List *TheLists; \n}; \n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#create-an-empty-table","title":"Create an empty table","text":"<pre><code>HashTable InitializeTable( int TableSize ) \n{   \n    HashTable H; \n    int i; \n    if ( TableSize &lt; MinTableSize ) \n    { \n        Error( \"Table size too small\" );  \n        return NULL;  \n    } \n    H = malloc( sizeof( struct HashTbl ) );  /*Allocate table*/\n    if ( H == NULL ) FatalError( \"Out of space!!!\" ); \n    H-&gt;TableSize = NextPrime( TableSize );  /*Better be prime*/\n    H-&gt;TheLists = malloc( sizeof( List )* H-&gt;TableSize );  /*Array of lists*/\n    if ( H-&gt;TheLists == NULL ) FatalError( \"Out of space!!!\" );\n    H-&gt;TheList = malloc(H-&gt;TableSize*sizeof(struct ListNode));\n    for( i = 0; i &lt; H-&gt;TableSize; i++ ) \n    {   /*Allocate list headers*/\n        //H-&gt;TheLists[ i ] = malloc( sizeof( struct ListNode ) ); /* Slow! */\n        if ( H-&gt;TheLists[ i ] == NULL ) FatalError( \"Out of space!!!\" ); \n        else H-&gt;TheLists[ i ]-&gt;Next = NULL;\n    } \n    return H; \n} \n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#find-a-key-from-a-hash-table","title":"Find a key from a hash table","text":"<pre><code>Position Find ( ElementType Key, HashTable H ) \n{ \n    Position P; \n    List L; \n    L = H-&gt;TheLists[ Hash( Key, H-&gt;TableSize ) ]; \n    P = L-&gt;Next; \n    while( P != NULL &amp;&amp; P-&gt;Element != Key )  /*Probably need strcmp*/ \n        P = P-&gt;Next; \n    return P; \n} \n</code></pre>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#insert-a-key-into-a-hash-table","title":"Insert a key into a hash table","text":"<pre><code>void Insert ( ElementType Key, HashTable H ) \n{ \n    Position Pos, NewCell; \n    List L; \n    Pos = Find( Key, H ); \n    if ( Pos == NULL ) \n    {   /*Key is not found, then insert*/\n        NewCell = malloc( sizeof( struct ListNode ) ); \n        if ( NewCell == NULL ) FatalError( \"Out of space!!!\" ); \n        else \n        { \n            L = H-&gt;TheLists[ Hash( Key, H-&gt;TableSize ) ]; /*Compute again is bad*/\n            NewCell-&gt;Next = L-&gt;Next; \n            NewCell-&gt;Element = Key; /*Probably need strcpy!*/ \n            L-&gt;Next = NewCell; \n        } \n    } \n} \n</code></pre> <p>Note : Make the TableSize about as large as the number of keys expected (i.e. to make the loading density factor \\(\\lambda\\approx\\)1).</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#84-open-addressing","title":"8.4 Open Addressing","text":"<ul> <li>find another empty cell to solve collision(avoiding pointers)</li> </ul> <pre><code>Algorithm: insert key into an array of hash table\n{\n    index = hash(key);\n    initialize i = 0 ------ the counter of probing;\n    while (collision at index) \n    {\n        index = (hash(key)+f(i))%TableSize; /*f(i) is collision resolving function*/\n        if (table is full) break;\n        else i++;\n    }\n    if (table is full) ERROR (\u201cNo space left\u201d);\n    else insert key at index;\n}\n</code></pre> <p>Note : Generally \\(\\lambda&lt;0.5\\).</p>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#linear-probing","title":"Linear Probing","text":"<ul> <li>\\(F(i)\\) is a linear function of \\(i\\), such as \\(F(i)=i\\).</li> <li>\u9010\u4e2a\u63a2\u6d4b\u6bcf\u4e2a\u5355\u5143(\u5fc5\u8981\u65f6\u53ef\u4ee5\u7ed5\u56de)\u4ee5\u67e5\u627e\u51fa\u4e00\u4e2a\u7a7a\u5355\u5143</li> <li>\u4f7f\u7528\u7ebf\u6027\u63a2\u6d4b\u7684\u9884\u671f\u63a2\u6d4b\u6b21\u6570\u5bf9\u4e8e\u63d2\u5165\u548c\u4e0d\u6210\u529f\u7684\u67e5\u627e\u6765\u8bf4\u5927\u7ea6\u662f\\(\\frac{1}{2}(1+\\frac{1}{(1-\\lambda)^2})\\)\uff0c\u5bf9\u4e8e\u6210\u529f\u7684\u67e5\u627e\u6765\u8bf4\u662f\\(\\frac{1}{2}(1+\\frac{1}{1-\\lambda})\\)</li> <li>Cause primary clustering : any key that hashes into the cluster will add to the cluster after several attempts to resolve the collision.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#quadratic-probing","title":"Quadratic Probing","text":"<ul> <li>\\(F(i)\\) is a quadratic function of \\(i\\), such as \\(F(i)=i^2\\).</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#theorem-if-quadratic-probing-is-used-and-the-table-size-is-prime-then-a-new-element-can-always-be-inserted-if-the-table-is-at-least-half-empty","title":"[Theorem] If quadratic probing is used, and the table size is prime, then a new element can always be inserted if the table is at least half empty.","text":"<p>Note : If the table size is a prime of the form \\(4k + 3\\), then the quadratic probing  \\(f(i) = \\pm i^2\\) can probe the entire table.</p> <pre><code>HashTable InitializeTable(int TableSize)\n{\n    HashTable H;\n    int i;\n    if(TableSize &lt; MinTableSize)\n    {\n        Error(\"Table size too small\");\n        return NULL;\n    }\n    /*Allocate table*/\n    H = malloc(sizeof(struct HashTbl));\n    if(H == NULL)\n        Fatal Error(\"Out of space!!!\");\n    H-&gt;TableSize = NextPrime(TableSize);\n\n    /*Allocate array of Cells*/\n    H-&gt;TheCells = malloc(sizeof(Cell)*H-&gt;TableSize);\n    if(H-&gt;TheCells == NULL)\n        FatalError(\"Out of space!!!\");\n\n    for(i = 0; i &lt; H-&gt;TableSize; i++)\n        H-&gt;TheCells[ i ].Info = Empty;\n    return H;\n}\n</code></pre> <pre><code>Position Find(ElementType Key, HashTable H) \n{   \n    Position CurrentPos; \n    int CollisionNum; \n    CollisionNum = 0; \n    CurrentPos = Hash(Key, H-&gt;TableSize); \n    while(H-&gt;TheCells[ CurrentPos ].Info != Empty &amp;&amp;\n          H-&gt;TheCells[ CurrentPos ].Element != Key) \n    { \n        CurrentPos += 2*++CollisionNum-1; \n        if (CurrentPos &gt;= H-&gt;TableSize)  \n            CurrentPos -= H-&gt;TableSize;   /*Faster than mod*/\n    } \n    return CurrentPos; \n} \n</code></pre> <pre><code>void Insert(ElementType Key, HashTable H) \n{ \n    Position Pos; \n    Pos = Find(Key, H); \n    if (H-&gt;TheCells[ Pos ].Info != Legitimate) \n    { /*OK to insert here*/ \n        H-&gt;TheCells[ Pos ].Info = Legitimate; \n        H-&gt;TheCells[ Pos ].Element = Key; /*Probably need strcpy*/ \n    } \n} \n</code></pre> <p>Note :</p> <ul> <li>Insertion will be seriously slowed down if there are too many deletions intermixed with insertions.</li> <li>Although primary clustering is solved, secondary clustering occurs, that is, keys that hash to the same position will probe the same alternative cells.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#double-hashing","title":"Double Hashing","text":"<ul> <li>\\(f(i)=i*hash_2(x)\\)</li> <li>\\(hash_2(x)\\not\\equiv 0\\)</li> <li>make sure that all cells can be probed</li> <li>\\(hash_2(x)=R-(x\\%R)\\) with \\(R\\) a prime smaller than TableSize, will work well.</li> </ul> <p>Note :</p> <ul> <li>If double hashing is correctly implemented, simulations imply that the expected number of probes is almost the same as for a random collision resolution strategy.</li> <li>Quadratic probing does not require the use of a second hash function and is thus likely to be simpler and faster in practice.</li> </ul>"},{"location":"2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webnotes/Foundation-of-Data-Structure/#85-rehashing","title":"8.5 Rehashing","text":"<ul> <li>Build another table that is about twice as big.</li> <li>Scan down the entire original hash table for non-deleted elements.</li> <li>Use a new function to hash those elements into the new table.</li> <li>When to rehash</li> <li>As soon as the table is half full</li> <li>When an insertion fails</li> <li>When the table reaches a certain load factor</li> </ul> <p>Note : Usually there should have been N/2 insertions before rehash, so O(N) rehash only adds a constant cost to each insertion. However, in an interactive system, the unfortunate user whose insertion caused a rehash could see a slowdown.</p> <pre><code>HashTable Rehash(HashTable H)\n{\n    int i, OldSize;\n    Cell *OldCells;\n    OldCells = H-&gt;TheCells;\n    OldSize = H-&gt;TableSize;\n\n    /*Get a new, empty table*/\n    H = InitializeTable(2*OldSize);\n    /*Scan through old table, reinserting into new*/\n    for(i = 0; i &lt; OldSize; i++)\n        if(OldCells[i].Info == Legitimate)\n            Insert(OldCells[i].Element, H);\n    free(OldCells);\n\n    return H;\n}\n</code></pre>"},{"location":"3%20ZJU-AI-ML/ML-zju/","title":"ML-for-zju","text":"<p>generative model \u751f\u6210\u5f0f\u6a21\u578b\u548c\u975e\u751f\u6210\u5f0f\u6a21\u578b</p> <p>linear model/none linear model</p> <p></p> <p>\u751f\u6210\u6a21\u578b\uff08Generative Model\uff09\u548c\u5224\u522b\u6a21\u578b\uff08Discriminative Model\uff09\u662f\u673a\u5668\u5b66\u4e60\u4e2d\u4e24\u79cd\u4e0d\u540c\u7c7b\u578b\u7684\u6a21\u578b\uff0c\u5b83\u4eec\u7684\u4e3b\u8981\u533a\u522b\u5728\u4e8e\u5b83\u4eec\u5bf9\u6570\u636e\u7684\u5efa\u6a21\u65b9\u5f0f\u548c\u5e94\u7528\u9886\u57df\u3002</p> <ol> <li>\u751f\u6210\u6a21\u578b\uff08Generative Model\uff09\uff1a</li> <li>\u751f\u6210\u6a21\u578b\u8bd5\u56fe\u5bf9\u6574\u4e2a\u6570\u636e\u5206\u5e03\u8fdb\u884c\u5efa\u6a21\uff0c\u5b83\u5b66\u4e60\u5982\u4f55\u751f\u6210\u6570\u636e\u3002\u751f\u6210\u6a21\u578b\u80fd\u591f\u751f\u6210\u4e0e\u8bad\u7ec3\u6570\u636e\u96c6\u76f8\u4f3c\u7684\u65b0\u6570\u636e\u70b9\u3002</li> <li>\u751f\u6210\u6a21\u578b\u901a\u5e38\u7528\u4e8e\u751f\u6210\u65b0\u6570\u636e\u3001\u6837\u672c\u5408\u6210\u3001\u7f3a\u5931\u6570\u636e\u586b\u8865\u4ee5\u53ca\u5bc6\u5ea6\u4f30\u8ba1\u7b49\u4efb\u52a1\u3002</li> <li>\u4ee3\u8868\u6027\u7684\u751f\u6210\u6a21\u578b\u5305\u62ec\u53d8\u5206\u81ea\u7f16\u7801\u5668\uff08Variational Autoencoders\uff0cVAE\uff09\u3001\u751f\u6210\u5bf9\u6297\u7f51\u7edc\uff08Generative Adversarial Networks\uff0cGAN\uff09\u3001\u9690\u9a6c\u5c14\u53ef\u592b\u6a21\u578b\uff08Hidden Markov Models\uff0cHMM\uff09\u7b49\u3002</li> <li>\u751f\u6210\u6a21\u578b\u901a\u5e38\u9700\u8981\u66f4\u591a\u7684\u6570\u636e\u548c\u8ba1\u7b97\u8d44\u6e90\u6765\u8bad\u7ec3\uff0c\u56e0\u4e3a\u5b83\u4eec\u8981\u5b66\u4e60\u6574\u4e2a\u6570\u636e\u5206\u5e03\u3002</li> <li>\u5224\u522b\u6a21\u578b\uff08Discriminative Model\uff09\uff1a</li> <li>\u5224\u522b\u6a21\u578b\u5173\u6ce8\u7684\u662f\u5bf9\u4e0d\u540c\u7c7b\u522b\u4e4b\u95f4\u7684\u8fb9\u754c\u8fdb\u884c\u5efa\u6a21\uff0c\u5b83\u5b66\u4e60\u5982\u4f55\u5bf9\u8f93\u5165\u6570\u636e\u8fdb\u884c\u5206\u7c7b\u6216\u6807\u8bb0\u3002</li> <li>\u5224\u522b\u6a21\u578b\u901a\u5e38\u7528\u4e8e\u5206\u7c7b\u3001\u56de\u5f52\u548c\u6807\u8bb0\u4efb\u52a1\uff0c\u5176\u4e2d\u76ee\u6807\u662f\u9884\u6d4b\u8f93\u5165\u6570\u636e\u7684\u6807\u7b7e\u6216\u5c5e\u6027\u3002</li> <li>\u4ee3\u8868\u6027\u7684\u5224\u522b\u6a21\u578b\u5305\u62ec\u903b\u8f91\u56de\u5f52\u3001\u652f\u6301\u5411\u91cf\u673a\u3001\u51b3\u7b56\u6811\u3001\u795e\u7ecf\u7f51\u7edc\u4e2d\u7684\u524d\u9988\u795e\u7ecf\u7f51\u7edc\u7b49\u3002</li> <li>\u5224\u522b\u6a21\u578b\u901a\u5e38\u5728\u5c0f\u89c4\u6a21\u6570\u636e\u4e0a\u6548\u679c\u8f83\u597d\uff0c\u56e0\u4e3a\u5b83\u4eec\u53ea\u9700\u8981\u5efa\u6a21\u4e0e\u4efb\u52a1\u76f8\u5173\u7684\u90e8\u5206\u4fe1\u606f\uff0c\u800c\u4e0d\u9700\u8981\u5b66\u4e60\u6574\u4e2a\u6570\u636e\u5206\u5e03\u3002</li> </ol> <p>\u603b\u7ed3\u6765\u8bf4\uff0c\u751f\u6210\u6a21\u578b\u548c\u5224\u522b\u6a21\u578b\u7684\u5173\u952e\u533a\u522b\u5728\u4e8e\u5176\u5efa\u6a21\u76ee\u6807\u3002\u751f\u6210\u6a21\u578b\u8bd5\u56fe\u7406\u89e3\u6574\u4e2a\u6570\u636e\u5206\u5e03\u5e76\u751f\u6210\u65b0\u6570\u636e\uff0c\u800c\u5224\u522b\u6a21\u578b\u5173\u6ce8\u7684\u662f\u5bf9\u6570\u636e\u7684\u5206\u7c7b\u6216\u6807\u8bb0\u3002\u5728\u5b9e\u9645\u5e94\u7528\u4e2d\uff0c\u9009\u62e9\u751f\u6210\u6a21\u578b\u8fd8\u662f\u5224\u522b\u6a21\u578b\u901a\u5e38\u53d6\u51b3\u4e8e\u5177\u4f53\u95ee\u9898\u548c\u4efb\u52a1\u7684\u6027\u8d28\u3002\u6709\u65f6\uff0c\u8fd9\u4e24\u79cd\u7c7b\u578b\u7684\u6a21\u578b\u53ef\u4ee5\u7ed3\u5408\u4f7f\u7528\uff0c\u4ee5\u5b9e\u73b0\u66f4\u590d\u6742\u7684\u673a\u5668\u5b66\u4e60\u4efb\u52a1\u3002</p> <p></p> <p>linear feature+nonlinear model/ nonlinear feature+linear model\u662f\u4ec0\u4e48\u610f\u601d</p> <p>ChatGPT</p> <p>\"\u7ebf\u6027\u7279\u5f81 + \u975e\u7ebf\u6027\u6a21\u578b\" \u548c \"\u975e\u7ebf\u6027\u7279\u5f81 + \u7ebf\u6027\u6a21\u578b\" \u662f\u673a\u5668\u5b66\u4e60\u4e2d\u7684\u4e24\u79cd\u4e0d\u540c\u65b9\u6cd5\uff0c\u7528\u4e8e\u5904\u7406\u6570\u636e\u548c\u5efa\u7acb\u9884\u6d4b\u6a21\u578b\u3002\u5b83\u4eec\u53ef\u4ee5\u5728\u7279\u5f81\u5de5\u7a0b\u548c\u6a21\u578b\u9009\u62e9\u65b9\u9762\u7528\u4e8e\u5904\u7406\u975e\u7ebf\u6027\u5173\u7cfb\u3002</p> <ol> <li>\u7ebf\u6027\u7279\u5f81 + \u975e\u7ebf\u6027\u6a21\u578b\uff1a</li> <li>\u5728\u8fd9\u79cd\u65b9\u6cd5\u4e2d\uff0c\u7279\u5f81\u662f\u539f\u59cb\u6570\u636e\u6216\u7ebf\u6027\u7ec4\u5408\u7684\u7ed3\u679c\uff0c\u800c\u6a21\u578b\u662f\u975e\u7ebf\u6027\u7684\u3002\u8fd9\u610f\u5473\u7740\u6a21\u578b\u53ef\u4ee5\u5b66\u4e60\u975e\u7ebf\u6027\u5173\u7cfb\uff0c\u4f46\u7279\u5f81\u672c\u8eab\u662f\u7ebf\u6027\u7684\u3002</li> <li>\u4e3e\u4f8b\uff1a\u7279\u5f81\u53ef\u4ee5\u662f\u539f\u59cb\u6570\u636e\uff0c\u5982\u957f\u5ea6\u3001\u5bbd\u5ea6\u548c\u9ad8\u5ea6\uff0c\u4f46\u6a21\u578b\u53ef\u4ee5\u662f\u591a\u9879\u5f0f\u56de\u5f52\u6a21\u578b\uff0c\u80fd\u591f\u62df\u5408\u975e\u7ebf\u6027\u5173\u7cfb\uff0c\u4f8b\u5982\u957f\u5ea6\u548c\u5bbd\u5ea6\u7684\u4e58\u79ef\u5bf9\u8f93\u51fa\u7684\u5f71\u54cd\u3002</li> <li>\u975e\u7ebf\u6027\u7279\u5f81 + \u7ebf\u6027\u6a21\u578b\uff1a</li> <li>\u5728\u8fd9\u79cd\u65b9\u6cd5\u4e2d\uff0c\u7279\u5f81\u672c\u8eab\u662f\u7ecf\u8fc7\u975e\u7ebf\u6027\u53d8\u6362\u7684\uff0c\u4f8b\u5982\uff0c\u901a\u8fc7\u5e94\u7528\u67d0\u79cd\u975e\u7ebf\u6027\u51fd\u6570\uff08\u4f8b\u5982\u5bf9\u6570\u3001\u6307\u6570\u3001\u591a\u9879\u5f0f\u7b49\uff09\u5bf9\u539f\u59cb\u6570\u636e\u8fdb\u884c\u5904\u7406\u3002\u7136\u540e\uff0c\u7ebf\u6027\u6a21\u578b\u88ab\u7528\u4e8e\u5b66\u4e60\u7279\u5f81\u4e4b\u95f4\u7684\u7ebf\u6027\u5173\u7cfb\u3002</li> <li>\u4e3e\u4f8b\uff1a\u7279\u5f81\u53ef\u4ee5\u662f\u539f\u59cb\u6570\u636e\u7684\u5bf9\u6570\uff0c\u6a21\u578b\u53ef\u4ee5\u662f\u7ebf\u6027\u56de\u5f52\u6a21\u578b\uff0c\u901a\u8fc7\u5bf9\u6570\u53d8\u6362\u80fd\u591f\u6355\u6349\u6570\u636e\u4e2d\u7684\u975e\u7ebf\u6027\u5173\u7cfb\uff0c\u5982\u6307\u6570\u589e\u957f\u3002</li> </ol> <p>\u8fd9\u4e24\u79cd\u65b9\u6cd5\u901a\u5e38\u7528\u4e8e\u5904\u7406\u4e0d\u540c\u7c7b\u578b\u7684\u6570\u636e\u548c\u95ee\u9898\u3002\u9009\u62e9\u54ea\u79cd\u65b9\u6cd5\u901a\u5e38\u53d6\u51b3\u4e8e\u95ee\u9898\u7684\u6027\u8d28\u4ee5\u53ca\u6570\u636e\u7684\u5206\u5e03\u3002\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u53ef\u4ee5\u5c1d\u8bd5\u4e24\u79cd\u65b9\u6cd5\uff0c\u7136\u540e\u6839\u636e\u6a21\u578b\u6027\u80fd\u6765\u9009\u62e9\u6700\u4f73\u65b9\u6cd5\u3002</p> <p>\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\"\u975e\u7ebf\u6027\u7279\u5f81 + \u7ebf\u6027\u6a21\u578b\" \u4e5f\u53ef\u4ee5\u88ab\u770b\u4f5c\u662f\u4e00\u79cd\"\u7ebf\u6027\u7279\u5f81 + \u975e\u7ebf\u6027\u6a21\u578b\"\u7684\u7279\u6b8a\u60c5\u51b5\uff0c\u56e0\u4e3a\u7ebf\u6027\u6a21\u578b\u672c\u8eab\u53ef\u4ee5\u5b66\u4e60\u975e\u7ebf\u6027\u5173\u7cfb\uff0c\u53ea\u8981\u7279\u5f81\u7ecf\u8fc7\u9002\u5f53\u7684\u975e\u7ebf\u6027\u53d8\u6362\u3002\u8fd9\u79cd\u7075\u6d3b\u6027\u4f7f\u5f97\u7ebf\u6027\u6a21\u578b\u6210\u4e3a\u8bb8\u591a\u673a\u5668\u5b66\u4e60\u95ee\u9898\u7684\u6709\u529b\u5de5\u5177\u3002</p> Truth/Prediction Positive Positive TP Negative FP <p></p> <p>mean-squared error</p> <p></p> <p></p>"},{"location":"3%20ZJU-AI-ML/ML-zju/#10-25","title":"10-25","text":""},{"location":"3%20ZJU-AI-ML/ML-zju/#symbolism","title":"symbolism","text":"<p>logic theorist</p> <p>expert system</p> <p>automated theoroem proving</p>"},{"location":"3%20ZJU-AI-ML/ML-zju/#connectionism","title":"connectionism","text":"<p>transformers</p> <p>recurrent neural networks</p> <p>convolution neural netorks</p>"},{"location":"3%20ZJU-AI-ML/feed%20forward%20and%20backward%20propagation/","title":"\u53cd\u5411\u4f20\u64ad","text":"<p>feed forward and backward propagation</p> <p>\u53cd\u5411\u4f20\u64ad\u4e2d\uff0c\u8ba1\u7b97\u7684\u662f\u6700\u7ec8\u7684</p>"},{"location":"3%20ZJU-AI-ML/labs%20%26%20hw%20review/","title":"\u8bfe\u7a0bLab&hw","text":"<p>labs &amp; hw review quickly\uff01</p>"},{"location":"3%20ZJU-AI-ML/notes%20for%20ZJU-AI-ML/","title":"\u8d76\u5feb\u8865\u8bfe\u6284\u7b14\u8bb0","text":"<p>notes for ZJU-AI-ML</p>"},{"location":"4%20%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%20DIP/DIP/","title":"4 \u56fe\u50cf\u4fe1\u606f\u5904\u7406 DIP","text":"<p>DIP</p> <p>DPI\u662f</p> <p>\u8bfe\u7a0b\u5927\u7eb2</p> <p>\u76ee\u5f55\u8bfe\u7a0b\u5b66\u4e60\u5185\u5bb9\u4efb\u8bfe\u6559\u5e08\u8bfe\u7a0b\u6559\u6750\u63a8\u8350\u4e66\u5355\u5206\u6570\u6784\u6210</p>"},{"location":"4%20%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%20DIP/DIP/#_1","title":"\u56fe\u50cf\u4fe1\u606f\u5904\u7406\u00b6","text":"<p>CS \u4e13\u4e1a\u9009\u4fee</p>"},{"location":"4%20%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%20DIP/DIP/#_2","title":"\u8bfe\u7a0b\u5b66\u4e60\u5185\u5bb9\u00b6","text":"<p>\u6559\u6388\u5185\u5bb9\u4ee5\u56fe\u50cf\u57fa\u672c\u6982\u5ff5\u3001\u57fa\u672c\u64cd\u4f5c\u4e3a\u57fa\u7840\uff0c\u56f4\u7ed5\u56fe\u50cf\u5408\u6210\u4e0e\u7f16\u8f91\u6838\u5fc3\uff0c\u5e76\u4ecb\u7ecd\u4e86\u5f53\u524d\u6570\u5b57\u56fe\u50cf\u5904\u7406\u7684\u73b0\u72b6\u3001\u53d1\u5c55\u548c\u4e00\u4e9b\u5173\u952e\u6280\u672f\u3002 \u4e3b\u8981\u77e5\u8bc6\u70b9\u4e3a\uff1a</p> <ul> <li>\u56fe\u50cf\u83b7\u53d6</li> <li>\u56fe\u50cf\u663e\u793a\u548c\u6253\u5370</li> <li>\u56fe\u50cf\u5b58\u50a8\u548c\u4f20\u8f93</li> <li>\u56fe\u50cf\u589e\u5f3a\u548c\u6062\u590d</li> <li>\u56fe\u50cf\u8bc6\u522b\u548c\u7406\u89e3</li> </ul>"},{"location":"4%20%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%20DIP/DIP/#_3","title":"\u4efb\u8bfe\u6559\u5e08\u00b6","text":"<p>\u672c\u95e8\u8bfe\u7a0b\u53ea\u7531\u5b8b\u660e\u9ece\u4e00\u4f4d\u8001\u5e08\u5f00\u8bbe\u3002</p> <p>\u6388\u8bfe\u65b9\u5f0f\uff1a\u53cc\u8bed\uff08\u7edd\u5927\u90e8\u5206 PPT \u4e3a\u82f1\u6587\uff0c\u8001\u5e08\u6388\u8bfe\u4f7f\u7528\u6c49\u8bed\uff09\u3002</p> <p>\u6388\u8bfe\u6c34\u5e73\uff1a\u53e3\u9f7f\u6e05\u6670\uff0c\u903b\u8f91\u6e05\u6670\uff0c\u667a\u4e91 1.5 \u500d\u901f\u521a\u597d\u3002</p> <p>\u7ed9\u5206\u60c5\u51b5\uff1a\u4e00\u822c\u3002\u4e0d\u5efa\u8bae\u62b1\u592a\u9ad8\u671f\u671b\uff0c\u4f46\u8ba4\u771f\u5b66\u7684\u8bdd\u5f97\u5206\u5e94\u8be5\u4e0d\u4f1a\u592a\u4f4e\u3002</p> <p>\u5176\u4ed6\uff1a\u9ece\u53d4\u662f\u4e00\u540d\u706b\u5f71\u53a8\u3002</p>"},{"location":"4%20%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%20DIP/DIP/#_4","title":"\u8bfe\u7a0b\u6559\u6750\u00b6","text":"<p>\u65e0</p>"},{"location":"4%20%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%20DIP/DIP/#_5","title":"\u63a8\u8350\u4e66\u5355\u00b6","text":"<ul> <li>Digital Image Processing Using MATLAB, Gonzalez</li> <li>\u300a\u6570\u5b57\u56fe\u50cf\u5904\u7406\u7f16\u7a0b\u5165\u95e8\u300b\uff0c\u5415\u51e4\u519b</li> </ul>"},{"location":"4%20%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%20DIP/DIP/#_6","title":"\u5206\u6570\u6784\u6210\u00b6","text":"<p>\u5377\u9762\uff0860%\uff09+ \u4f5c\u4e1a\uff0840%\uff09</p> <p>\u4e00\u5b66\u671f\u5927\u6982\u4f1a\u6709 5~7 \u6b21\u4f5c\u4e1a\uff0c\u8981\u4f7f\u7528 C/C++ \u7f16\u7a0b\uff0c\u4e0d\u53ef\u8c03\u7528 OpenCV \u7b49\u56fe\u5f62\u5904\u7406\u5e93\u3002</p> <p>\u77e2\u91cf\u56fe\u683c\u5f0f</p> <p>BITMAPFILEHEADER</p> <p>BITMAPINFOHEDER</p> <p>morphing \u53d8\u5f62\u3001\u6620\u5c04</p> <p>bilateral filter \u53cc\u8fb9\u6ee4\u6ce2</p> <p>guided filter</p>"},{"location":"Others/CS61A-python/","title":"CS61a PYTHON","text":"<p>answer = get_string()</p> <p>print(\"hello,\",answer)  \u4e24\u4e2a\u53c2\u6570\u4e2d\u95f4\u81ea\u52a8\u52a0\u62ec\u53f7</p> <p>print(f\"hello,{answer}\")</p> <p>f\u4e3aformatted string \u683c\u5f0f\u5316\u5b57\u7b26\u4e32</p> <p>\u6570\u636e\u7c7b\u578b</p> <p>\u5220\u53bb\u4e86c\u4e2d\u7684  long double</p> <p>\u53ea\u6709bool float int str</p> <p>\u52a0\u4e86range list tuple dict set</p> <pre><code>words = set() #\u76f4\u63a5\u5c06\u4e00\u4e2ahash table \u8d4b\u7ed9word\n#dict\u7684\u5b9e\u73b0\uff1f\ndef check(word):\n    if word.lower() in words:\n        return True\n    else:\n        return False\ndef load(dictionary):\n    file = open(dictionary, \"r\")\n    for line in file:\n        word = line.rstrip() #\n        words.add(line)\n    close(file)\n    return True\n\ndef size():\n    return len(word)\n\ndef unload():\n    #free memory\n    return True\n</code></pre> <p></p> <p>\u6240\u8c13oop\u5c31\u662f\u6709\u5185\u7f6e\u7684\u51fd\u6570</p> <p>s.lower() \u8981\u975e\u5e38\u6ce8\u610fpython\u4e2d\u7684\u6d45\u62f7\u8d1d\u548c\u6df1\u62f7\u8d1d</p> <p></p> <pre><code>#py\u4e0d\u9700\u8981prototype\uff0c\u4f46\u662f\u9700\u8981call main\n\nmain\u51fd\u6570\u5199\u5728\u6700\u540e\uff0c\u4e0d\u7528\u7f29\u8fdb\n</code></pre> <pre><code>#try-except\u8bed\u53e5\n#\u629b\u51fa\u9519\u8bef\uff0c\u7136\u540e\ntry:\n\nexcept:\n\nelse:\n</code></pre> <pre><code>for i in range(4):\n    print(\"?\",end=\"\\n\")-&gt;print(\"?\",end=\"\")\n=print(\"?\"*4)\n#\u6ca1\u6709\u5206\u914d\u5185\u5b58\uff0c\u6ca1\u6709\u6307\u9488\n</code></pre>"},{"location":"Others/CS61A-python/#global-frame","title":"global frame(\u5168\u5c40\u5e27)","text":"<p>\u5168\u5c40\u5e27\u662f\u7a0b\u5e8f\u7684\u9876\u5c42\u5e27\uff0c\u5305\u542b\u4e86\u5168\u5c40\u8303\u56f4\u5185\u5b9a\u4e49\u7684\u53d8\u91cf\u3002\u8fd9\u4e9b\u53d8\u91cf\u88ab\u79f0\u4e3a\u5168\u5c40\u53d8\u91cf\uff0c\u56e0\u4e3a\u5b83\u4eec\u53ef\u4ee5\u5728\u6574\u4e2a\u7a0b\u5e8f\u7684\u4efb\u4f55\u5730\u65b9\u8bbf\u95ee\u3002\u5168\u5c40\u5e27\u4e2d\u7684\u53d8\u91cf\u5bf9\u6574\u4e2a\u7a0b\u5e8f\u90fd\u662f\u53ef\u89c1\u7684\u3002</p>"},{"location":"Others/CS61A-python/#local-frame","title":"local frame\uff08\u5c40\u90e8\u5e27\uff09","text":"<p>\u6bcf\u5f53\u4f60\u8c03\u7528\u4e00\u4e2a\u51fd\u6570\uff0cPython\u4f1a\u4e3a\u8be5\u51fd\u6570\u521b\u5efa\u4e00\u4e2a\u5c40\u90e8\u5e27\u3002\u8fd9\u4e2a\u5c40\u90e8\u5e27\u5305\u542b\u4e86\u51fd\u6570\u4e2d\u5b9a\u4e49\u7684\u5c40\u90e8\u53d8\u91cf\u548c\u53c2\u6570\u3002\u8fd9\u4e9b\u53d8\u91cf\u53ea\u80fd\u5728\u51fd\u6570\u5185\u90e8\u8bbf\u95ee\uff0c\u800c\u5728\u51fd\u6570\u6267\u884c\u5b8c\u6bd5\u540e\uff0c\u5c40\u90e8\u5e27\u4e5f\u4f1a\u88ab\u9500\u6bc1\u3002\u8fd9\u6709\u52a9\u4e8e\u4fdd\u6301\u53d8\u91cf\u7684\u9694\u79bb\u6027\uff0c\u9632\u6b62\u4e0d\u540c\u51fd\u6570\u4e4b\u95f4\u7684\u53d8\u91cf\u540d\u51b2\u7a81\u3002</p> <p>\u4e3e\u4f8b\u6765\u8bf4\uff0c\u5982\u679c\u4f60\u5728Python\u4e2d\u5b9a\u4e49\u4e00\u4e2a\u51fd\u6570\uff0c\u51fd\u6570\u5185\u7684\u53d8\u91cf\u4f1a\u5b58\u5728\u4e8e\u8be5\u51fd\u6570\u7684\u5c40\u90e8\u5e27\u4e2d\u3002\u540c\u65f6\uff0c\u5982\u679c\u4f60\u5728\u51fd\u6570\u5916\u5b9a\u4e49\u4e00\u4e2a\u53d8\u91cf\uff0c\u5b83\u4f1a\u5b58\u5728\u4e8e\u5168\u5c40\u5e27\u4e2d\u3002\u8fd9\u79cd\u5206\u5c42\u7684\u5e27\u7ed3\u6784\u6709\u52a9\u4e8e\u7ec4\u7ec7\u548c\u7ba1\u7406\u53d8\u91cf\uff0c\u4f7f\u5176\u5177\u6709\u9002\u5f53\u7684\u4f5c\u7528\u57df\u3002\u5c40\u90e8\u5e27\u548c\u5168\u5c40\u5e27\u7684\u4ea4\u4e92\u662fPython\u4e2d\u53d8\u91cf\u4f5c\u7528\u57df\u7684\u6838\u5fc3\u6982\u5ff5\uff0c\u5b83\u786e\u4fdd\u4e86\u53d8\u91cf\u5728\u7a0b\u5e8f\u4e2d\u7684\u5408\u7406\u53ef\u89c1\u6027\u548c\u9694\u79bb\u6027\u3002</p>"},{"location":"Others/CS61A-python/#python3-i-examplepy","title":"$python3 -i example.py","text":"<p>\u4ee5\u4ea4\u4e92\u5f0f\u547d\u4ee4\u884c\u8fd0\u884cpython\uff0c\u53ef\u4ee5\u901a\u8fc7\u952e\u5165\u53d8\u91cf\u503c\u67e5\u770b\u6267\u884c\u5b8c\u6210\u540e\u7684\u5404\u4e2a\u53d8\u91cf\uff0c\u65e0\u9700print</p>"},{"location":"Others/CS61A-python/#python3-m-doctest-examplepy","title":"$python3 -m doctest example.py","text":"<p>\u8fd0\u884cdocstring\u6240\u6307\u5b9a\u7684\u793a\u4f8b\uff0c\u5982\u679c\u6ca1\u6709\u8f93\u51fa\u5219\u76f4\u63a5\u8fd4\u56de</p>"},{"location":"Others/CS61A-python/#python3-m-doctest-v-examplepy","title":"$python3 -m doctest -v example.py","text":"<p>\u6253\u5370\u8f93\u51fa\u6240\u6709\u7684docstring\u6d4b\u8bd5\u7ed3\u679c\uff0c\u76f8\u5f53\u4e8e\u81ea\u6d4b\u60c5\u51b5</p> <p>def\u5d4c\u5957\u5b9a\u4e49</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>lambda x  :  f(x)==y \u8fd4\u56de\u4e00\u4e2ax</p> <p></p> <p>control statements</p> <p></p>"},{"location":"Others/CS61A-python/#-n-1n-1n","title":"\u9a8c\u8bc1\u9012\u5f52\u7684\u6b63\u786e\u6027/\u5982\u4f55\u5199\u9012\u5f52-&gt;\u5206\u89e3\u95ee\u9898\uff0c\u5c31\u597d\u50cfn-1\u7684\u7b54\u6848\u5df2\u7ecf\u5199\u597d\u4e86\uff0c\u53ea\u9700\u8981\u4ecen-1\u5f97\u5230n","text":"<p>\u7528\u6570\u5f52\uff01</p> <p>1.base case</p> <p>2.\u5047\u8bben-1\u7684\u60c5\u51b5\u6b63\u786e\u6267\u884c\uff0c\u6b63\u786e\u8fd4\u56de\uff0c\u5982\u4f55\u5229\u7528n-1\u7684\u60c5\u51b5\u5f97\u51fan</p> <p></p> <p></p> <p>\u4e0a\u9762\u662f\u5faa\u73af\uff0c\u8fed\u4ee3</p> <p>\u4e0b\u9762\u662f\u9012\u5f52\uff01</p> <p>\u8fed\u4ee3\u6bcf\u6b21while\u5faa\u73af\u5185\u7684\u8d4b\u503c\u53d8\u6210\u4e86\u9012\u5f52\u8c03\u7528\u65f6\u7684\u53c2\u6570</p> <pre><code>def factorial_recursive(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial_recursive(n - 1)\n\ndef factorial_iterative(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n</code></pre> <p>\u5206\u6e05\u695abase case\u548celse</p> <p></p> <p></p> <p></p> <p>\u600e\u4e48\u5206\u89e3\u95ee\u9898\u6bd4\u8f83\u5173\u952e</p> <p>counting partitions</p> <p></p> <p></p> <p></p> <p>python\u5217\u8868(list)\u548c\u5143\u7ec4(tuple)\u8be6\u89e3_\u6728\u5b50\u6797_\u7684\u535a\u5ba2-CSDN\u535a\u5ba2</p> <p>\u4e00\u7bc7\u8bb2list\u548ctuple\u533a\u522b\u7684blog\uff0c\u975e\u5e38\u7ec6\u81f4\uff0c\u53ef\u4ee5\u7ec6\u770b</p> <p>Python\u7684enumerate\u51fd\u6570-CSDN\u535a\u5ba2</p> <p>method \uff1a\u548cinstance\u7ed1\u5b9a\u7684\u51fd\u6570</p> <p>method\u7684\u7b2c\u4e00\u4e2a\u9690\u5f62\u7684\u53c2\u6570\u662fself\uff0c\u8c03\u7528\u7684\u65b9\u5f0f\u662fdot\uff08.\uff09</p> <p>instance\u6709\u5c5e\u6027\uff0c\u4f46\u662fclass\u4e5f\u53ef\u4ee5\u6709\u81ea\u5df1\u7684\u5c5e\u6027</p> <p>\u7c7b\u540d.\u51fd\u6570\u540d</p> <p>Account.deposit\uff08account_john\uff0c10\uff09\u5c5e\u4e8e\u76f4\u63a5\u8bbf\u95ee\u7c7b\u7684method</p> <pre><code>class Account:\n    interest = 0.02\n    def __init__(self,account_holder):\n        self.balance = 0\n        self.holder = account_holder\n    def withdraw(self,amount):\n        if self.balance-amount&lt;0:\n            return 'Insufficient funds'\n        else\n        self.balance = self.balance-amount\n        return self.balance\n    def deposit(slef,amount):\n        self.balance = self.balance+amount\n        return self.balance\n    #additional methods would be defined here\nclass CheckingAccount(Account):\n    #\u9012\u5f52\u67e5\u770b\u662f\u5426\u6709\u5bf9\u5e94\u7684attribute\uff0c\u5982\u679c\u627e\u5230\u7684attribute\u662f\u4e00\u4e2abound method\u5c31\u8fd4\u56de\u51fd\u6570\u8ba1\u7b97\u540e\u7684\u503c\uff0c\u5982\u679c\u662f\u4e00\u4e2a\u503c\uff0c\u5c31\u8fd4\u56de\u8be5\u503c\n    #\u521d\u59cb\u5316\u7684\u65f6\u5019\n    withdraw_fee = 1\n    interest = 0.01\n    def withdraw(self,amount):\n        return Account.withdraw(self,amount+self.withdraw_fee)#\u8fd9\u91cc\u4f53\u73b0\u4e86\u7ee7\u627f\u7684\u53e6\u4e00\u79cd\u7528\u6cd5\n    #\u9012\u5f52\u67e5\u770b\uff0cwithdraw\u5728\u5b50\u7c7b\u4e2d\u6709\u540c\u540d\u7684\u91cd\u6784\u5b9e\u73b0\uff0c\u6240\u4ee5\u6309\u7167\u5b50\u7c7b\u7684\u6765\uff0c\u4f46\u662f\u56e0\u4e3a\u65b9\u4fbf\uff0c\u53ef\u4ee5\u8c03\u7528\u7236\u7c7b\u7684withdraw\u51fd\u6570\uff0c\u6240\u4ee5\u4f7f\u7528Account.withdraw\u6765\u8bbf\u95ee\u7236\u7c7b\u4e2d\u7684withdraw\uff0c\u4f46\u9700\u8981\u63d0\u4f9bself\u53c2\u6570\uff0c\u56e0\u4e3a\u5e76\u672a\u521d\u59cb\u5316account\u5c5e\u6027\u4e0b\u7684withdraw\uff0c\u6240\u4ee5\u9700\u8981\u63d0\u4f9bself\u53c2\u6570\n    #\u5373\u4f7f\u5df2\u88aboverridden\u7684\u5c5e\u6027\u4e5f\u53ef\u4ee5\u901a\u8fc7\u76f4\u63a5\u8bbf\u95ee\u7c7b\u5bf9\u8c61\u8bbf\u95ee\ntom_account = Account(\"Tom\")\n&gt;&gt;&gt;tom_account.interest\na = Account(\"John\")\nb = CheckingAccount('Jack')\n&gt;&gt;&gt;a.deposit(100)\n100\n&gt;&gt;&gt;b.deposit(100)\n100\n&gt;&gt;&gt;a.withdraw(100)\n90\n&gt;&gt;&gt;b.withdraw(100)\n89\n    0.02\n    #\u521d\u59cb\u5316\u7684\u5b9e\u4f8b\u6ca1\u6709interest\u8fd9\u4e2a\u5c5e\u6027\uff0c\u4f46\u662f\u7c7b\u6709\uff0c\u4e5f\u53ef\u4ee5\u8bbf\u95ee\u5230\n</code></pre> <p>\u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\u4e2d\uff0c\u6240\u6709\u4e1c\u897f\u662fobject\uff1a\u5bf9\u8c61</p> <p>\u5728oop python\u4e2d\uff0c\u6240\u6709\u4e1c\u897f\uff08object\uff09\u90fd\u6709\u5c5e\u6027\uff08attributes\uff09\uff0c\u4ee5\u952e\u503c\u5bf9\uff08name-value pairs)\u8868\u793a</p> <p>\u7c7b\uff08classes\uff09\u4e5f\u662fobject\uff1a\u5bf9\u8c61\uff0c\u56e0\u6b64\u7c7b\u6709\u81ea\u5df1\u7684\u5c5e\u6027</p> <p>\u5b9e\u4f8b\u7684\u5c5e\u6027\uff1a\u521d\u59cb\u5316\u7684\u5b9e\u4f8b\u5177\u6709\u7684\u5c5e\u6027</p> <p>\u7c7b\u7684\u5c5e\u6027\uff1a\u521d\u59cb\u5316\u7684\u5b9e\u4f8b\u6240\u5c5e\u7684\u7c7b\u6240\u5177\u6709\u7684\u5c5e\u6027</p> <p>\u7c7b\u7684def\u65b9\u6cd5\u5b9a\u4e49\u7684method/\u51fd\u6570\u8fd4\u56de\u4e0d\u8fd4\u56de\uff08return\u6709\u6ca1\u6709\u5185\u5bb9\u89c6\u60c5\u51b5\u9700\u8981\uff0c\u5982\u679c\u5728\u5b9e\u9645\u5b9e\u4f8b\u5316\u8c03\u7528\u7c7b\u65f6\u9700\u8981\u5c06\u521d\u59cb\u5316\u8fc7\u7684\u4e1c\u897f\u63a5\u6536\uff0c\u4f8b\u5982a = open_account(\"john\",5),\u5219\u9700\u8981\u8fd4\u56de\uff0c\u5426\u5219\u4e0d\u4e00\u5b9a\u9700\u8981\u5199return\u4ec0\u4e48</p> <p>has-a\u548cis-a\u5173\u7cfb</p> <pre><code>class Bank:\n    #a bank has accounts:has-a\u5173\u7cfb\n    def __init__(self):\n        self.accounts = []\n    def open_account(self,holder,amount,kind = Account):\n        account = kind(holder)\n        account.deposit(amount)\n        self.accounts.append(account)\n        return account\n    def pay_interest(self):\n        for a in self.accounts:\n            a.deposit(a.balance*a.interest)\n    def too_big_to_fail(self):\n        return len(self.account)&gt;1\n</code></pre> <pre><code>class A:\n    z = -1\n    def f(self,x):\n        return B(x-1)\nclass B(A):\n    n = 4\n    def __init__(self,y):\n        if y:\n            self.z = self.f(y)\n        else:\n            self.z = C(y+1)\nclass C(B):\n    def f(self,x):\n        return x\na = A()\nb = B(1)\nb.n = 5\nprint(C(2).n)\nprint(a.z==C.z)\nprint(a.z==b.z)\nprint(b.z)\nprint(b.z.z)\nprint(b.z.z.z)\nprint(b.z.z.z.z)\n</code></pre>"},{"location":"Others/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","title":"git\u4f7f\u7528\u6559\u7a0b","text":"<p>docs\\pictures\\1.jpg</p> <p></p>"},{"location":"Others/linux%20%E5%90%AF%E5%8A%A8/","title":"linux","text":"<ol> <li>\u4e91\u8ba1\u7b97\u548c\u865a\u62df\u5316\uff1a</li> <li>\u5b66\u4e60\u5982\u4f55\u914d\u7f6e\u548c\u7ba1\u7406\u4e91\u670d\u52a1\u5668\uff0c\u7406\u89e3\u4e91\u8ba1\u7b97\u6982\u5ff5\u548c\u670d\u52a1\u6a21\u578b\u3002</li> <li>\u638c\u63e1\u865a\u62df\u5316\u6280\u672f\uff0c\u5982\u5bb9\u5668\u5316\u548c\u865a\u62df\u673a\u7ba1\u7406\u3002</li> <li>\u7f51\u7edc\u548c\u5b89\u5168\uff1a</li> <li>\u914d\u7f6e\u548c\u7ba1\u7406\u7f51\u7edc\u670d\u52a1\uff0c\u5b66\u4e60\u7f51\u7edc\u5b89\u5168\u7684\u57fa\u7840\u77e5\u8bc6\u3002</li> <li>\u5b9e\u65bd\u9632\u706b\u5899\u3001\u8eab\u4efd\u9a8c\u8bc1\u548c\u8bbf\u95ee\u63a7\u5236\u3002</li> <li>\u5206\u5e03\u5f0f\u7cfb\u7edf\uff1a</li> <li>\u5b66\u4e60\u5982\u4f55\u6784\u5efa\u548c\u7ba1\u7406\u5206\u5e03\u5f0f\u7cfb\u7edf\uff0c\u5305\u62ec\u6570\u636e\u5e93\u3001\u6d88\u606f\u961f\u5217\u548c\u8d1f\u8f7d\u5747\u8861\u5668\u3002</li> <li>\u7814\u7a76\u5bb9\u9519\u6027\u548c\u5206\u5e03\u5f0f\u4e00\u81f4\u6027\u7684\u7406\u8bba\u548c\u5b9e\u8df5\u3002</li> <li>\u81ea\u52a8\u5316\u548c\u7f16\u6392\uff1a</li> <li>\u4f7f\u7528\u81ea\u52a8\u5316\u5de5\u5177\u548c\u7f16\u6392\u6846\u67b6\u6765\u7ba1\u7406\u548c\u90e8\u7f72\u5e94\u7528\u7a0b\u5e8f\u3002</li> <li>\u5b66\u4e60\u811a\u672c\u8bed\u8a00\u548c\u914d\u7f6e\u7ba1\u7406\u5de5\u5177\u3002</li> <li>\u5927\u6570\u636e\u548c\u6570\u636e\u79d1\u5b66\uff1a</li> <li>\u5b66\u4e60\u5982\u4f55\u4f7f\u7528\u4e91\u5e73\u53f0\u5904\u7406\u548c\u5206\u6790\u5927\u89c4\u6a21\u6570\u636e\u3002</li> <li>\u63a2\u7d22\u673a\u5668\u5b66\u4e60\u548c\u4eba\u5de5\u667a\u80fd\u5e94\u7528\u3002</li> <li>Web\u5f00\u53d1\u548c\u5e94\u7528\u90e8\u7f72\uff1a</li> <li>\u6784\u5efa\u548c\u90e8\u7f72Web\u5e94\u7528\u7a0b\u5e8f\uff0c\u4e86\u89e3\u4e91\u4e0a\u7684\u6258\u7ba1\u670d\u52a1\u3002</li> <li>\u5b66\u4e60\u4f7f\u7528\u5bb9\u5668\u548c\u670d\u52a1\u5668less\u67b6\u6784\u3002</li> <li>\u5bb9\u5668\u5316\u6280\u672f\uff1a</li> <li>\u4f7f\u7528Docker\u7b49\u5bb9\u5668\u6280\u672f\u6784\u5efa\u3001\u90e8\u7f72\u548c\u7ba1\u7406\u5e94\u7528\u7a0b\u5e8f\u3002</li> <li>\u5b66\u4e60Kubernetes\u7b49\u5bb9\u5668\u7f16\u6392\u5de5\u5177\u3002</li> </ol> <p>aliyun\u670d\u52a1\u5668\uff1a ssh root@101.201.46.135</p> <p>\u5b9d\u5854\u9762\u677f </p> <p>\u6700\u540e\u8fd8\u662f\u91c7\u7528ssh\u7684\u65b9\u6cd5</p> <p>SSH\u514d\u5bc6\u767b\u5f55\uff08SSH Public Key Authentication\uff09\u662f\u4e00\u79cd\u901a\u8fc7\u4f7f\u7528\u5bc6\u94a5\u5bf9\u800c\u4e0d\u662f\u5bc6\u7801\u8fdb\u884cSSH\u767b\u5f55\u7684\u65b9\u6cd5\uff0c\u63d0\u9ad8\u4e86\u5b89\u5168\u6027\u5e76\u7b80\u5316\u4e86\u767b\u5f55\u8fc7\u7a0b\u3002\u4ee5\u4e0b\u662fSSH\u514d\u5bc6\u767b\u5f55\u7684\u914d\u7f6e\u8fc7\u7a0b\uff1a</p> <ol> <li>\u751f\u6210\u5bc6\u94a5\u5bf9\uff1a \u5728\u672c\u5730\u673a\u5668\u4e0a\u751f\u6210\u4e00\u5bf9\u5bc6\u94a5\uff0c\u5305\u62ec\u79c1\u94a5\u548c\u516c\u94a5\u3002\u79c1\u94a5\u5b58\u50a8\u5728\u672c\u5730\u673a\u5668\u4e0a\uff0c\u800c\u516c\u94a5\u4f1a\u88ab\u4f20\u8f93\u5230\u8fdc\u7a0b\u673a\u5668\u4e0a\u3002</li> </ol> <p>\u4f7f\u7528\u4ee5\u4e0b\u547d\u4ee4\u751f\u6210\u5bc6\u94a5\u5bf9\uff1a</p> <p><code>bashCopy code    ssh-keygen -t rsa</code></p> <p>\u8fd9\u4f1a\u5728<code>~/.ssh/</code>\u76ee\u5f55\u4e0b\u751f\u6210<code>id_rsa</code>\uff08\u79c1\u94a5\uff09\u548c<code>id_rsa.pub</code>\uff08\u516c\u94a5\uff09\u6587\u4ef6\u3002</p> <ol> <li>\u5c06\u516c\u94a5\u590d\u5236\u5230\u8fdc\u7a0b\u670d\u52a1\u5668\uff1a \u5c06\u672c\u5730\u751f\u6210\u7684\u516c\u94a5\u590d\u5236\u5230\u8fdc\u7a0b\u670d\u52a1\u5668\u7684<code>~/.ssh/authorized_keys</code>\u6587\u4ef6\u4e2d\u3002\u53ef\u4ee5\u4f7f\u7528<code>ssh-copy-id</code>\u547d\u4ee4\uff0c\u5b83\u4f1a\u81ea\u52a8\u5c06\u516c\u94a5\u6dfb\u52a0\u5230\u76ee\u6807\u7528\u6237\u7684<code>authorized_keys</code>\u6587\u4ef6\u4e2d\u3002</li> </ol> <p><code>bashCopy code    ssh-copy-id username@remote_host</code></p> <p>\u5982\u679c<code>ssh-copy-id</code>\u547d\u4ee4\u4e0d\u53ef\u7528\uff0c\u53ef\u4ee5\u624b\u52a8\u5c06\u516c\u94a5\u5185\u5bb9\u8ffd\u52a0\u5230\u8fdc\u7a0b\u670d\u52a1\u5668\u7684<code>~/.ssh/authorized_keys</code>\u6587\u4ef6\u4e2d\u3002</p> <ol> <li>\u8bbe\u7f6e\u6743\u9650\uff1a \u786e\u4fdd<code>~/.ssh/</code> \u76ee\u5f55\u548c <code>~/.ssh/authorized_keys</code> \u6587\u4ef6\u7684\u6743\u9650\u6b63\u786e\u3002\u6743\u9650\u8bbe\u7f6e\u5bf9\u4e8eSSH\u7684\u5b89\u5168\u6027\u81f3\u5173\u91cd\u8981\u3002</li> </ol> <p><code>bashCopy codechmod 700 ~/.ssh    chmod 600 ~/.ssh/authorized_keys</code></p> <ol> <li>\u6d4b\u8bd5SSH\u514d\u5bc6\u767b\u5f55\uff1a \u5c1d\u8bd5\u4f7f\u7528SSH\u8fde\u63a5\u5230\u8fdc\u7a0b\u670d\u52a1\u5668\uff0c\u5e94\u8be5\u4e0d\u518d\u9700\u8981\u8f93\u5165\u5bc6\u7801\u3002</li> </ol> <p><code>bashCopy code    ssh username@remote_host</code></p> <p>\u5982\u679c\u4e00\u5207\u8bbe\u7f6e\u6b63\u786e\uff0c\u4f60\u5c06\u53ef\u4ee5\u65e0\u5bc6\u7801\u767b\u5f55\u5230\u8fdc\u7a0b\u670d\u52a1\u5668\u3002</p> <p>\u8bf7\u6ce8\u610f\uff0c\u4e3a\u4e86\u5b89\u5168\u8d77\u89c1\uff0c\u79c1\u94a5\u6587\u4ef6\uff08<code>id_rsa</code>\uff09\u5e94\u8be5\u4fdd\u6301\u5728\u672c\u5730\u673a\u5668\u4e0a\uff0c\u5e76\u4e14\u4e0d\u5e94\u8be5\u5206\u4eab\u7ed9\u5176\u4ed6\u4eba\u3002\u540c\u65f6\uff0c\u516c\u94a5\u6587\u4ef6\uff08<code>id_rsa.pub</code>\uff09\u9700\u8981\u4f20\u8f93\u5230\u9700\u8981\u8bbf\u95ee\u7684\u8fdc\u7a0b\u670d\u52a1\u5668\u3002</p> <p>[Linux]\u521b\u5efa\u65b0\u7528\u6237\u53ca\u7528\u6237\u6743\u9650 - \u77e5\u4e4e (zhihu.com)</p> <pre><code>scp -r /home/user/documents username@remote_host:/var/www/\nscp -P 80 baseline2.cu hjy@10.78.18.247:~/gemm\n</code></pre>"},{"location":"Others/linux%20%E5%90%AF%E5%8A%A8/#11-16","title":"11-16","text":"<p>\u670d\u52a1\u5668\u6539\u540d</p> <p>\u627e\u5230/etc/hosts  sudo vim hosts \u6dfb\u52a0\u4e00\u884c  101.201.46.135  server_jy \u518d\u5728ssh\u65f6\u91cd\u65b0add\u4e00\u4e0b\u8fd9\u4e2a\u522b\u540d\uff0c\u5b8c\u6210</p> <p>\u4ee5\u540e\u5c31\u53ebserver_jy\u4e86~</p> <p>\u76d1\u542c\u7aef\u53e3</p> <p>\u5b89\u5168\u7ec4</p> <p>\u67e5\u627e\u547d\u4ee4</p> <p>```[root@iZ2ze72tpnr9ta1r8uvbujZ /]# find / -name nginx [root@iZ2ze72tpnr9ta1r8uvbujZ /]# find / -name nginx /www/server/nginx /www/server/nginx/src/objs/nginx /www/server/nginx/sbin/nginx /www/server/panel/rewrite/nginx /www/server/panel/vhost/nginx /www/server/panel/vhost/template/nginx /etc/rc.d/init.d/nginx /usr/bin/nginx /usr/local/nginx [root@iZ2ze72tpnr9ta1r8uvbujZ /]#</p> <pre><code>\n/usr/bin\n\n/usr/local\n\n```c\n[root@iZ2ze72tpnr9ta1r8uvbujZ /]# start nginx\n-bash: start: command not found\n[root@iZ2ze72tpnr9ta1r8uvbujZ /]# nginx\nnginx: [emerg] bind() to 0.0.0.0:888 failed (98: Address already in use)\nnginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\nnginx: [emerg] bind() to 0.0.0.0:888 failed (98: Address already in use)\nnginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\nnginx: [emerg] bind() to 0.0.0.0:888 failed (98: Address already in use)\nnginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\nnginx: [emerg] bind() to 0.0.0.0:888 failed (98: Address already in use)\nnginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\nnginx: [emerg] bind() to 0.0.0.0:888 failed (98: Address already in use)\nnginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\nnginx: [emerg] still could not bind()\n[root@iZ2ze72tpnr9ta1r8uvbujZ /]# sudo lsof -i :80\nCOMMAND      PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nAliYunDun   1473 root   11u  IPv4  27166      0t0  TCP iZ2ze72tpnr9ta1r8uvbujZ:37902-&gt;100.100.30.26:http (ESTABLISHED)\nnginx     269834 root    9u  IPv4 679139      0t0  TCP *:http (LISTEN)\nnginx     269835  www    9u  IPv4 679139      0t0  TCP *:http (LISTEN)\nnginx     269836  www    9u  IPv4 679139      0t0  TCP *:http (LISTEN)\n[root@iZ2ze72tpnr9ta1r8uvbujZ /]#\n</code></pre>"},{"location":"Others/linux%20%E5%90%AF%E5%8A%A8/#grep","title":"grep","text":"<p><code>grep</code>\u662f\u4e00\u4e2a\u5728\u6587\u672c\u4e2d\u641c\u7d22\u6a21\u5f0f\u7684\u5f3a\u5927\u547d\u4ee4\u884c\u5de5\u5177\u3002\u5b83\u7684\u540d\u5b57\u6765\u6e90\u4e8e\u5168\u5c40\u6b63\u5219\u8868\u8fbe\u5f0f\u6253\u5370\uff08Global Regular Expression Print\uff09\u3002</p> <p>\u4e0b\u9762\u662f<code>grep</code>\u547d\u4ee4\u7684\u57fa\u672c\u7528\u6cd5\u548c\u4e00\u4e9b\u5e38\u89c1\u9009\u9879\uff1a</p> <pre><code>bashCopy code\ngrep [options] pattern [file...]\n</code></pre> <ul> <li><code>pattern</code>\uff1a\u8981\u641c\u7d22\u7684\u6a21\u5f0f\uff0c\u53ef\u4ee5\u662f\u5b57\u7b26\u4e32\u6216\u6b63\u5219\u8868\u8fbe\u5f0f\u3002</li> <li><code>file</code>\uff1a\u8981\u5728\u5176\u4e2d\u641c\u7d22\u6a21\u5f0f\u7684\u6587\u4ef6\u3002\u5982\u679c\u6ca1\u6709\u63d0\u4f9b\u6587\u4ef6\u540d\uff0c<code>grep</code>\u5c06\u4ece\u6807\u51c6\u8f93\u5165\u4e2d\u8bfb\u53d6\u3002</li> </ul> <p>\u5e38\u89c1\u9009\u9879\uff1a</p> <ul> <li><code>-i</code>\uff1a\u5ffd\u7565\u5927\u5c0f\u5199\u3002</li> <li><code>-r</code>\u6216<code>-R</code>\uff1a\u9012\u5f52\u641c\u7d22\u5b50\u76ee\u5f55\u3002</li> <li><code>-n</code>\uff1a\u663e\u793a\u5339\u914d\u884c\u7684\u884c\u53f7\u3002</li> <li><code>-v</code>\uff1a\u53cd\u5411\u9009\u62e9\uff0c\u663e\u793a\u4e0d\u5339\u914d\u7684\u884c\u3002</li> <li><code>-l</code>\uff1a\u53ea\u663e\u793a\u5305\u542b\u5339\u914d\u9879\u7684\u6587\u4ef6\u540d\u3002</li> <li><code>-c</code>\uff1a\u53ea\u663e\u793a\u5339\u914d\u7684\u884c\u6570\u800c\u4e0d\u663e\u793a\u5339\u914d\u7684\u5185\u5bb9\u3002</li> <li><code>-A</code>\uff0c<code>-B</code>\uff0c<code>-C</code>\uff1a\u663e\u793a\u5339\u914d\u884c\u7684\u4e0a\u4e0b\u6587\u884c\u3002</li> <li><code>-e</code>\uff1a\u6307\u5b9a\u591a\u4e2a\u6a21\u5f0f\u3002</li> </ul> <p>\u793a\u4f8b\uff1a</p> <ol> <li>\u5728\u6587\u4ef6\u4e2d\u641c\u7d22\u5305\u542b\u5173\u952e\u5b57\u7684\u884c\uff1a</li> </ol> <p><code>bashCopy code    grep \"keyword\" filename</code></p> <ol> <li>\u9012\u5f52\u641c\u7d22\u76ee\u5f55\u4e0b\u6240\u6709\u6587\u4ef6\u4e2d\u5305\u542b\u5173\u952e\u5b57\u7684\u884c\uff1a</li> </ol> <p><code>bashCopy code    grep -r \"keyword\" directory</code></p> <ol> <li>\u5ffd\u7565\u5927\u5c0f\u5199\uff1a</li> </ol> <p><code>bashCopy code    grep -i \"keyword\" filename</code></p> <ol> <li>\u663e\u793a\u5339\u914d\u884c\u7684\u884c\u53f7\uff1a</li> </ol> <p><code>bashCopy code    grep -n \"keyword\" filename</code></p> <ol> <li>\u53cd\u5411\u9009\u62e9\uff0c\u663e\u793a\u4e0d\u5339\u914d\u7684\u884c\uff1a</li> </ol> <p><code>bashCopy code    grep -v \"keyword\" filename</code></p> <p>\u8fd9\u53ea\u662f\u4e00\u4e9b<code>grep</code>\u547d\u4ee4\u7684\u57fa\u672c\u7528\u6cd5\u548c\u9009\u9879\uff0c<code>grep</code>\u6709\u5f88\u591a\u5176\u4ed6\u9009\u9879\u548c\u529f\u80fd\uff0c\u4f60\u53ef\u4ee5\u901a\u8fc7<code>man grep</code>\u67e5\u770b<code>grep</code>\u7684\u624b\u518c\u9875\u4ee5\u83b7\u53d6\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\u3002\\</p> <p>\u7adf\u7136\u6ca1\u6709apt-get\uff1f\uff1f</p> <pre><code>[root@iZ2ze72tpnr9ta1r8uvbujZ hjy]# lsb_release -a\nLSB Version:    :core-4.1-amd64:core-4.1-noarch\nDistributor ID: AlibabaCloud\nDescription:    Alibaba Cloud Linux release 3 (Soaring Falcon)\nRelease:        3\nCodename:       SoaringFalcon\n</code></pre> <p>\u4e3a\u4ec0\u4e48\u547d\u4ee4\u67e5\u627e\u4e0d\u5230\u662fbash\u6253\u5934</p> <pre><code>bash: apt-get: command not found\n</code></pre> <p>\u5982\u679c\u4f60\u5728\u4f7f\u7528\u547d\u4ee4\u65f6\u9047\u5230 \"\u547d\u4ee4\u627e\u4e0d\u5230\" \u7684\u9519\u8bef\uff0c\u8fd9\u53ef\u80fd\u6709\u591a\u4e2a\u539f\u56e0\u3002\u4e00\u79cd\u53ef\u80fd\u6027\u662f\u7cfb\u7edf\u65e0\u6cd5\u627e\u5230\u6216\u8bc6\u522b\u8be5\u547d\u4ee4\uff0c\u8fd9\u53ef\u80fd\u4e0e\u73af\u5883\u53d8\u91cf\u6216\u547d\u4ee4\u7684\u4f4d\u7f6e\u6709\u5173\u3002\u4ee5\u4e0b\u662f\u4e00\u4e9b\u53ef\u80fd\u7684\u539f\u56e0\u548c\u89e3\u51b3\u65b9\u6cd5\uff1a</p> <ol> <li>\u73af\u5883\u53d8\u91cf\u95ee\u9898\uff1a \u786e\u4fdd\u547d\u4ee4\u6240\u5728\u7684\u8def\u5f84\u5305\u542b\u5728\u7cfb\u7edf\u7684<code>PATH</code>\u73af\u5883\u53d8\u91cf\u4e2d\u3002<code>PATH</code>\u73af\u5883\u53d8\u91cf\u5305\u542b\u4e00\u7ec4\u76ee\u5f55\uff0c\u7cfb\u7edf\u5728\u8fd9\u4e9b\u76ee\u5f55\u4e2d\u67e5\u627e\u53ef\u6267\u884c\u6587\u4ef6\u3002\u4f60\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u547d\u4ee4\u67e5\u770b<code>PATH</code>\uff1a</li> </ol> <p><code>bashCopy code    echo $PATH</code></p> <p>\u5982\u679c\u547d\u4ee4\u6240\u5728\u7684\u76ee\u5f55\u4e0d\u5728<code>PATH</code>\u4e2d\uff0c\u4f60\u53ef\u4ee5\u5c06\u5176\u6dfb\u52a0\u5230<code>PATH</code>\u3002\u4f8b\u5982\uff1a</p> <p><code>bashCopy code    export PATH=$PATH:/path/to/your/command</code></p> <p>\u5728\u8fd9\u91cc\uff0c\u5c06<code>/path/to/your/command</code>\u66ff\u6362\u4e3a\u5305\u542b\u4f60\u7684\u547d\u4ee4\u7684\u5b9e\u9645\u8def\u5f84\u3002</p> <ol> <li> <p>\u547d\u4ee4\u672a\u5b89\u88c5\uff1a \u786e\u4fdd\u4f60\u5c1d\u8bd5\u8fd0\u884c\u7684\u547d\u4ee4\u5df2\u7ecf\u5b89\u88c5\u5728\u7cfb\u7edf\u4e0a\u3002\u6709\u4e9b\u547d\u4ee4\u53ef\u80fd\u9700\u8981\u5355\u72ec\u5b89\u88c5\u3002\u4f60\u53ef\u4ee5\u4f7f\u7528\u7cfb\u7edf\u7684\u5305\u7ba1\u7406\u5668\u5b89\u88c5\u5b83\u4eec\u3002</p> </li> <li> <p>\u6587\u4ef6\u6743\u9650\u95ee\u9898\uff1a \u68c0\u67e5\u547d\u4ee4\u6587\u4ef6\u7684\u6743\u9650\uff0c\u786e\u4fdd\u4f60\u6709\u6267\u884c\u6743\u9650\u3002\u4f60\u53ef\u4ee5\u4f7f\u7528<code>ls -l</code>\u547d\u4ee4\u67e5\u770b\u6587\u4ef6\u6743\u9650\uff0c\u4f8b\u5982\uff1a</p> </li> </ol> <p><code>bashCopy code    ls -l /path/to/your/command</code></p> <p>\u5982\u679c\u6ca1\u6709\u6267\u884c\u6743\u9650\uff0c\u53ef\u4ee5\u4f7f\u7528<code>chmod</code>\u547d\u4ee4\u6dfb\u52a0\u6267\u884c\u6743\u9650\uff1a</p> <p><code>bashCopy code    chmod +x /path/to/your/command</code></p> <ol> <li>\u547d\u4ee4\u62fc\u5199\u9519\u8bef\uff1a \u8bf7\u786e\u4fdd\u4f60\u6b63\u786e\u62fc\u5199\u4e86\u8981\u8fd0\u884c\u7684\u547d\u4ee4\u3002</li> </ol> <p>\u5982\u679c\u4f60\u80fd\u63d0\u4f9b\u66f4\u5177\u4f53\u7684\u9519\u8bef\u4fe1\u606f\u6216\u547d\u4ee4\u793a\u4f8b\uff0c\u6211\u53ef\u4ee5\u63d0\u4f9b\u66f4\u8be6\u7ec6\u7684\u5e2e\u52a9\u3002</p> <pre><code>[root@iZ2ze72tpnr9ta1r8uvbujZ hjy]# echo $PATH\n/home/hjy/.local/bin:/home/hjy/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin\n</code></pre> <p>\u53d1\u884c\u7248\u95ee\u9898</p> <p>\u6ca1\u6709apt-get</p> <pre><code>sudo dnf install ?\n[root@iZ2ze72tpnr9ta1r8uvbujZ hjy]# sudo dnf install pip\nLast metadata expiration check: 3:41:20 ago on Sat Nov 18 08:06:48 2023.\nNo match for argument: pip\nError: Unable to find a match: pip\n</code></pre> <p>wordpress\u5efa\u7ad9  ok</p> <p>mysql\u6570\u636e\u5e93\u4f7f\u7528</p> <p>\u57df\u540d\u53ea\u4e0d\u8fc7\u662f\u5c06101.201.46.135\u4e4b\u7c7b\u7684ip\u5730\u5740\u7528DNS\u670d\u52a1\u5668\u6620\u5c04\u5230\u53ef\u8bb0\u5fc6\u7684\u5b57\u7b26\u4e32\uff1f</p> <p>\u662f\u7684\uff0c\u57df\u540d\u7cfb\u7edf\uff08DNS\uff09\u7684\u4e3b\u8981\u4f5c\u7528\u662f\u5c06\u6613\u4e8e\u8bb0\u5fc6\u7684\u57df\u540d\u6620\u5c04\u5230\u8ba1\u7b97\u673a\u7f51\u7edc\u4e2d\u7684IP\u5730\u5740\u3002IP\u5730\u5740\u662f\u4e92\u8054\u7f51\u4e0a\u8ba1\u7b97\u673a\u7684\u552f\u4e00\u6807\u8bc6\u7b26\uff0c\u901a\u8fc7\u5c06\u57df\u540d\u6620\u5c04\u5230IP\u5730\u5740\uff0c\u4eba\u4eec\u53ef\u4ee5\u4f7f\u7528\u5bb9\u6613\u8bb0\u5fc6\u7684\u540d\u79f0\u6765\u8bbf\u95ee\u7f51\u7ad9\u3001\u670d\u52a1\u5668\u6216\u5176\u4ed6\u7f51\u7edc\u670d\u52a1\uff0c\u800c\u4e0d\u5fc5\u8bb0\u4f4f\u590d\u6742\u7684\u6570\u5b57\u5730\u5740\u3002</p> <p>\u4f8b\u5982\uff0c\u5c06\u57df\u540d \"example.com\" \u6620\u5c04\u5230 IP \u5730\u5740 \"101.201.46.135\"\u3002\u5f53\u4f60\u5728\u6d4f\u89c8\u5668\u4e2d\u952e\u5165 \"example.com\" \u65f6\uff0c\u8ba1\u7b97\u673a\u9996\u5148\u4f1a\u67e5\u8be2DNS\u670d\u52a1\u5668\uff0c\u83b7\u53d6\u4e0e \"example.com\" \u76f8\u5173\u8054\u7684IP\u5730\u5740\uff0c\u7136\u540e\u4f7f\u7528\u8fd9\u4e2aIP\u5730\u5740\u5efa\u7acb\u8fde\u63a5\u5230\u76f8\u5e94\u7684\u670d\u52a1\u5668\u3002</p> <p>DNS\u4f7f\u7528\u4e00\u4e2a\u5c42\u6b21\u5316\u7684\u7ed3\u6784\uff0c\u5305\u62ec\u9876\u7ea7\u57df\uff08\u5982.com\u3001.org\uff09\u3001\u4e8c\u7ea7\u57df\uff08\u5982example.com\uff09\u3001\u5b50\u57df\u7b49\u3002\u8fd9\u4e2a\u7ed3\u6784\u5141\u8bb8\u5168\u7403\u8303\u56f4\u5185\u552f\u4e00\u5730\u6807\u8bc6\u4e0d\u540c\u7684\u57df\u540d\uff0c\u5e76\u901a\u8fc7\u5206\u5e03\u5f0f\u7684DNS\u670d\u52a1\u5668\u7cfb\u7edf\u6765\u7ba1\u7406\u8fd9\u4e9b\u6620\u5c04\u5173\u7cfb\u3002</p> <p>\u603b\u7684\u6765\u8bf4\uff0c\u57df\u540d\u7684\u4f5c\u7528\u662f\u63d0\u4f9b\u4e00\u4e2a\u4fbf\u4e8e\u8bb0\u5fc6\u548c\u4f7f\u7528\u7684\u65b9\u5f0f\u6765\u8bbf\u95ee\u4e92\u8054\u7f51\u4e0a\u7684\u8d44\u6e90\uff0c\u800c\u4e0d\u5fc5\u8bb0\u4f4f\u5b83\u4eec\u7684\u5177\u4f53IP\u5730\u5740\u3002</p> <p>\u81ea\u884c\u5efa\u7ad9\u6709\u5f88\u591a\u9009\u62e9\uff0c\u53d6\u51b3\u4e8e\u4f60\u7684\u6280\u672f\u6c34\u5e73\u3001\u9700\u6c42\u3001\u9884\u7b97\u548c\u4e2a\u4eba\u504f\u597d\u3002\u4ee5\u4e0b\u662f\u4e00\u4e9b\u5e38\u89c1\u7684\u81ea\u884c\u5efa\u7ad9\u5de5\u5177\u548c\u5e73\u53f0\uff1a</p> <ol> <li>WordPress\uff1a WordPress \u662f\u4e00\u4e2a\u6d41\u884c\u7684\u5f00\u6e90\u5185\u5bb9\u7ba1\u7406\u7cfb\u7edf (CMS)\uff0c\u9002\u7528\u4e8e\u5404\u79cd\u7c7b\u578b\u7684\u7f51\u7ad9\uff0c\u4ece\u535a\u5ba2\u5230\u4f01\u4e1a\u7f51\u7ad9\u3002\u5b83\u6709\u5927\u91cf\u7684\u4e3b\u9898\u548c\u63d2\u4ef6\uff0c\u6613\u4e8e\u4f7f\u7528\uff0c\u9002\u5408\u4e0d\u5177\u5907\u7f16\u7a0b\u6280\u80fd\u7684\u7528\u6237\u3002</li> <li>Jekyll\uff1a Jekyll \u662f\u4e00\u4e2a\u9759\u6001\u7f51\u7ad9\u751f\u6210\u5668\uff0c\u4f7f\u7528 Ruby \u8bed\u8a00\u3002\u5b83\u9002\u7528\u4e8e\u535a\u5ba2\u548c\u7b80\u5355\u7684\u7f51\u7ad9\uff0c\u751f\u6210\u7684\u7f51\u7ad9\u53ef\u4ee5\u90e8\u7f72\u5230\u51e0\u4e4e\u4efb\u4f55\u6258\u7ba1\u670d\u52a1\u4e0a\u3002</li> <li>Hugo\uff1a Hugo \u662f\u53e6\u4e00\u4e2a\u9759\u6001\u7f51\u7ad9\u751f\u6210\u5668\uff0c\u7528 Go \u8bed\u8a00\u7f16\u5199\uff0c\u5177\u6709\u5feb\u901f\u7684\u6784\u5efa\u901f\u5ea6\u3002\u5b83\u9002\u7528\u4e8e\u4e2a\u4eba\u535a\u5ba2\u548c\u5c0f\u578b\u7f51\u7ad9\u3002</li> <li>GitHub Pages\uff1a \u5982\u679c\u4f60\u4f7f\u7528 Git \u8fdb\u884c\u7248\u672c\u63a7\u5236\uff0c\u5e76\u4e14\u559c\u6b22\u5728 GitHub \u4e0a\u6258\u7ba1\u4ee3\u7801\uff0cGitHub Pages \u662f\u4e00\u4e2a\u514d\u8d39\u7684\u9759\u6001\u7f51\u7ad9\u6258\u7ba1\u670d\u52a1\u3002\u5b83\u4e0e Jekyll \u96c6\u6210\u5f97\u5f88\u597d\uff0c\u4f46\u4e5f\u652f\u6301\u5176\u4ed6\u9759\u6001\u7f51\u7ad9\u751f\u6210\u5668\u3002</li> <li>Wix\uff1a Wix \u662f\u4e00\u4e2a\u6613\u4e8e\u4f7f\u7528\u7684\u7f51\u7ad9\u6784\u5efa\u5e73\u53f0\uff0c\u63d0\u4f9b\u5404\u79cd\u6a21\u677f\u548c\u62d6\u653e\u5f0f\u7f16\u8f91\u5668\u3002\u9002\u5408\u90a3\u4e9b\u4e0d\u5177\u5907\u7f16\u7801\u7ecf\u9a8c\u7684\u7528\u6237\u3002</li> <li>Squarespace\uff1a Squarespace \u662f\u4e00\u4e2a\u96c6\u6210\u7684\u7f51\u7ad9\u5efa\u8bbe\u5e73\u53f0\uff0c\u63d0\u4f9b\u4e13\u4e1a\u8bbe\u8ba1\u7684\u6a21\u677f\u548c\u7b80\u5355\u7684\u62d6\u653e\u7f16\u8f91\u5de5\u5177\u3002\u9002\u7528\u4e8e\u521b\u610f\u548c\u5546\u4e1a\u7f51\u7ad9\u3002</li> <li>Django\uff1a \u5982\u679c\u4f60\u6709\u7f16\u7a0b\u7ecf\u9a8c\uff0c\u5e76\u4e14\u60f3\u8981\u66f4\u5927\u7684\u7075\u6d3b\u6027\uff0cDjango \u662f\u4e00\u4e2a\u5f3a\u5927\u7684Python\u6846\u67b6\uff0c\u9002\u7528\u4e8e\u5f00\u53d1\u590d\u6742\u7684Web\u5e94\u7528\u7a0b\u5e8f\u3002</li> <li>VuePress \u548c Nuxt.js\uff1a \u5982\u679c\u4f60\u719f\u6089 Vue.js\uff0cVuePress \u9002\u7528\u4e8e\u6587\u6863\u548c\u535a\u5ba2\u3002\u800c Nuxt.js \u5219\u662f\u4e00\u4e2a\u7528\u4e8e\u6784\u5efaVue.js\u5e94\u7528\u7a0b\u5e8f\u7684\u6846\u67b6\uff0c\u4e5f\u53ef\u4ee5\u7528\u4e8e\u670d\u52a1\u5668\u6e32\u67d3\u548c\u9759\u6001\u7ad9\u70b9\u751f\u6210\u3002</li> </ol> <p>\u9009\u62e9\u54ea\u4e2a\u5de5\u5177\u53d6\u51b3\u4e8e\u4f60\u7684\u5177\u4f53\u9700\u6c42\u548c\u6280\u672f\u504f\u597d\u3002\u5bf9\u4e8e\u521d\u5b66\u8005\uff0c\u4f7f\u7528WordPress\u3001Wix\u6216Squarespace\u53ef\u80fd\u662f\u66f4\u5bb9\u6613\u4e0a\u624b\u7684\u9009\u62e9\u3002\u5bf9\u4e8e\u6709\u4e00\u4e9b\u7f16\u7a0b\u7ecf\u9a8c\u7684\u4eba\u6765\u8bf4\uff0c\u9759\u6001\u7f51\u7ad9\u751f\u6210\u5668\u5982Jekyll\u3001Hugo\u6216VuePress\u53ef\u80fd\u662f\u4e00\u4e2a\u4e0d\u9519\u7684\u9009\u62e9\u3002</p> <p></p> <p>2023_DD\u662fguahao\u8001\u5e08\u5728github\u4e0a\u7684\u4ed3\u5e93\u7684\u5168\u90e8\u5185\u5bb9\uff0c\u5176\u4e2d\u5e76\u672a\u5305\u62ecnode_modules,src/assets/javascripts\u6587\u4ef6\u7684\u5185\u5bb9\uff0c\u8bf7\u95ee</p> <p>github.io\u5efa\u7ad9\u8fc7\u7a0b</p> <p>\u4f7f\u7528</p> <p></p> <p></p>"}]}